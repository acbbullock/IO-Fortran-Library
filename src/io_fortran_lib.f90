!!---------------------------------------------------------------------------------------------------------------------
!!  This module file contains common i/o procedures for arrays of complex, real, integer, and character type. Common
!!  operations include printing array slices to stdout, reading/writing multidimensional arrays from/to text files
!!  and binary files. Convenience functions for number -> string conversion are provided as well as vector -> string
!!  conversion with a specified delimiter. This module is F2018 compliant, has no external dependencies, and has a max
!!  line length of 120.
!!---------------------------------------------------------------------------------------------------------------------
module io_fortran_lib
    use, intrinsic :: iso_fortran_env, only: real128,real64,real32, int64,int32,int16,int8, input_unit, output_unit
    implicit none (type,external)
    private

    !! Public APIs ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public :: aprint, to_str, to_file, from_file                                                           !! Array I/O
    public :: str, echo                                                                                   !! String I/O
    public :: nl                                                                                           !! Constants

    !! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    character(len=1), parameter :: nl = new_line('a')                                             !! New line character

    character(len=*), dimension(*), parameter :: text_ext = [ 'csv', 'txt', 'ods', 'odf', 'odm', 'odt',  &
                                                              'xls', 'xlsx', 'doc', 'docx', 'md', 'log', &
                                                              'rtf', 'org', 'embed' ]

    character(len=*), dimension(*), parameter :: binary_ext = [ 'dat', 'bin' ]

    character(len=*), dimension(*), parameter :: real_fmts = [ 'es', 'f', 'z' ]

    character(len=*), dimension(*), parameter :: int_fmts = [ 'i', 'z' ]

    character(len=*), dimension(*), parameter :: locales = [ 'US', 'EU' ]

    interface aprint                                                                        !! Submodule array_printing
        module impure subroutine aprint_1dc128(x, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc128
        module impure subroutine aprint_1dc64(x, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc64
        module impure subroutine aprint_1dc32(x, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc32

        module impure subroutine aprint_2dc128(x, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc128
        module impure subroutine aprint_2dc64(x, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc64
        module impure subroutine aprint_2dc32(x, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc32

        module impure subroutine aprint_1dr128(x, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr128
        module impure subroutine aprint_1dr64(x, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr64
        module impure subroutine aprint_1dr32(x, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr32

        module impure subroutine aprint_2dr128(x, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr128
        module impure subroutine aprint_2dr64(x, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr64
        module impure subroutine aprint_2dr32(x, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr32

        module impure subroutine aprint_1di64(x, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di64
        module impure subroutine aprint_1di32(x, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di32
        module impure subroutine aprint_1di16(x, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di16
        module impure subroutine aprint_1di8(x, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di8

        module impure subroutine aprint_2di64(x, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di64
        module impure subroutine aprint_2di32(x, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di32
        module impure subroutine aprint_2di16(x, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di16
        module impure subroutine aprint_2di8(x, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di8

        module impure subroutine aprint_1dchar(x)
            character(len=*), dimension(:), intent(in) :: x
        end subroutine aprint_1dchar

        module impure subroutine aprint_2dchar(x)
            character(len=*), dimension(:,:), intent(in) :: x
        end subroutine aprint_2dchar
    end interface

    interface str                                                                              !! Submodule internal_io
        module pure function str_c128(x, locale, fmt, decimals, im) result(x_str)
            complex(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c128
        module pure function str_c64(x, locale, fmt, decimals, im) result(x_str)
            complex(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c64
        module pure function str_c32(x, locale, fmt, decimals, im) result(x_str)
            complex(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c32

        module pure function str_r128(x, locale, fmt, decimals) result(x_str)
            real(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r128
        module pure function str_r64(x, locale, fmt, decimals) result(x_str)
            real(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r64
        module pure function str_r32(x, locale, fmt, decimals) result(x_str)
            real(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r32

        module pure function str_i64(x, fmt) result(x_str)
            integer(int64), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i64
        module pure function str_i32(x, fmt) result(x_str)
            integer(int32), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i32
        module pure function str_i16(x, fmt) result(x_str)
            integer(int16), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i16
        module pure function str_i8(x, fmt) result(x_str)
            integer(int8), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i8
    end interface

    interface to_str                                                                           !! Submodule internal_io
        module pure function to_str_1dc128(x, locale, delim, fmt, decimals, im) result(x_str)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function to_str_1dc128
        module pure function to_str_1dc64(x, locale, delim, fmt, decimals, im) result(x_str)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function to_str_1dc64
        module pure function to_str_1dc32(x, locale, delim, fmt, decimals, im) result(x_str)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function to_str_1dc32

        module pure function to_str_1dr128(x, locale, delim, fmt, decimals) result(x_str)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function to_str_1dr128
        module pure function to_str_1dr64(x, locale, delim, fmt, decimals) result(x_str)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function to_str_1dr64
        module pure function to_str_1dr32(x, locale, delim, fmt, decimals) result(x_str)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function to_str_1dr32

        module pure function to_str_1di64(x, delim, fmt) result(x_str)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function to_str_1di64
        module pure function to_str_1di32(x, delim, fmt) result(x_str)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function to_str_1di32
        module pure function to_str_1di16(x, delim, fmt) result(x_str)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function to_str_1di16
        module pure function to_str_1di8(x, delim, fmt) result(x_str)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function to_str_1di8

        module pure function to_str_1dchar(x, delim, trimstring) result(x_str)
            character(len=*), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: delim
            logical, intent(in), optional :: trimstring
            character(len=:), allocatable :: x_str
        end function to_str_1dchar
    end interface

    interface to_file                                                                              !! Submodule file_io
        module impure subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc128
        module impure subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc64
        module impure subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc32

        module impure subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc128
        module impure subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc64
        module impure subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc32

        module impure subroutine to_file_3dc128(x, file_name)
            complex(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc128
        module impure subroutine to_file_3dc64(x, file_name)
            complex(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc64
        module impure subroutine to_file_3dc32(x, file_name)
            complex(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc32

        module impure subroutine to_file_4dc128(x, file_name)
            complex(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc128
        module impure subroutine to_file_4dc64(x, file_name)
            complex(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc64
        module impure subroutine to_file_4dc32(x, file_name)
            complex(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc32

        module impure subroutine to_file_5dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc128
        module impure subroutine to_file_5dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc64
        module impure subroutine to_file_5dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc32

        module impure subroutine to_file_6dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc128
        module impure subroutine to_file_6dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc64
        module impure subroutine to_file_6dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc32

        module impure subroutine to_file_7dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc128
        module impure subroutine to_file_7dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc64
        module impure subroutine to_file_7dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc32

        module impure subroutine to_file_8dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc128
        module impure subroutine to_file_8dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc64
        module impure subroutine to_file_8dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc32

        module impure subroutine to_file_9dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc128
        module impure subroutine to_file_9dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc64
        module impure subroutine to_file_9dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc32

        module impure subroutine to_file_10dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc128
        module impure subroutine to_file_10dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc64
        module impure subroutine to_file_10dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc32

        module impure subroutine to_file_11dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc128
        module impure subroutine to_file_11dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc64
        module impure subroutine to_file_11dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc32

        module impure subroutine to_file_12dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc128
        module impure subroutine to_file_12dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc64
        module impure subroutine to_file_12dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc32

        module impure subroutine to_file_13dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc128
        module impure subroutine to_file_13dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc64
        module impure subroutine to_file_13dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc32

        module impure subroutine to_file_14dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc128
        module impure subroutine to_file_14dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc64
        module impure subroutine to_file_14dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc32

        module impure subroutine to_file_15dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc128
        module impure subroutine to_file_15dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc64
        module impure subroutine to_file_15dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc32

        module impure subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr128
        module impure subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr64
        module impure subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr32

        module impure subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr128
        module impure subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr64
        module impure subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr32

        module impure subroutine to_file_3dr128(x, file_name)
            real(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr128
        module impure subroutine to_file_3dr64(x, file_name)
            real(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr64
        module impure subroutine to_file_3dr32(x, file_name)
            real(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr32

        module impure subroutine to_file_4dr128(x, file_name)
            real(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr128
        module impure subroutine to_file_4dr64(x, file_name)
            real(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr64
        module impure subroutine to_file_4dr32(x, file_name)
            real(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr32

        module impure subroutine to_file_5dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr128
        module impure subroutine to_file_5dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr64
        module impure subroutine to_file_5dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr32

        module impure subroutine to_file_6dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr128
        module impure subroutine to_file_6dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr64
        module impure subroutine to_file_6dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr32

        module impure subroutine to_file_7dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr128
        module impure subroutine to_file_7dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr64
        module impure subroutine to_file_7dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr32

        module impure subroutine to_file_8dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr128
        module impure subroutine to_file_8dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr64
        module impure subroutine to_file_8dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr32

        module impure subroutine to_file_9dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr128
        module impure subroutine to_file_9dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr64
        module impure subroutine to_file_9dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr32

        module impure subroutine to_file_10dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr128
        module impure subroutine to_file_10dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr64
        module impure subroutine to_file_10dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr32

        module impure subroutine to_file_11dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr128
        module impure subroutine to_file_11dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr64
        module impure subroutine to_file_11dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr32

        module impure subroutine to_file_12dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr128
        module impure subroutine to_file_12dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr64
        module impure subroutine to_file_12dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr32

        module impure subroutine to_file_13dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr128
        module impure subroutine to_file_13dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr64
        module impure subroutine to_file_13dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr32

        module impure subroutine to_file_14dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr128
        module impure subroutine to_file_14dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr64
        module impure subroutine to_file_14dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr32

        module impure subroutine to_file_15dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr128
        module impure subroutine to_file_15dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr64
        module impure subroutine to_file_15dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr32

        module impure subroutine to_file_1di64(x, file_name, header, dim, delim, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di64
        module impure subroutine to_file_1di32(x, file_name, header, dim, delim, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di32
        module impure subroutine to_file_1di16(x, file_name, header, dim, delim, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di16
        module impure subroutine to_file_1di8(x, file_name, header, dim, delim, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di8

        module impure subroutine to_file_2di64(x, file_name, header, delim, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di64
        module impure subroutine to_file_2di32(x, file_name, header, delim, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di32
        module impure subroutine to_file_2di16(x, file_name, header, delim, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di16
        module impure subroutine to_file_2di8(x, file_name, header, delim, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di8

        module impure subroutine to_file_3di64(x, file_name)
            integer(int64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di64
        module impure subroutine to_file_3di32(x, file_name)
            integer(int32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di32
        module impure subroutine to_file_3di16(x, file_name)
            integer(int16), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di16
        module impure subroutine to_file_3di8(x, file_name)
            integer(int8), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di8

        module impure subroutine to_file_4di64(x, file_name)
            integer(int64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di64
        module impure subroutine to_file_4di32(x, file_name)
            integer(int32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di32
        module impure subroutine to_file_4di16(x, file_name)
            integer(int16), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di16
        module impure subroutine to_file_4di8(x, file_name)
            integer(int8), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di8

        module impure subroutine to_file_5di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di64
        module impure subroutine to_file_5di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di32
        module impure subroutine to_file_5di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di16
        module impure subroutine to_file_5di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di8

        module impure subroutine to_file_6di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di64
        module impure subroutine to_file_6di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di32
        module impure subroutine to_file_6di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di16
        module impure subroutine to_file_6di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di8

        module impure subroutine to_file_7di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di64
        module impure subroutine to_file_7di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di32
        module impure subroutine to_file_7di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di16
        module impure subroutine to_file_7di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di8

        module impure subroutine to_file_8di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di64
        module impure subroutine to_file_8di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di32
        module impure subroutine to_file_8di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di16
        module impure subroutine to_file_8di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di8

        module impure subroutine to_file_9di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di64
        module impure subroutine to_file_9di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di32
        module impure subroutine to_file_9di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di16
        module impure subroutine to_file_9di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di8

        module impure subroutine to_file_10di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di64
        module impure subroutine to_file_10di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di32
        module impure subroutine to_file_10di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di16
        module impure subroutine to_file_10di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di8

        module impure subroutine to_file_11di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di64
        module impure subroutine to_file_11di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di32
        module impure subroutine to_file_11di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di16
        module impure subroutine to_file_11di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di8

        module impure subroutine to_file_12di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di64
        module impure subroutine to_file_12di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di32
        module impure subroutine to_file_12di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di16
        module impure subroutine to_file_12di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di8

        module impure subroutine to_file_13di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di64
        module impure subroutine to_file_13di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di32
        module impure subroutine to_file_13di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di16
        module impure subroutine to_file_13di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di8

        module impure subroutine to_file_14di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di64
        module impure subroutine to_file_14di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di32
        module impure subroutine to_file_14di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di16
        module impure subroutine to_file_14di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di8

        module impure subroutine to_file_15di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di64
        module impure subroutine to_file_15di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di32
        module impure subroutine to_file_15di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di16
        module impure subroutine to_file_15di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di8

        module impure subroutine to_file_1dchar(x, file_name, header, dim, delim)
            character(len=*), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
        end subroutine to_file_1dchar

        module impure subroutine to_file_2dchar(x, file_name, header, delim)
            character(len=*), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
        end subroutine to_file_2dchar
    end interface

    interface from_file                                                                            !! Submodule file_io
        module impure subroutine from_textfile_1dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc128
        module impure subroutine from_binaryfile_1dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc128
        module impure subroutine from_textfile_1dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc64
        module impure subroutine from_binaryfile_1dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc64
        module impure subroutine from_textfile_1dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc32
        module impure subroutine from_binaryfile_1dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc32

        module impure subroutine from_textfile_2dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc128
        module impure subroutine from_binaryfile_2dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc128
        module impure subroutine from_textfile_2dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc64
        module impure subroutine from_binaryfile_2dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc64
        module impure subroutine from_textfile_2dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc32
        module impure subroutine from_binaryfile_2dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc32

        module impure subroutine from_file_3dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc128
        module impure subroutine from_file_3dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc64
        module impure subroutine from_file_3dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc32

        module impure subroutine from_file_4dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc128
        module impure subroutine from_file_4dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc64
        module impure subroutine from_file_4dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc32

        module impure subroutine from_file_5dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc128
        module impure subroutine from_file_5dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc64
        module impure subroutine from_file_5dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc32

        module impure subroutine from_file_6dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc128
        module impure subroutine from_file_6dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc64
        module impure subroutine from_file_6dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc32

        module impure subroutine from_file_7dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc128
        module impure subroutine from_file_7dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc64
        module impure subroutine from_file_7dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc32

        module impure subroutine from_file_8dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc128
        module impure subroutine from_file_8dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc64
        module impure subroutine from_file_8dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc32

        module impure subroutine from_file_9dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc128
        module impure subroutine from_file_9dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc64
        module impure subroutine from_file_9dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc32

        module impure subroutine from_file_10dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc128
        module impure subroutine from_file_10dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc64
        module impure subroutine from_file_10dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc32

        module impure subroutine from_file_11dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc128
        module impure subroutine from_file_11dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc64
        module impure subroutine from_file_11dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc32

        module impure subroutine from_file_12dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc128
        module impure subroutine from_file_12dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc64
        module impure subroutine from_file_12dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc32

        module impure subroutine from_file_13dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc128
        module impure subroutine from_file_13dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc64
        module impure subroutine from_file_13dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc32

        module impure subroutine from_file_14dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc128
        module impure subroutine from_file_14dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc64
        module impure subroutine from_file_14dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc32

        module impure subroutine from_file_15dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc128
        module impure subroutine from_file_15dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc64
        module impure subroutine from_file_15dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc32

        module impure subroutine from_textfile_1dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr128
        module impure subroutine from_binaryfile_1dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr128
        module impure subroutine from_textfile_1dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr64
        module impure subroutine from_binaryfile_1dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr64
        module impure subroutine from_textfile_1dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr32
        module impure subroutine from_binaryfile_1dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr32

        module impure subroutine from_textfile_2dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr128
        module impure subroutine from_binaryfile_2dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr128
        module impure subroutine from_textfile_2dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr64
        module impure subroutine from_binaryfile_2dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr64
        module impure subroutine from_textfile_2dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr32
        module impure subroutine from_binaryfile_2dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr32

        module impure subroutine from_file_3dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr128
        module impure subroutine from_file_3dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr64
        module impure subroutine from_file_3dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr32

        module impure subroutine from_file_4dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr128
        module impure subroutine from_file_4dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr64
        module impure subroutine from_file_4dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr32

        module impure subroutine from_file_5dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr128
        module impure subroutine from_file_5dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr64
        module impure subroutine from_file_5dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr32

        module impure subroutine from_file_6dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr128
        module impure subroutine from_file_6dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr64
        module impure subroutine from_file_6dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr32

        module impure subroutine from_file_7dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr128
        module impure subroutine from_file_7dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr64
        module impure subroutine from_file_7dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr32

        module impure subroutine from_file_8dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr128
        module impure subroutine from_file_8dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr64
        module impure subroutine from_file_8dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr32

        module impure subroutine from_file_9dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr128
        module impure subroutine from_file_9dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr64
        module impure subroutine from_file_9dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr32

        module impure subroutine from_file_10dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr128
        module impure subroutine from_file_10dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr64
        module impure subroutine from_file_10dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr32

        module impure subroutine from_file_11dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr128
        module impure subroutine from_file_11dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr64
        module impure subroutine from_file_11dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr32

        module impure subroutine from_file_12dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr128
        module impure subroutine from_file_12dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr64
        module impure subroutine from_file_12dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr32

        module impure subroutine from_file_13dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr128
        module impure subroutine from_file_13dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr64
        module impure subroutine from_file_13dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr32

        module impure subroutine from_file_14dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr128
        module impure subroutine from_file_14dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr64
        module impure subroutine from_file_14dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr32

        module impure subroutine from_file_15dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr128
        module impure subroutine from_file_15dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr64
        module impure subroutine from_file_15dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr32

        module impure subroutine from_textfile_1di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di64
        module impure subroutine from_binaryfile_1di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di64
        module impure subroutine from_textfile_1di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di32
        module impure subroutine from_binaryfile_1di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di32
        module impure subroutine from_textfile_1di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di16
        module impure subroutine from_binaryfile_1di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di16
        module impure subroutine from_textfile_1di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di8
        module impure subroutine from_binaryfile_1di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di8

        module impure subroutine from_textfile_2di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di64
        module impure subroutine from_binaryfile_2di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di64
        module impure subroutine from_textfile_2di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di32
        module impure subroutine from_binaryfile_2di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di32
        module impure subroutine from_textfile_2di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di16
        module impure subroutine from_binaryfile_2di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di16
        module impure subroutine from_textfile_2di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di8
        module impure subroutine from_binaryfile_2di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di8

        module impure subroutine from_file_3di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di64
        module impure subroutine from_file_3di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di32
        module impure subroutine from_file_3di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di16
        module impure subroutine from_file_3di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di8

        module impure subroutine from_file_4di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di64
        module impure subroutine from_file_4di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di32
        module impure subroutine from_file_4di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di16
        module impure subroutine from_file_4di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di8

        module impure subroutine from_file_5di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di64
        module impure subroutine from_file_5di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di32
        module impure subroutine from_file_5di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di16
        module impure subroutine from_file_5di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di8

        module impure subroutine from_file_6di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di64
        module impure subroutine from_file_6di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di32
        module impure subroutine from_file_6di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di16
        module impure subroutine from_file_6di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di8

        module impure subroutine from_file_7di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di64
        module impure subroutine from_file_7di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di32
        module impure subroutine from_file_7di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di16
        module impure subroutine from_file_7di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di8

        module impure subroutine from_file_8di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di64
        module impure subroutine from_file_8di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di32
        module impure subroutine from_file_8di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di16
        module impure subroutine from_file_8di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di8

        module impure subroutine from_file_9di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di64
        module impure subroutine from_file_9di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di32
        module impure subroutine from_file_9di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di16
        module impure subroutine from_file_9di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di8

        module impure subroutine from_file_10di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di64
        module impure subroutine from_file_10di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di32
        module impure subroutine from_file_10di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di16
        module impure subroutine from_file_10di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di8

        module impure subroutine from_file_11di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di64
        module impure subroutine from_file_11di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di32
        module impure subroutine from_file_11di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di16
        module impure subroutine from_file_11di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di8

        module impure subroutine from_file_12di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di64
        module impure subroutine from_file_12di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di32
        module impure subroutine from_file_12di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di16
        module impure subroutine from_file_12di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di8

        module impure subroutine from_file_13di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di64
        module impure subroutine from_file_13di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di32
        module impure subroutine from_file_13di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di16
        module impure subroutine from_file_13di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di8

        module impure subroutine from_file_14di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di64
        module impure subroutine from_file_14di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di32
        module impure subroutine from_file_14di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di16
        module impure subroutine from_file_14di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di8

        module impure subroutine from_file_15di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di64
        module impure subroutine from_file_15di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di32
        module impure subroutine from_file_15di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di16
        module impure subroutine from_file_15di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di8

        module impure subroutine from_textfile_1dchar(file_name, into, word_length, header, delim)
            character(len=*), intent(in) :: file_name
            character(len=:), allocatable, dimension(:), intent(out) :: into
            integer, intent(in) :: word_length
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
        end subroutine from_textfile_1dchar

        module impure subroutine from_textfile_2dchar(file_name, into, word_length, header, delim)
            character(len=*), intent(in) :: file_name
            character(len=:), allocatable, dimension(:,:), intent(out) :: into
            integer, intent(in) :: word_length
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
        end subroutine from_textfile_2dchar
    end interface

    interface echo                                                                                 !! Submodule text_io
        module impure subroutine echo_string(string, file_name, append)
            character(len=*), intent(in) :: string
            character(len=*), intent(in) :: file_name
            logical, optional, intent(in) :: append
        end subroutine echo_string
    end interface

    interface to_text                                                                              !! Submodule text_io
        module impure subroutine to_text_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc128
        module impure subroutine to_text_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc64
        module impure subroutine to_text_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc32

        module impure subroutine to_text_2dc128(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc128
        module impure subroutine to_text_2dc64(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc64
        module impure subroutine to_text_2dc32(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc32

        module impure subroutine to_text_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr128
        module impure subroutine to_text_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr64
        module impure subroutine to_text_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr32

        module impure subroutine to_text_2dr128(x, file_name, header, locale, delim, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr128
        module impure subroutine to_text_2dr64(x, file_name, header, locale, delim, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr64
        module impure subroutine to_text_2dr32(x, file_name, header, locale, delim, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr32

        module impure subroutine to_text_1di64(x, file_name, header, dim, delim, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di64
        module impure subroutine to_text_1di32(x, file_name, header, dim, delim, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di32
        module impure subroutine to_text_1di16(x, file_name, header, dim, delim, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di16
        module impure subroutine to_text_1di8(x, file_name, header, dim, delim, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di8

        module impure subroutine to_text_2di64(x, file_name, header, delim, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di64
        module impure subroutine to_text_2di32(x, file_name, header, delim, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di32
        module impure subroutine to_text_2di16(x, file_name, header, delim, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di16
        module impure subroutine to_text_2di8(x, file_name, header, delim, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di8

        module impure subroutine to_text_1dchar(x, file_name, header, dim, delim)
            character(len=*), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
        end subroutine to_text_1dchar

        module impure subroutine to_text_2dchar(x, file_name, header, delim)
            character(len=*), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
        end subroutine to_text_2dchar
    end interface

    interface from_text                                                                            !! Submodule text_io
        module impure subroutine from_text_1dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc128
        module impure subroutine from_text_1dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc64
        module impure subroutine from_text_1dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc32

        module impure subroutine from_text_2dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc128
        module impure subroutine from_text_2dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc64
        module impure subroutine from_text_2dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc32

        module impure subroutine from_text_1dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr128
        module impure subroutine from_text_1dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr64
        module impure subroutine from_text_1dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr32

        module impure subroutine from_text_2dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr128
        module impure subroutine from_text_2dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr64
        module impure subroutine from_text_2dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr32

        module impure subroutine from_text_1di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di64
        module impure subroutine from_text_1di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di32
        module impure subroutine from_text_1di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di16
        module impure subroutine from_text_1di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di8

        module impure subroutine from_text_2di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di64
        module impure subroutine from_text_2di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di32
        module impure subroutine from_text_2di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di16
        module impure subroutine from_text_2di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di8

        module impure subroutine from_text_1dchar(file_name, into, word_length, header, delim)
            character(len=*), intent(in) :: file_name
            character(len=:), allocatable, dimension(:), intent(out) :: into
            integer, intent(in) :: word_length
            logical, intent(in) :: header
            character(len=*), intent(in) :: delim
        end subroutine from_text_1dchar

        module impure subroutine from_text_2dchar(file_name, into, word_length, header, delim)
            character(len=*), intent(in) :: file_name
            character(len=:), allocatable, dimension(:,:), intent(out) :: into
            integer, intent(in) :: word_length
            logical, intent(in) :: header
            character(len=*), intent(in) :: delim
        end subroutine from_text_2dchar
    end interface

    interface to_binary                                                                          !! Submodule binary_io
        module impure subroutine to_binary_1dc128(x, file_name)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc128
        module impure subroutine to_binary_1dc64(x, file_name)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc64
        module impure subroutine to_binary_1dc32(x, file_name)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc32

        module impure subroutine to_binary_2dc128(x, file_name)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc128
        module impure subroutine to_binary_2dc64(x, file_name)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc64
        module impure subroutine to_binary_2dc32(x, file_name)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc32

        module impure subroutine to_binary_3dc128(x, file_name)
            complex(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc128
        module impure subroutine to_binary_3dc64(x, file_name)
            complex(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc64
        module impure subroutine to_binary_3dc32(x, file_name)
            complex(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc32

        module impure subroutine to_binary_4dc128(x, file_name)
            complex(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc128
        module impure subroutine to_binary_4dc64(x, file_name)
            complex(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc64
        module impure subroutine to_binary_4dc32(x, file_name)
            complex(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc32

        module impure subroutine to_binary_5dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc128
        module impure subroutine to_binary_5dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc64
        module impure subroutine to_binary_5dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc32

        module impure subroutine to_binary_6dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc128
        module impure subroutine to_binary_6dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc64
        module impure subroutine to_binary_6dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc32

        module impure subroutine to_binary_7dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc128
        module impure subroutine to_binary_7dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc64
        module impure subroutine to_binary_7dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc32

        module impure subroutine to_binary_8dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc128
        module impure subroutine to_binary_8dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc64
        module impure subroutine to_binary_8dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc32

        module impure subroutine to_binary_9dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc128
        module impure subroutine to_binary_9dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc64
        module impure subroutine to_binary_9dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc32

        module impure subroutine to_binary_10dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc128
        module impure subroutine to_binary_10dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc64
        module impure subroutine to_binary_10dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc32

        module impure subroutine to_binary_11dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc128
        module impure subroutine to_binary_11dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc64
        module impure subroutine to_binary_11dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc32

        module impure subroutine to_binary_12dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc128
        module impure subroutine to_binary_12dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc64
        module impure subroutine to_binary_12dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc32

        module impure subroutine to_binary_13dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc128
        module impure subroutine to_binary_13dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc64
        module impure subroutine to_binary_13dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc32

        module impure subroutine to_binary_14dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc128
        module impure subroutine to_binary_14dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc64
        module impure subroutine to_binary_14dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc32

        module impure subroutine to_binary_15dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc128
        module impure subroutine to_binary_15dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc64
        module impure subroutine to_binary_15dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc32

        module impure subroutine to_binary_1dr128(x, file_name)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr128
        module impure subroutine to_binary_1dr64(x, file_name)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr64
        module impure subroutine to_binary_1dr32(x, file_name)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr32

        module impure subroutine to_binary_2dr128(x, file_name)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr128
        module impure subroutine to_binary_2dr64(x, file_name)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr64
        module impure subroutine to_binary_2dr32(x, file_name)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr32

        module impure subroutine to_binary_3dr128(x, file_name)
            real(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr128
        module impure subroutine to_binary_3dr64(x, file_name)
            real(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr64
        module impure subroutine to_binary_3dr32(x, file_name)
            real(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr32

        module impure subroutine to_binary_4dr128(x, file_name)
            real(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr128
        module impure subroutine to_binary_4dr64(x, file_name)
            real(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr64
        module impure subroutine to_binary_4dr32(x, file_name)
            real(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr32

        module impure subroutine to_binary_5dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr128
        module impure subroutine to_binary_5dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr64
        module impure subroutine to_binary_5dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr32

        module impure subroutine to_binary_6dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr128
        module impure subroutine to_binary_6dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr64
        module impure subroutine to_binary_6dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr32

        module impure subroutine to_binary_7dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr128
        module impure subroutine to_binary_7dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr64
        module impure subroutine to_binary_7dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr32

        module impure subroutine to_binary_8dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr128
        module impure subroutine to_binary_8dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr64
        module impure subroutine to_binary_8dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr32

        module impure subroutine to_binary_9dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr128
        module impure subroutine to_binary_9dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr64
        module impure subroutine to_binary_9dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr32

        module impure subroutine to_binary_10dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr128
        module impure subroutine to_binary_10dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr64
        module impure subroutine to_binary_10dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr32

        module impure subroutine to_binary_11dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr128
        module impure subroutine to_binary_11dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr64
        module impure subroutine to_binary_11dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr32

        module impure subroutine to_binary_12dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr128
        module impure subroutine to_binary_12dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr64
        module impure subroutine to_binary_12dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr32

        module impure subroutine to_binary_13dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr128
        module impure subroutine to_binary_13dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr64
        module impure subroutine to_binary_13dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr32

        module impure subroutine to_binary_14dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr128
        module impure subroutine to_binary_14dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr64
        module impure subroutine to_binary_14dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr32

        module impure subroutine to_binary_15dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr128
        module impure subroutine to_binary_15dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr64
        module impure subroutine to_binary_15dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr32

        module impure subroutine to_binary_1di64(x, file_name)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di64
        module impure subroutine to_binary_1di32(x, file_name)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di32
        module impure subroutine to_binary_1di16(x, file_name)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di16
        module impure subroutine to_binary_1di8(x, file_name)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di8

        module impure subroutine to_binary_2di64(x, file_name)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di64
        module impure subroutine to_binary_2di32(x, file_name)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di32
        module impure subroutine to_binary_2di16(x, file_name)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di16
        module impure subroutine to_binary_2di8(x, file_name)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di8

        module impure subroutine to_binary_3di64(x, file_name)
            integer(int64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di64
        module impure subroutine to_binary_3di32(x, file_name)
            integer(int32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di32
        module impure subroutine to_binary_3di16(x, file_name)
            integer(int16), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di16
        module impure subroutine to_binary_3di8(x, file_name)
            integer(int8), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di8

        module impure subroutine to_binary_4di64(x, file_name)
            integer(int64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di64
        module impure subroutine to_binary_4di32(x, file_name)
            integer(int32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di32
        module impure subroutine to_binary_4di16(x, file_name)
            integer(int16), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di16
        module impure subroutine to_binary_4di8(x, file_name)
            integer(int8), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di8

        module impure subroutine to_binary_5di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di64
        module impure subroutine to_binary_5di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di32
        module impure subroutine to_binary_5di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di16
        module impure subroutine to_binary_5di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di8

        module impure subroutine to_binary_6di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di64
        module impure subroutine to_binary_6di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di32
        module impure subroutine to_binary_6di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di16
        module impure subroutine to_binary_6di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di8

        module impure subroutine to_binary_7di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di64
        module impure subroutine to_binary_7di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di32
        module impure subroutine to_binary_7di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di16
        module impure subroutine to_binary_7di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di8

        module impure subroutine to_binary_8di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di64
        module impure subroutine to_binary_8di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di32
        module impure subroutine to_binary_8di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di16
        module impure subroutine to_binary_8di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di8

        module impure subroutine to_binary_9di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di64
        module impure subroutine to_binary_9di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di32
        module impure subroutine to_binary_9di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di16
        module impure subroutine to_binary_9di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di8

        module impure subroutine to_binary_10di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di64
        module impure subroutine to_binary_10di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di32
        module impure subroutine to_binary_10di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di16
        module impure subroutine to_binary_10di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di8

        module impure subroutine to_binary_11di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di64
        module impure subroutine to_binary_11di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di32
        module impure subroutine to_binary_11di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di16
        module impure subroutine to_binary_11di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di8

        module impure subroutine to_binary_12di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di64
        module impure subroutine to_binary_12di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di32
        module impure subroutine to_binary_12di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di16
        module impure subroutine to_binary_12di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di8

        module impure subroutine to_binary_13di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di64
        module impure subroutine to_binary_13di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di32
        module impure subroutine to_binary_13di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di16
        module impure subroutine to_binary_13di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di8

        module impure subroutine to_binary_14di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di64
        module impure subroutine to_binary_14di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di32
        module impure subroutine to_binary_14di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di16
        module impure subroutine to_binary_14di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di8

        module impure subroutine to_binary_15di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di64
        module impure subroutine to_binary_15di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di32
        module impure subroutine to_binary_15di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di16
        module impure subroutine to_binary_15di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di8
    end interface

    interface from_binary                                                                        !! Submodule binary_io
        module impure subroutine from_binary_1dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc128
        module impure subroutine from_binary_1dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc64
        module impure subroutine from_binary_1dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc32

        module impure subroutine from_binary_2dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc128
        module impure subroutine from_binary_2dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc64
        module impure subroutine from_binary_2dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc32

        module impure subroutine from_binary_3dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc128
        module impure subroutine from_binary_3dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc64
        module impure subroutine from_binary_3dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc32

        module impure subroutine from_binary_4dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc128
        module impure subroutine from_binary_4dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc64
        module impure subroutine from_binary_4dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc32

        module impure subroutine from_binary_5dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc128
        module impure subroutine from_binary_5dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc64
        module impure subroutine from_binary_5dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc32

        module impure subroutine from_binary_6dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc128
        module impure subroutine from_binary_6dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc64
        module impure subroutine from_binary_6dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc32

        module impure subroutine from_binary_7dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc128
        module impure subroutine from_binary_7dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc64
        module impure subroutine from_binary_7dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc32

        module impure subroutine from_binary_8dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc128
        module impure subroutine from_binary_8dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc64
        module impure subroutine from_binary_8dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc32

        module impure subroutine from_binary_9dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc128
        module impure subroutine from_binary_9dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc64
        module impure subroutine from_binary_9dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc32

        module impure subroutine from_binary_10dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc128
        module impure subroutine from_binary_10dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc64
        module impure subroutine from_binary_10dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc32

        module impure subroutine from_binary_11dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc128
        module impure subroutine from_binary_11dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc64
        module impure subroutine from_binary_11dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc32

        module impure subroutine from_binary_12dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc128
        module impure subroutine from_binary_12dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc64
        module impure subroutine from_binary_12dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc32

        module impure subroutine from_binary_13dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc128
        module impure subroutine from_binary_13dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc64
        module impure subroutine from_binary_13dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc32

        module impure subroutine from_binary_14dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc128
        module impure subroutine from_binary_14dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc64
        module impure subroutine from_binary_14dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc32

        module impure subroutine from_binary_15dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc128
        module impure subroutine from_binary_15dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc64
        module impure subroutine from_binary_15dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc32

        module impure subroutine from_binary_1dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr128
        module impure subroutine from_binary_1dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr64
        module impure subroutine from_binary_1dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr32

        module impure subroutine from_binary_2dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr128
        module impure subroutine from_binary_2dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr64
        module impure subroutine from_binary_2dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr32

        module impure subroutine from_binary_3dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr128
        module impure subroutine from_binary_3dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr64
        module impure subroutine from_binary_3dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr32

        module impure subroutine from_binary_4dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr128
        module impure subroutine from_binary_4dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr64
        module impure subroutine from_binary_4dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr32

        module impure subroutine from_binary_5dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr128
        module impure subroutine from_binary_5dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr64
        module impure subroutine from_binary_5dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr32

        module impure subroutine from_binary_6dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr128
        module impure subroutine from_binary_6dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr64
        module impure subroutine from_binary_6dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr32

        module impure subroutine from_binary_7dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr128
        module impure subroutine from_binary_7dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr64
        module impure subroutine from_binary_7dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr32

        module impure subroutine from_binary_8dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr128
        module impure subroutine from_binary_8dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr64
        module impure subroutine from_binary_8dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr32

        module impure subroutine from_binary_9dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr128
        module impure subroutine from_binary_9dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr64
        module impure subroutine from_binary_9dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr32

        module impure subroutine from_binary_10dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr128
        module impure subroutine from_binary_10dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr64
        module impure subroutine from_binary_10dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr32

        module impure subroutine from_binary_11dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr128
        module impure subroutine from_binary_11dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr64
        module impure subroutine from_binary_11dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr32

        module impure subroutine from_binary_12dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr128
        module impure subroutine from_binary_12dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr64
        module impure subroutine from_binary_12dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr32

        module impure subroutine from_binary_13dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr128
        module impure subroutine from_binary_13dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr64
        module impure subroutine from_binary_13dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr32

        module impure subroutine from_binary_14dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr128
        module impure subroutine from_binary_14dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr64
        module impure subroutine from_binary_14dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr32

        module impure subroutine from_binary_15dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr128
        module impure subroutine from_binary_15dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr64
        module impure subroutine from_binary_15dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr32

        module impure subroutine from_binary_1di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di64
        module impure subroutine from_binary_1di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di32
        module impure subroutine from_binary_1di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di16
        module impure subroutine from_binary_1di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di8

        module impure subroutine from_binary_2di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di64
        module impure subroutine from_binary_2di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di32
        module impure subroutine from_binary_2di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di16
        module impure subroutine from_binary_2di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di8

        module impure subroutine from_binary_3di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di64
        module impure subroutine from_binary_3di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di32
        module impure subroutine from_binary_3di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di16
        module impure subroutine from_binary_3di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di8

        module impure subroutine from_binary_4di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di64
        module impure subroutine from_binary_4di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di32
        module impure subroutine from_binary_4di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di16
        module impure subroutine from_binary_4di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di8

        module impure subroutine from_binary_5di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di64
        module impure subroutine from_binary_5di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di32
        module impure subroutine from_binary_5di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di16
        module impure subroutine from_binary_5di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di8

        module impure subroutine from_binary_6di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di64
        module impure subroutine from_binary_6di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di32
        module impure subroutine from_binary_6di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di16
        module impure subroutine from_binary_6di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di8

        module impure subroutine from_binary_7di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di64
        module impure subroutine from_binary_7di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di32
        module impure subroutine from_binary_7di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di16
        module impure subroutine from_binary_7di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di8

        module impure subroutine from_binary_8di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di64
        module impure subroutine from_binary_8di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di32
        module impure subroutine from_binary_8di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di16
        module impure subroutine from_binary_8di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di8

        module impure subroutine from_binary_9di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di64
        module impure subroutine from_binary_9di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di32
        module impure subroutine from_binary_9di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di16
        module impure subroutine from_binary_9di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di8

        module impure subroutine from_binary_10di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di64
        module impure subroutine from_binary_10di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di32
        module impure subroutine from_binary_10di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di16
        module impure subroutine from_binary_10di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di8

        module impure subroutine from_binary_11di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di64
        module impure subroutine from_binary_11di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di32
        module impure subroutine from_binary_11di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di16
        module impure subroutine from_binary_11di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di8

        module impure subroutine from_binary_12di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di64
        module impure subroutine from_binary_12di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di32
        module impure subroutine from_binary_12di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di16
        module impure subroutine from_binary_12di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di8

        module impure subroutine from_binary_13di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di64
        module impure subroutine from_binary_13di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di32
        module impure subroutine from_binary_13di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di16
        module impure subroutine from_binary_13di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di8

        module impure subroutine from_binary_14di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di64
        module impure subroutine from_binary_14di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di32
        module impure subroutine from_binary_14di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di16
        module impure subroutine from_binary_14di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di8

        module impure subroutine from_binary_15di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di64
        module impure subroutine from_binary_15di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di32
        module impure subroutine from_binary_15di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di16
        module impure subroutine from_binary_15di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di8
    end interface

    contains
    pure function ext_of(file_name) result(ext)
        character(len=*), intent(in) :: file_name
        character(len=:), allocatable :: ext

        integer :: i, l

        l = len_trim(file_name)

        do i = l, 1, -1
            if ( file_name(i:i) == '.' ) exit
        end do

        if ( i > 0 ) then
            ext = trim(adjustl(file_name(i+1:l)))
        else
            ext = ''
        end if
    end function ext_of

end module io_fortran_lib

submodule (io_fortran_lib) array_printing
    contains
    module procedure aprint_1dc128
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, n_rows, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows) )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc128
    module procedure aprint_1dc64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, n_rows, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows) )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc64
    module procedure aprint_1dc32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, n_rows, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows) )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc32

    module procedure aprint_2dc128
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, n_rows, n_columns, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows, n_columns) )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc128
    module procedure aprint_2dc64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, n_rows, n_columns, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows, n_columns) )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc64
    module procedure aprint_2dc32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, n_rows, n_columns, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(n_rows, n_columns) )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc32

    module procedure aprint_1dr128
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, n_rows, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr128
    module procedure aprint_1dr64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, n_rows, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr64
    module procedure aprint_1dr32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, n_rows, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr32

    module procedure aprint_2dr128
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, n_rows, n_columns, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr128
    module procedure aprint_2dr64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, n_rows, n_columns, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr64
    module procedure aprint_2dr32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, n_rows, n_columns, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr32

    module procedure aprint_1di64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i, n_rows

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di64
    module procedure aprint_1di32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i, n_rows

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di32
    module procedure aprint_1di16
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i, n_rows

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di16
    module procedure aprint_1di8
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i, n_rows

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows), source=source )

        do concurrent (i = 1:n_rows)
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di8

    module procedure aprint_2di64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j, n_rows, n_columns

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di64
    module procedure aprint_2di32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j, n_rows, n_columns

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di32
    module procedure aprint_2di16
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j, n_rows, n_columns

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di16
    module procedure aprint_2di8
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j, n_rows, n_columns

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        n_rows = size(x, dim=1)
        n_columns = size(x, dim=2)

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(n_rows, n_columns), source=source )

        do concurrent (j = 1:n_columns, i = 1:n_rows)
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di8

    module procedure aprint_1dchar
        integer :: i

        write(unit=*, fmt='(a)') nl//'    '//adjustr(x(lbound(x, dim=1)))//' '

        if ( size(x) == 1 ) return

        if ( size(x) > 2 ) then
            do i = lbound(x, dim=1) + 1, ubound(x, dim=1) - 1
                write(unit=*, fmt='(a)') '    '//adjustr(x(i))//' '
            end do
        end if
        
        write(unit=*, fmt='(a)') '    '//adjustr(x(ubound(x, dim=1)))//' '//nl
    end procedure aprint_1dchar
    
    module procedure aprint_2dchar
        integer :: i

        write(unit=*, fmt='(a)') nl//'    '//to_str(x(lbound(x, dim=1),:), delim=' ', trimstring=.false.)//' '

        if ( size(x, dim=1) == 1 ) return

        if ( size(x, dim=1) > 2 ) then
            do i = lbound(x, dim=1) + 1, ubound(x, dim=1) - 1
                write(unit=*, fmt='(a)') '    '//to_str(x(i,:), delim=' ', trimstring=.false.)//' '
            end do
        end if
        
        write(unit=*, fmt='(a)') '    '//to_str(x(ubound(x, dim=1),:), delim=' ', trimstring=.false.)//' '//nl
    end procedure aprint_2dchar
end submodule array_printing

submodule (io_fortran_lib) internal_io
    contains
    module procedure str_c128
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c128
    module procedure str_c64
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c64
    module procedure str_c32
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c32

    module procedure str_r128
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'es' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e4)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            e = int(log10(abs(x)))

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=70) :: str_tmp )

            write(unit=str_tmp, fmt='(z)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r128
    module procedure str_r64
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'es' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e3)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            e = int(log10(abs(x)))

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=40) :: str_tmp )

            write(unit=str_tmp, fmt='(z)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r64
    module procedure str_r32
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'es' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e2)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            e = int(log10(abs(x)))

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=25) :: str_tmp )

            write(unit=str_tmp, fmt='(z)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r32

    module procedure str_i64
        character(len=:), allocatable :: fmt_
        character(len=40) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i64
    module procedure str_i32
        character(len=:), allocatable :: fmt_
        character(len=25) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i32
    module procedure str_i16
        character(len=:), allocatable :: fmt_
        character(len=15) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i16
    module procedure str_i8
        character(len=:), allocatable :: fmt_
        character(len=10) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i8

    module procedure to_str_1dc128
        character(len=:), allocatable :: locale_, delim_, fmt_, im_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure to_str_1dc128
    module procedure to_str_1dc64
        character(len=:), allocatable :: locale_, delim_, fmt_, im_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure to_str_1dc64
    module procedure to_str_1dc32
        character(len=:), allocatable :: locale_, delim_, fmt_, im_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure to_str_1dc32

    module procedure to_str_1dr128
        character(len=:), allocatable :: locale_, delim_, fmt_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure to_str_1dr128
    module procedure to_str_1dr64
        character(len=:), allocatable :: locale_, delim_, fmt_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure to_str_1dr64
    module procedure to_str_1dr32
        character(len=:), allocatable :: locale_, delim_, fmt_
        integer :: i, decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(delim) ) then
            if ( locale_ == 'US' ) then
                delim_ = ','
            else
                delim_ = ';'
            end if
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'es'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), locale=locale_, fmt=fmt_, decimals=decimals_)//delim_
        end do
        x_str = x_str//str(x(size(x)), locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure to_str_1dr32

    module procedure to_str_1di64
        character(len=:), allocatable :: delim_, fmt_
        integer :: i

        if ( .not. present(delim) ) then
            delim_ = ','
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), fmt=fmt_)//delim_
        end do
        x_str = x_str//str(x(size(x)), fmt=fmt_)
    end procedure to_str_1di64
    module procedure to_str_1di32
        character(len=:), allocatable :: delim_, fmt_
        integer :: i

        if ( .not. present(delim) ) then
            delim_ = ','
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), fmt=fmt_)//delim_
        end do
        x_str = x_str//str(x(size(x)), fmt=fmt_)
    end procedure to_str_1di32
    module procedure to_str_1di16
        character(len=:), allocatable :: delim_, fmt_
        integer :: i

        if ( .not. present(delim) ) then
            delim_ = ','
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), fmt=fmt_)//delim_
        end do
        x_str = x_str//str(x(size(x)), fmt=fmt_)
    end procedure to_str_1di16
    module procedure to_str_1di8
        character(len=:), allocatable :: delim_, fmt_
        integer :: i

        if ( .not. present(delim) ) then
            delim_ = ','
        else
            delim_ = delim
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        x_str = ''
        do i = 1, size(x)-1
            x_str = x_str//str(x(i), fmt=fmt_)//delim_
        end do
        x_str = x_str//str(x(size(x)), fmt=fmt_)
    end procedure to_str_1di8

    module procedure to_str_1dchar
        logical :: trimstring_
        integer :: i

        if ( .not. present(trimstring) ) then
            trimstring_ = .true.
        else
            trimstring_ = trimstring
        end if

        if ( trimstring_ ) then
            x_str = ''
            do i = 1, size(x)-1
                x_str = x_str//trim(adjustl(x(i)))//delim
            end do
            x_str = x_str//trim(adjustl(x(size(x))))
        else
            x_str = ''
            do i = 1, size(x)-1
                x_str = x_str//adjustr(x(i))//delim
            end do
            x_str = x_str//adjustr(x(size(x)))
        end if
    end procedure to_str_1dchar
end submodule internal_io

submodule (io_fortran_lib) file_io
    contains
    !! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure to_file_1dc128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc128
    module procedure to_file_1dc64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc64
    module procedure to_file_1dc32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc32

    module procedure to_file_2dc128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc128
    module procedure to_file_2dc64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc64
    module procedure to_file_2dc32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc32

    module procedure to_file_3dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc128
    module procedure to_file_3dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc64
    module procedure to_file_3dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc32

    module procedure to_file_4dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc128
    module procedure to_file_4dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc64
    module procedure to_file_4dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc32

    module procedure to_file_5dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc128
    module procedure to_file_5dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc64
    module procedure to_file_5dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc32

    module procedure to_file_6dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc128
    module procedure to_file_6dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc64
    module procedure to_file_6dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc32

    module procedure to_file_7dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc128
    module procedure to_file_7dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc64
    module procedure to_file_7dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc32

    module procedure to_file_8dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc128
    module procedure to_file_8dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc64
    module procedure to_file_8dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc32

    module procedure to_file_9dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc128
    module procedure to_file_9dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc64
    module procedure to_file_9dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc32

    module procedure to_file_10dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc128
    module procedure to_file_10dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc64
    module procedure to_file_10dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc32

    module procedure to_file_11dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc128
    module procedure to_file_11dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc64
    module procedure to_file_11dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc32

    module procedure to_file_12dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc128
    module procedure to_file_12dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc64
    module procedure to_file_12dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc32

    module procedure to_file_13dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc128
    module procedure to_file_13dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc64
    module procedure to_file_13dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc32

    module procedure to_file_14dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc128
    module procedure to_file_14dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc64
    module procedure to_file_14dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc32

    module procedure to_file_15dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc128
    module procedure to_file_15dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc64
    module procedure to_file_15dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc32

    module procedure to_file_1dr128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr128
    module procedure to_file_1dr64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr64
    module procedure to_file_1dr32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            
            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr32

    module procedure to_file_2dr128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr128
    module procedure to_file_2dr64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr64
    module procedure to_file_2dr32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'es'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr32

    module procedure to_file_3dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr128
    module procedure to_file_3dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr64
    module procedure to_file_3dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr32

    module procedure to_file_4dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr128
    module procedure to_file_4dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr64
    module procedure to_file_4dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr32

    module procedure to_file_5dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr128
    module procedure to_file_5dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr64
    module procedure to_file_5dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr32

    module procedure to_file_6dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr128
    module procedure to_file_6dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr64
    module procedure to_file_6dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr32

    module procedure to_file_7dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr128
    module procedure to_file_7dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr64
    module procedure to_file_7dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr32

    module procedure to_file_8dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr128
    module procedure to_file_8dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr64
    module procedure to_file_8dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr32

    module procedure to_file_9dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr128
    module procedure to_file_9dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr64
    module procedure to_file_9dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr32

    module procedure to_file_10dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr128
    module procedure to_file_10dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr64
    module procedure to_file_10dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr32

    module procedure to_file_11dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr128
    module procedure to_file_11dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr64
    module procedure to_file_11dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr32

    module procedure to_file_12dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr128
    module procedure to_file_12dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr64
    module procedure to_file_12dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr32

    module procedure to_file_13dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr128
    module procedure to_file_13dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr64
    module procedure to_file_13dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr32

    module procedure to_file_14dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr128
    module procedure to_file_14dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr64
    module procedure to_file_14dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr32

    module procedure to_file_15dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr128
    module procedure to_file_15dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr64
    module procedure to_file_15dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr32

    module procedure to_file_1di64
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di64
    module procedure to_file_1di32
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di32
    module procedure to_file_1di16
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di16
    module procedure to_file_1di8
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di8

    module procedure to_file_2di64
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di64
    module procedure to_file_2di32
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di32
    module procedure to_file_2di16
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di16
    module procedure to_file_2di8
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di8

    module procedure to_file_3di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di64
    module procedure to_file_3di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di32
    module procedure to_file_3di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di16
    module procedure to_file_3di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di8

    module procedure to_file_4di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di64
    module procedure to_file_4di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di32
    module procedure to_file_4di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di16
    module procedure to_file_4di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di8

    module procedure to_file_5di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di64
    module procedure to_file_5di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di32
    module procedure to_file_5di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di16
    module procedure to_file_5di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di8

    module procedure to_file_6di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di64
    module procedure to_file_6di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di32
    module procedure to_file_6di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di16
    module procedure to_file_6di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di8

    module procedure to_file_7di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di64
    module procedure to_file_7di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di32
    module procedure to_file_7di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di16
    module procedure to_file_7di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di8

    module procedure to_file_8di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di64
    module procedure to_file_8di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di32
    module procedure to_file_8di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di16
    module procedure to_file_8di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di8

    module procedure to_file_9di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di64
    module procedure to_file_9di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di32
    module procedure to_file_9di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di16
    module procedure to_file_9di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di8

    module procedure to_file_10di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di64
    module procedure to_file_10di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di32
    module procedure to_file_10di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di16
    module procedure to_file_10di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di8

    module procedure to_file_11di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di64
    module procedure to_file_11di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di32
    module procedure to_file_11di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di16
    module procedure to_file_11di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di8

    module procedure to_file_12di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di64
    module procedure to_file_12di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di32
    module procedure to_file_12di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di16
    module procedure to_file_12di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di8

    module procedure to_file_13di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di64
    module procedure to_file_13di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di32
    module procedure to_file_13di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di16
    module procedure to_file_13di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di8

    module procedure to_file_14di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di64
    module procedure to_file_14di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di32
    module procedure to_file_14di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di16
    module procedure to_file_14di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di8

    module procedure to_file_15di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di64
    module procedure to_file_15di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di32
    module procedure to_file_15di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di16
    module procedure to_file_15di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di8

    module procedure to_file_1dchar
        character(len=:), allocatable :: ext, delim_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')
        end if
    end procedure to_file_1dchar

    module procedure to_file_2dchar
        character(len=:), allocatable :: ext, delim_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')
        end if
    end procedure to_file_2dchar

    !! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_textfile_1dc128
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc128
    module procedure from_binaryfile_1dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc128
    module procedure from_textfile_1dc64
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc64
    module procedure from_binaryfile_1dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc64
    module procedure from_textfile_1dc32
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc32
    module procedure from_binaryfile_1dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc32

    module procedure from_textfile_2dc128
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc128
    module procedure from_binaryfile_2dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc128
    module procedure from_textfile_2dc64
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc64
    module procedure from_binaryfile_2dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc64
    module procedure from_textfile_2dc32
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc32
    module procedure from_binaryfile_2dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc32

    module procedure from_file_3dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc128
    module procedure from_file_3dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc64
    module procedure from_file_3dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc32

    module procedure from_file_4dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc128
    module procedure from_file_4dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc64
    module procedure from_file_4dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc32

    module procedure from_file_5dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc128
    module procedure from_file_5dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc64
    module procedure from_file_5dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc32

    module procedure from_file_6dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc128
    module procedure from_file_6dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc64
    module procedure from_file_6dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc32

    module procedure from_file_7dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc128
    module procedure from_file_7dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc64
    module procedure from_file_7dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc32

    module procedure from_file_8dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc128
    module procedure from_file_8dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc64
    module procedure from_file_8dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc32

    module procedure from_file_9dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc128
    module procedure from_file_9dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc64
    module procedure from_file_9dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc32

    module procedure from_file_10dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc128
    module procedure from_file_10dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc64
    module procedure from_file_10dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc32

    module procedure from_file_11dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc128
    module procedure from_file_11dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc64
    module procedure from_file_11dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc32

    module procedure from_file_12dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc128
    module procedure from_file_12dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc64
    module procedure from_file_12dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc32

    module procedure from_file_13dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc128
    module procedure from_file_13dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc64
    module procedure from_file_13dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc32

    module procedure from_file_14dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc128
    module procedure from_file_14dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc64
    module procedure from_file_14dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc32

    module procedure from_file_15dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc128
    module procedure from_file_15dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc64
    module procedure from_file_15dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc32

    module procedure from_textfile_1dr128
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr128
    module procedure from_binaryfile_1dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr128
    module procedure from_textfile_1dr64
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr64
    module procedure from_binaryfile_1dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr64
    module procedure from_textfile_1dr32
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr32
    module procedure from_binaryfile_1dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr32

    module procedure from_textfile_2dr128
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr128
    module procedure from_binaryfile_2dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr128
    module procedure from_textfile_2dr64
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr64
    module procedure from_binaryfile_2dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr64
    module procedure from_textfile_2dr32
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'es'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr32
    module procedure from_binaryfile_2dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr32

    module procedure from_file_3dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr128
    module procedure from_file_3dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr64
    module procedure from_file_3dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr32

    module procedure from_file_4dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr128
    module procedure from_file_4dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr64
    module procedure from_file_4dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr32

    module procedure from_file_5dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr128
    module procedure from_file_5dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr64
    module procedure from_file_5dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr32

    module procedure from_file_6dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr128
    module procedure from_file_6dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr64
    module procedure from_file_6dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr32

    module procedure from_file_7dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr128
    module procedure from_file_7dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr64
    module procedure from_file_7dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr32

    module procedure from_file_8dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr128
    module procedure from_file_8dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr64
    module procedure from_file_8dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr32

    module procedure from_file_9dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr128
    module procedure from_file_9dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr64
    module procedure from_file_9dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr32

    module procedure from_file_10dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr128
    module procedure from_file_10dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr64
    module procedure from_file_10dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr32

    module procedure from_file_11dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr128
    module procedure from_file_11dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr64
    module procedure from_file_11dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr32

    module procedure from_file_12dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr128
    module procedure from_file_12dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr64
    module procedure from_file_12dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr32

    module procedure from_file_13dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr128
    module procedure from_file_13dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr64
    module procedure from_file_13dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr32

    module procedure from_file_14dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr128
    module procedure from_file_14dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr64
    module procedure from_file_14dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr32

    module procedure from_file_15dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr128
    module procedure from_file_15dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr64
    module procedure from_file_15dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr32

    module procedure from_textfile_1di64
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di64
    module procedure from_binaryfile_1di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di64
    module procedure from_textfile_1di32
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di32
    module procedure from_binaryfile_1di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di32
    module procedure from_textfile_1di16
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di16
    module procedure from_binaryfile_1di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di16
    module procedure from_textfile_1di8
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di8
    module procedure from_binaryfile_1di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di8

    module procedure from_textfile_2di64
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di64
    module procedure from_binaryfile_2di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di64
    module procedure from_textfile_2di32
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di32
    module procedure from_binaryfile_2di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di32
    module procedure from_textfile_2di16
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di16
    module procedure from_binaryfile_2di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di16
    module procedure from_textfile_2di8
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di8
    module procedure from_binaryfile_2di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di8

    module procedure from_file_3di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di64
    module procedure from_file_3di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di32
    module procedure from_file_3di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di16
    module procedure from_file_3di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di8

    module procedure from_file_4di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di64
    module procedure from_file_4di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di32
    module procedure from_file_4di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di16
    module procedure from_file_4di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di8

    module procedure from_file_5di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di64
    module procedure from_file_5di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di32
    module procedure from_file_5di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di16
    module procedure from_file_5di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di8

    module procedure from_file_6di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di64
    module procedure from_file_6di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di32
    module procedure from_file_6di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di16
    module procedure from_file_6di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di8

    module procedure from_file_7di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di64
    module procedure from_file_7di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di32
    module procedure from_file_7di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di16
    module procedure from_file_7di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di8

    module procedure from_file_8di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di64
    module procedure from_file_8di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di32
    module procedure from_file_8di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di16
    module procedure from_file_8di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di8

    module procedure from_file_9di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di64
    module procedure from_file_9di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di32
    module procedure from_file_9di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di16
    module procedure from_file_9di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di8

    module procedure from_file_10di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di64
    module procedure from_file_10di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di32
    module procedure from_file_10di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di16
    module procedure from_file_10di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di8

    module procedure from_file_11di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di64
    module procedure from_file_11di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di32
    module procedure from_file_11di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di16
    module procedure from_file_11di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di8

    module procedure from_file_12di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di64
    module procedure from_file_12di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di32
    module procedure from_file_12di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di16
    module procedure from_file_12di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di8

    module procedure from_file_13di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di64
    module procedure from_file_13di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di32
    module procedure from_file_13di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di16
    module procedure from_file_13di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di8

    module procedure from_file_14di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di64
    module procedure from_file_14di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di32
    module procedure from_file_14di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di16
    module procedure from_file_14di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di8

    module procedure from_file_15di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di64
    module procedure from_file_15di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di32
    module procedure from_file_15di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di16
    module procedure from_file_15di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di8

    module procedure from_textfile_1dchar
        character(len=:), allocatable :: ext, delim_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if

            if ( word_length < 0 ) then
                error stop nl//'FATAL: word_length may not be negative in read of file "'//file_name//'".'
            end if
            
            call from_text(file_name=file_name, into=into, word_length=word_length, header=header_, delim=delim_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Binary read not supported for '// &
                               'character data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dchar

    module procedure from_textfile_2dchar
        character(len=:), allocatable :: ext, delim_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if

            if ( word_length < 0 ) then
                error stop nl//'FATAL: word_length may not be negative in read of file "'//file_name//'".'
            end if
            
            call from_text(file_name=file_name, into=into, word_length=word_length, header=header_, delim=delim_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Binary read not supported for '// &
                               'character data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dchar
end submodule file_io

submodule (io_fortran_lib) text_io
    contains
    !! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure echo_string
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            if ( (.not. present(append)) .or. (.not. append) ) then
                open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                      action='write', access='sequential', position='rewind' )
            else if ( append ) then
                open( newunit=file_unit, file=file_name, status='old', form='formatted', &
                      action='write', access='sequential', position='append' )
            end if
        end if

        write(unit=file_unit, fmt='(a)') string

        close(file_unit)
    end procedure echo_string

    module procedure to_text_1dc128
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals, im=im)
        end if

        close(file_unit)
    end procedure to_text_1dc128
    module procedure to_text_1dc64
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals, im=im)
        end if

        close(file_unit)
    end procedure to_text_1dc64
    module procedure to_text_1dc32
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals, im=im)
        end if

        close(file_unit)
    end procedure to_text_1dc32

    module procedure to_text_2dc128
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, &
                                                            decimals=decimals, im=im)
        end do

        close(file_unit)
    end procedure to_text_2dc128
    module procedure to_text_2dc64
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, &
                                                            decimals=decimals, im=im)
        end do

        close(file_unit)
    end procedure to_text_2dc64
    module procedure to_text_2dc32
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, &
                                                            decimals=decimals, im=im)
        end do

        close(file_unit)
    end procedure to_text_2dc32

    module procedure to_text_1dr128
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end if

        close(file_unit)
    end procedure to_text_1dr128
    module procedure to_text_1dr64
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end if

        close(file_unit)
    end procedure to_text_1dr64
    module procedure to_text_1dr32
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), locale=locale, fmt=fmt, decimals=decimals)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end if

        close(file_unit)
    end procedure to_text_1dr32

    module procedure to_text_2dr128
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end do

        close(file_unit)
    end procedure to_text_2dr128
    module procedure to_text_2dr64
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end do

        close(file_unit)
    end procedure to_text_2dr64
    module procedure to_text_2dr32
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), locale=locale, delim=delim, fmt=fmt, decimals=decimals)
        end do

        close(file_unit)
    end procedure to_text_2dr32

    module procedure to_text_1di64
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), fmt=fmt)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, delim=delim, fmt=fmt)
        end if

        close(file_unit)
    end procedure to_text_1di64
    module procedure to_text_1di32
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), fmt=fmt)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, delim=delim, fmt=fmt)
        end if

        close(file_unit)
    end procedure to_text_1di32
    module procedure to_text_1di16
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), fmt=fmt)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, delim=delim, fmt=fmt)
        end if

        close(file_unit)
    end procedure to_text_1di16
    module procedure to_text_1di8
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') str(x(i), fmt=fmt)
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, delim=delim, fmt=fmt)
        end if

        close(file_unit)
    end procedure to_text_1di8

    module procedure to_text_2di64
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), delim=delim, fmt=fmt)
        end do

        close(file_unit)
    end procedure to_text_2di64
    module procedure to_text_2di32
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), delim=delim, fmt=fmt)
        end do

        close(file_unit)
    end procedure to_text_2di32
    module procedure to_text_2di16
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), delim=delim, fmt=fmt)
        end do

        close(file_unit)
    end procedure to_text_2di16
    module procedure to_text_2di8
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), delim=delim, fmt=fmt)
        end do

        close(file_unit)
    end procedure to_text_2di8

    module procedure to_text_1dchar
        logical :: exists
        integer :: file_unit, i
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write(unit=file_unit, fmt='(a)') trim(adjustl(header(1)))
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write(unit=file_unit, fmt='(a)', advance='no') label//str(i)//delim
                end do
                write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=1))
            end if
        else if ( size(header) == size(x) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        if ( dim == 1 ) then
            do i = lbound(x, dim=1), ubound(x, dim=1)
                write(unit=file_unit, fmt='(a)') trim(adjustl(x(i)))
            end do
        else if ( dim == 2 ) then
            write(unit=file_unit, fmt='(a)') to_str(x, delim=delim)
        end if

        close(file_unit)
    end procedure to_text_1dchar

    module procedure to_text_2dchar
        logical :: exists
        integer :: file_unit, i, j
        character(len=:), allocatable :: label

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='formatted', &
                  action='write', access='sequential', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write(unit=file_unit, fmt='(a)', advance='no') label//str(j)//delim
            end do
            write(unit=file_unit, fmt='(a)') label//str(ubound(x, dim=2))
        else if ( size(header) == size(x, dim=2) ) then
            write(unit=file_unit, fmt='(a)') to_str(header, delim=delim)
        end if

        do i = lbound(x, dim=1), ubound(x, dim=1)
            write(unit=file_unit, fmt='(a)') to_str(x(i,:), delim=delim)
        end do

        close(file_unit)
    end procedure to_text_2dchar

    !! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_text_1dc128
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real128) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc128
    module procedure from_text_1dc64
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real64) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc64
    module procedure from_text_1dc32
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real32) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc32

    module procedure from_text_2dc128
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real128) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        ignore_sep = .false.
        row = 1
        column = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(row, column) = c
                if ( column /= n_columns ) then
                    column = column + 1
                else
                    if ( row /= n_rows ) then
                        row = row + 1
                        column = 1
                    else
                        exit read_into
                    end if
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_2dc128
    module procedure from_text_2dc64
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real64) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        ignore_sep = .false.
        row = 1
        column = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(row, column) = c
                if ( column /= n_columns ) then
                    column = column + 1
                else
                    if ( row /= n_rows ) then
                        row = row + 1
                        column = 1
                    else
                        exit read_into
                    end if
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_2dc64
    module procedure from_text_2dc32
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real32) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        ignore_sep = .false.
        row = 1
        column = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'es' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                    read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(row, column) = c
                if ( column /= n_columns ) then
                    column = column + 1
                else
                    if ( row /= n_rows ) then
                        row = row + 1
                        column = 1
                    else
                        exit read_into
                    end if
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='('//fmt//')') c%re
                        read(unit=number(sep_pos+1:), fmt='('//fmt//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_2dc32

    module procedure from_text_1dr128
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr128
    module procedure from_text_1dr64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr64
    module procedure from_text_1dr32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr32

    module procedure from_text_2dr128
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(row, column)
                    end if
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2dr128
    module procedure from_text_2dr64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(row, column)
                    end if
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2dr64
    module procedure from_text_2dr32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(row, column)
                    end if
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2dr32

    module procedure from_text_1di64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di64
    module procedure from_text_1di32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di32
    module procedure from_text_1di16
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di16
    module procedure from_text_1di8
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(ind)
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di8

    module procedure from_text_2di64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2di64
    module procedure from_text_2di32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2di32
    module procedure from_text_2di16
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2di16
    module procedure from_text_2di8
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='('//fmt//')') into(row, column)
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_2di8

    module procedure from_text_1dchar
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(delim) > 0 ) then
            allocate( character(len=1) :: separating_chars(len(delim)+1) )
            do i = 1, len(delim)
                separating_chars(i) = delim(i:i)
            end do
            separating_chars(len(delim)+1) = nl
        else
            separating_chars = [nl]
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(separating_chars == current_char) ) then
                if ( any(separating_chars == prev_char) ) then
                    prev_char = current_char
                else
                    prev_char = current_char
                    n_columns = n_columns + 1
                end if
            else
                prev_char = current_char
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( character(len=word_length) :: into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( character(len=word_length) :: into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            current_char = file(i:i)

            if ( any(separating_chars == current_char) ) then
                if ( .not. any(separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='(a)') into(ind)
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            else
                if ( any(separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            end if
        end do read_into
    end procedure from_text_1dchar

    module procedure from_text_2dchar
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns, file_length
        integer :: i, row, column, l1, l2

        character(len=:), allocatable, dimension(:) :: separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(delim) > 0 ) then
            allocate( character(len=1) :: separating_chars(len(delim)+1) )
            do i = 1, len(delim)
                separating_chars(i) = delim(i:i)
            end do
            separating_chars(len(delim)+1) = nl
        else
            separating_chars = [nl]
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(separating_chars == current_char) ) then
                if ( any(separating_chars == prev_char) ) then
                    prev_char = current_char
                else
                    prev_char = current_char
                    n_columns = n_columns + 1
                end if
            else
                prev_char = current_char
            end if

            if ( current_char == nl ) exit
        end do

        allocate( character(len=word_length) :: into(n_rows, n_columns) )
    
        row = 1
        column = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            current_char = file(i:i)

            if ( any(separating_chars == current_char) ) then
                if ( .not. any(separating_chars == file(l2:l2)) ) then
                    read(unit=file(l1:l2), fmt='(a)') into(row, column)
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        if ( row /= n_rows ) then
                            row = row + 1
                            column = 1
                        else
                            exit read_into
                        end if
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            else
                if ( any(separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            end if
        end do read_into
    end procedure from_text_2dchar
end submodule text_io

submodule (io_fortran_lib) binary_io
    contains
    !! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure to_binary_1dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dc128
    module procedure to_binary_1dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dc64
    module procedure to_binary_1dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_1dc32

    module procedure to_binary_2dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dc128
    module procedure to_binary_2dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dc64
    module procedure to_binary_2dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_2dc32

    module procedure to_binary_3dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dc128
    module procedure to_binary_3dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dc64
    module procedure to_binary_3dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_3dc32

    module procedure to_binary_4dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dc128
    module procedure to_binary_4dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dc64
    module procedure to_binary_4dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_4dc32

    module procedure to_binary_5dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dc128
    module procedure to_binary_5dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dc64
    module procedure to_binary_5dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_5dc32

    module procedure to_binary_6dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dc128
    module procedure to_binary_6dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dc64
    module procedure to_binary_6dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_6dc32

    module procedure to_binary_7dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dc128
    module procedure to_binary_7dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dc64
    module procedure to_binary_7dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_7dc32

    module procedure to_binary_8dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dc128
    module procedure to_binary_8dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dc64
    module procedure to_binary_8dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_8dc32

    module procedure to_binary_9dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dc128
    module procedure to_binary_9dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dc64
    module procedure to_binary_9dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_9dc32

    module procedure to_binary_10dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dc128
    module procedure to_binary_10dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dc64
    module procedure to_binary_10dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_10dc32

    module procedure to_binary_11dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dc128
    module procedure to_binary_11dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dc64
    module procedure to_binary_11dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_11dc32

    module procedure to_binary_12dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dc128
    module procedure to_binary_12dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dc64
    module procedure to_binary_12dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_12dc32

    module procedure to_binary_13dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dc128
    module procedure to_binary_13dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dc64
    module procedure to_binary_13dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_13dc32

    module procedure to_binary_14dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dc128
    module procedure to_binary_14dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dc64
    module procedure to_binary_14dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_14dc32

    module procedure to_binary_15dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dc128
    module procedure to_binary_15dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dc64
    module procedure to_binary_15dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_15dc32

    module procedure to_binary_1dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dr128
    module procedure to_binary_1dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dr64
    module procedure to_binary_1dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_1dr32

    module procedure to_binary_2dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr128
    module procedure to_binary_2dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr64
    module procedure to_binary_2dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr32

    module procedure to_binary_3dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr128
    module procedure to_binary_3dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr64
    module procedure to_binary_3dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr32

    module procedure to_binary_4dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr128
    module procedure to_binary_4dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr64
    module procedure to_binary_4dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr32

    module procedure to_binary_5dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr128
    module procedure to_binary_5dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr64
    module procedure to_binary_5dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr32

    module procedure to_binary_6dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr128
    module procedure to_binary_6dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr64
    module procedure to_binary_6dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr32

    module procedure to_binary_7dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr128
    module procedure to_binary_7dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr64
    module procedure to_binary_7dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr32

    module procedure to_binary_8dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr128
    module procedure to_binary_8dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr64
    module procedure to_binary_8dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr32

    module procedure to_binary_9dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr128
    module procedure to_binary_9dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr64
    module procedure to_binary_9dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr32

    module procedure to_binary_10dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr128
    module procedure to_binary_10dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr64
    module procedure to_binary_10dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr32

    module procedure to_binary_11dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr128
    module procedure to_binary_11dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr64
    module procedure to_binary_11dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr32

    module procedure to_binary_12dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr128
    module procedure to_binary_12dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr64
    module procedure to_binary_12dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr32

    module procedure to_binary_13dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr128
    module procedure to_binary_13dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr64
    module procedure to_binary_13dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr32

    module procedure to_binary_14dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr128
    module procedure to_binary_14dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr64
    module procedure to_binary_14dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr32

    module procedure to_binary_15dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr128
    module procedure to_binary_15dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr64
    module procedure to_binary_15dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr32

    module procedure to_binary_1di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di64
    module procedure to_binary_1di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di32
    module procedure to_binary_1di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di16
    module procedure to_binary_1di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di8

    module procedure to_binary_2di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di64
    module procedure to_binary_2di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di32
    module procedure to_binary_2di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di16
    module procedure to_binary_2di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di8

    module procedure to_binary_3di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di64
    module procedure to_binary_3di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di32
    module procedure to_binary_3di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di16
    module procedure to_binary_3di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di8

    module procedure to_binary_4di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di64
    module procedure to_binary_4di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di32
    module procedure to_binary_4di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di16
    module procedure to_binary_4di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di8

    module procedure to_binary_5di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di64
    module procedure to_binary_5di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di32
    module procedure to_binary_5di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di16
    module procedure to_binary_5di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di8

    module procedure to_binary_6di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di64
    module procedure to_binary_6di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di32
    module procedure to_binary_6di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di16
    module procedure to_binary_6di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di8

    module procedure to_binary_7di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di64
    module procedure to_binary_7di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di32
    module procedure to_binary_7di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di16
    module procedure to_binary_7di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di8

    module procedure to_binary_8di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di64
    module procedure to_binary_8di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di32
    module procedure to_binary_8di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di16
    module procedure to_binary_8di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di8

    module procedure to_binary_9di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di64
    module procedure to_binary_9di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di32
    module procedure to_binary_9di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di16
    module procedure to_binary_9di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di8

    module procedure to_binary_10di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di64
    module procedure to_binary_10di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di32
    module procedure to_binary_10di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di16
    module procedure to_binary_10di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di8

    module procedure to_binary_11di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di64
    module procedure to_binary_11di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di32
    module procedure to_binary_11di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di16
    module procedure to_binary_11di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di8

    module procedure to_binary_12di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di64
    module procedure to_binary_12di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di32
    module procedure to_binary_12di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di16
    module procedure to_binary_12di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di8

    module procedure to_binary_13di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di64
    module procedure to_binary_13di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di32
    module procedure to_binary_13di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di16
    module procedure to_binary_13di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di8

    module procedure to_binary_14di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di64
    module procedure to_binary_14di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di32
    module procedure to_binary_14di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di16
    module procedure to_binary_14di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di8

    module procedure to_binary_15di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di64
    module procedure to_binary_15di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di32
    module procedure to_binary_15di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di16
    module procedure to_binary_15di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di8

    !! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_binary_1dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc128
    module procedure from_binary_1dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc64
    module procedure from_binary_1dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc32

    module procedure from_binary_2dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc128
    module procedure from_binary_2dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc64
    module procedure from_binary_2dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc32

    module procedure from_binary_3dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc128
    module procedure from_binary_3dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc64
    module procedure from_binary_3dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc32

    module procedure from_binary_4dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc128
    module procedure from_binary_4dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc64
    module procedure from_binary_4dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc32

    module procedure from_binary_5dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc128
    module procedure from_binary_5dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc64
    module procedure from_binary_5dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc32

    module procedure from_binary_6dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc128
    module procedure from_binary_6dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc64
    module procedure from_binary_6dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc32

    module procedure from_binary_7dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc128
    module procedure from_binary_7dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc64
    module procedure from_binary_7dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc32

    module procedure from_binary_8dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc128
    module procedure from_binary_8dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc64
    module procedure from_binary_8dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc32

    module procedure from_binary_9dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc128
    module procedure from_binary_9dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc64
    module procedure from_binary_9dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc32

    module procedure from_binary_10dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc128
    module procedure from_binary_10dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc64
    module procedure from_binary_10dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc32

    module procedure from_binary_11dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc128
    module procedure from_binary_11dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc64
    module procedure from_binary_11dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc32

    module procedure from_binary_12dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc128
    module procedure from_binary_12dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc64
    module procedure from_binary_12dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc32

    module procedure from_binary_13dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc128
    module procedure from_binary_13dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc64
    module procedure from_binary_13dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc32

    module procedure from_binary_14dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc128
    module procedure from_binary_14dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc64
    module procedure from_binary_14dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc32

    module procedure from_binary_15dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc128
    module procedure from_binary_15dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc64
    module procedure from_binary_15dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc32

    module procedure from_binary_1dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr128
    module procedure from_binary_1dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr64
    module procedure from_binary_1dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr32

    module procedure from_binary_2dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr128
    module procedure from_binary_2dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr64
    module procedure from_binary_2dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr32

    module procedure from_binary_3dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr128
    module procedure from_binary_3dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr64
    module procedure from_binary_3dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr32

    module procedure from_binary_4dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr128
    module procedure from_binary_4dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr64
    module procedure from_binary_4dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr32

    module procedure from_binary_5dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr128
    module procedure from_binary_5dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr64
    module procedure from_binary_5dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr32

    module procedure from_binary_6dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr128
    module procedure from_binary_6dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr64
    module procedure from_binary_6dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr32

    module procedure from_binary_7dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr128
    module procedure from_binary_7dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr64
    module procedure from_binary_7dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr32

    module procedure from_binary_8dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr128
    module procedure from_binary_8dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr64
    module procedure from_binary_8dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr32

    module procedure from_binary_9dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr128
    module procedure from_binary_9dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr64
    module procedure from_binary_9dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr32

    module procedure from_binary_10dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr128
    module procedure from_binary_10dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr64
    module procedure from_binary_10dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr32

    module procedure from_binary_11dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr128
    module procedure from_binary_11dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr64
    module procedure from_binary_11dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr32

    module procedure from_binary_12dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr128
    module procedure from_binary_12dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr64
    module procedure from_binary_12dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr32

    module procedure from_binary_13dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr128
    module procedure from_binary_13dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr64
    module procedure from_binary_13dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr32

    module procedure from_binary_14dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr128
    module procedure from_binary_14dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr64
    module procedure from_binary_14dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr32

    module procedure from_binary_15dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr128
    module procedure from_binary_15dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr64
    module procedure from_binary_15dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr32

    module procedure from_binary_1di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di64
    module procedure from_binary_1di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di32
    module procedure from_binary_1di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di16
    module procedure from_binary_1di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di8

    module procedure from_binary_2di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di64
    module procedure from_binary_2di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di32
    module procedure from_binary_2di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di16
    module procedure from_binary_2di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di8

    module procedure from_binary_3di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di64
    module procedure from_binary_3di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di32
    module procedure from_binary_3di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di16
    module procedure from_binary_3di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di8

    module procedure from_binary_4di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di64
    module procedure from_binary_4di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di32
    module procedure from_binary_4di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di16
    module procedure from_binary_4di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di8

    module procedure from_binary_5di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di64
    module procedure from_binary_5di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di32
    module procedure from_binary_5di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di16
    module procedure from_binary_5di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di8

    module procedure from_binary_6di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di64
    module procedure from_binary_6di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di32
    module procedure from_binary_6di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di16
    module procedure from_binary_6di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di8

    module procedure from_binary_7di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di64
    module procedure from_binary_7di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di32
    module procedure from_binary_7di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di16
    module procedure from_binary_7di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di8

    module procedure from_binary_8di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di64
    module procedure from_binary_8di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di32
    module procedure from_binary_8di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di16
    module procedure from_binary_8di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di8

    module procedure from_binary_9di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di64
    module procedure from_binary_9di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di32
    module procedure from_binary_9di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di16
    module procedure from_binary_9di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di8

    module procedure from_binary_10di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di64
    module procedure from_binary_10di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di32
    module procedure from_binary_10di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di16
    module procedure from_binary_10di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di8

    module procedure from_binary_11di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di64
    module procedure from_binary_11di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di32
    module procedure from_binary_11di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di16
    module procedure from_binary_11di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di8

    module procedure from_binary_12di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di64
    module procedure from_binary_12di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di32
    module procedure from_binary_12di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di16
    module procedure from_binary_12di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di8

    module procedure from_binary_13di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di64
    module procedure from_binary_13di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di32
    module procedure from_binary_13di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di16
    module procedure from_binary_13di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di8

    module procedure from_binary_14di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di64
    module procedure from_binary_14di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di32
    module procedure from_binary_14di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di16
    module procedure from_binary_14di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di8

    module procedure from_binary_15di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di64
    module procedure from_binary_15di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di32
    module procedure from_binary_15di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di16
    module procedure from_binary_15di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di8
end submodule binary_io
