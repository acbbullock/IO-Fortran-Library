module io_fortran_lib
    !------------------------------------------------------------------------------------------------------------------
    !!  This module provides common I/O routines for arrays of complex, real, integer, and character type. Such
    !!  routines include printing array sections and reading/writing multidimensional arrays from/to text files
    !!  and binary files. An interface for number -> string conversion is provided as well as a simple text logging
    !!  routine. This module is F2018 compliant, has no external dependencies, and has a max line length of 120.
    !------------------------------------------------------------------------------------------------------------------
    use, intrinsic :: iso_fortran_env, only: real128, real64, real32, int64, int32, int16, int8, &     ! Standard kinds
                                             input_unit, output_unit                  ! Standard input and output units
    implicit none (type,external)                                                     ! No implicit types or interfaces
    private

    ! Public API list ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    public :: aprint, to_file, from_file                                                                    ! Array I/O
    public :: str, echo                                                                                    ! String I/O
    public :: String                                                                                          ! Classes
    public :: nl                                                                                            ! Constants

    ! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    character(len=1), parameter :: nl = new_line('a')
    !! This is the new line character constant, provided for the purpose of inserting new lines into strings without
    !! needing to call the `new_line` intrinsic each time.

    character(len=*), dimension(*), parameter :: text_ext   = [ 'csv', 'txt', 'ods', &        ! Allowed text extensions
                                                                'odf', 'odm', 'odt', &
                                                                'xls', 'doc', 'log', &
                                                                'rtf', 'org', 'dbf' ]

    character(len=*), dimension(*), parameter :: binary_ext = [ 'dat', 'bin' ]              ! Allowed binary extensions

    character(len=*), dimension(*), parameter :: real_fmts  = [ 'e', 'f', 'z' ]            ! Allowed formats for floats

    character(len=*), dimension(*), parameter :: int_fmts   = [ 'i', 'z' ]               ! Allowed formats for integers

    character(len=*), dimension(*), parameter :: locales    = [ 'US', 'EU' ]                ! Allowed locale specifiers

    type String                                                                                   ! String wrapper type
        !--------------------------------------------------------------------------------------------------------------
        !! Wrapper type for an allocatable string.
        !!
        !! This type is provided primarily for the purpose of standard compliance when needing to declare arrays of
        !! strings in which the elements may have non-identical lengths or for which the lengths of elements may need
        !! to vary during run-time.
        !!
        !! The form and function of this type was influenced by Rust's
        !! [String](https://doc.rust-lang.org/std/string/struct.String.html).
        !--------------------------------------------------------------------------------------------------------------
        private
        character(len=:), allocatable :: s
        contains
            private
            procedure, pass(self), public :: empty
            procedure, pass(self), public :: len => length
            procedure, pass(self), public :: push
            procedure, pass(self), public :: print => print_String
            procedure, nopass, public :: aprint => aprint_1dString, aprint_2dString
    end type String

    interface String                                                                      ! Submodule String_procedures
        !--------------------------------------------------------------------------------------------------------------
        !! Constructors for type String
        !--------------------------------------------------------------------------------------------------------------
        pure elemental recursive type(String) module function new_Str_c128(x, locale, fmt, decimals, im) result(self)
            complex(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end function new_Str_c128
        pure elemental recursive type(String) module function new_Str_c64(x, locale, fmt, decimals, im) result(self)
            complex(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end function new_Str_c64
        pure elemental recursive type(String) module function new_Str_c32(x, locale, fmt, decimals, im) result(self)
            complex(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end function new_Str_c32

        pure elemental recursive type(String) module function new_Str_r128(x, locale, fmt, decimals) result(self)
            real(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end function new_Str_r128
        pure elemental recursive type(String) module function new_Str_r64(x, locale, fmt, decimals) result(self)
            real(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end function new_Str_r64
        pure elemental recursive type(String) module function new_Str_r32(x, locale, fmt, decimals) result(self)
            real(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end function new_Str_r32

        pure elemental recursive type(String) module function new_Str_i64(x, fmt) result(self)
            integer(int64), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end function new_Str_i64
        pure elemental recursive type(String) module function new_Str_i32(x, fmt) result(self)
            integer(int32), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end function new_Str_i32
        pure elemental recursive type(String) module function new_Str_i16(x, fmt) result(self)
            integer(int16), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end function new_Str_i16
        pure elemental recursive type(String) module function new_Str_i8(x, fmt) result(self)
            integer(int8), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end function new_Str_i8

        pure elemental recursive type(String) module function new_Str_char(chars) result(self)
            character(len=*), intent(in) :: chars
        end function new_Str_char
    end interface

    interface                                                                             ! Submodule String_procedures
        !--------------------------------------------------------------------------------------------------------------
        !! Methods for type String
        !--------------------------------------------------------------------------------------------------------------
        pure elemental recursive module subroutine empty(self)
            !! Sets component s to the empty string '' elementally.
            class(String), intent(inout) :: self
        end subroutine empty

        pure elemental recursive integer module function length(self) result(self_len)
            !! Returns length of component s elementally. Unallocated components return -1.
            class(String), intent(in) :: self
        end function length

        pure elemental recursive module subroutine push(self, chars)
            !! Appends chars to component s elementally.
            class(String), intent(inout) :: self
            character(len=*), intent(in) :: chars
        end subroutine push

        impure recursive module subroutine print_String(self)
            !! Prints component s for non-array String
            class(String), intent(in) :: self
        end subroutine print_String
    end interface

    interface aprint                                                                         ! Submodule array_printing
        !--------------------------------------------------------------------------------------------------------------
        !! Subroutine for printing arrays and array sections to stdout.
        !!
        !! For a user reference, see [aprint](../page/Ref/aprint.html).
        !--------------------------------------------------------------------------------------------------------------
        impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc128
        impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc64
        impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_1dc32

        impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc128
        impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc64
        impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine aprint_2dc32

        impure recursive module subroutine aprint_1dr128(x, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr128
        impure recursive module subroutine aprint_1dr64(x, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr64
        impure recursive module subroutine aprint_1dr32(x, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_1dr32

        impure recursive module subroutine aprint_2dr128(x, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr128
        impure recursive module subroutine aprint_2dr64(x, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr64
        impure recursive module subroutine aprint_2dr32(x, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine aprint_2dr32

        impure recursive module subroutine aprint_1di64(x, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di64
        impure recursive module subroutine aprint_1di32(x, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di32
        impure recursive module subroutine aprint_1di16(x, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di16
        impure recursive module subroutine aprint_1di8(x, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_1di8

        impure recursive module subroutine aprint_2di64(x, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di64
        impure recursive module subroutine aprint_2di32(x, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di32
        impure recursive module subroutine aprint_2di16(x, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di16
        impure recursive module subroutine aprint_2di8(x, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
        end subroutine aprint_2di8

        impure recursive module subroutine aprint_1dchar(x)
            character(len=*), dimension(:), intent(in) :: x
        end subroutine aprint_1dchar

        impure recursive module subroutine aprint_2dchar(x)
            character(len=*), dimension(:,:), intent(in) :: x
        end subroutine aprint_2dchar

        impure recursive module subroutine aprint_1dString(x)
            class(String), dimension(:), intent(in) :: x
        end subroutine aprint_1dString

        impure recursive module subroutine aprint_2dString(x)
            class(String), dimension(:,:), intent(in) :: x
        end subroutine aprint_2dString
    end interface

    interface str                                                                               ! Submodule internal_io
        !--------------------------------------------------------------------------------------------------------------
        !! Function for representing a number as a string.
        !!
        !! By default behavior, `str` will write a `real` or `complex` number using a number of significant digits
        !! required in the worst case for a lossless round-trip conversion starting with the internal model
        !! representation of `x`.
        !!
        !! For a user reference, see [str](../page/Ref/str.html).
        !--------------------------------------------------------------------------------------------------------------
        pure recursive module function str_c128(x, locale, fmt, decimals, im) result(x_str)
            complex(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c128
        pure recursive module function str_c64(x, locale, fmt, decimals, im) result(x_str)
            complex(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c64
        pure recursive module function str_c32(x, locale, fmt, decimals, im) result(x_str)
            complex(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
            character(len=:), allocatable :: x_str
        end function str_c32

        pure recursive module function str_r128(x, locale, fmt, decimals) result(x_str)
            real(real128), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r128
        pure recursive module function str_r64(x, locale, fmt, decimals) result(x_str)
            real(real64), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r64
        pure recursive module function str_r32(x, locale, fmt, decimals) result(x_str)
            real(real32), intent(in) :: x
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=:), allocatable :: x_str
        end function str_r32

        pure recursive module function str_i64(x, fmt) result(x_str)
            integer(int64), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i64
        pure recursive module function str_i32(x, fmt) result(x_str)
            integer(int32), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i32
        pure recursive module function str_i16(x, fmt) result(x_str)
            integer(int16), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i16
        pure recursive module function str_i8(x, fmt) result(x_str)
            integer(int8), intent(in) :: x
            character(len=*), intent(in), optional :: fmt
            character(len=:), allocatable :: x_str
        end function str_i8
    end interface

    interface to_file                                                                               ! Submodule file_io
        !--------------------------------------------------------------------------------------------------------------
        !! Subroutine for writing an array to an external file.
        !!
        !! The file `file_name` will be created if it does not already exist and will be overwritten if it does exist.
        !! Writing to text is allowed for arrays of rank `1` or `2`, and writing to binary is allowed for arrays of any
        !! rank `1`-`15`. Any invalid actual arguments will be ignored, defaults will be assumed, and a warning message
        !! will be issued on stdout.
        !!
        !! For a user reference, see [to_file](../page/Ref/to_file.html).
        !--------------------------------------------------------------------------------------------------------------
        impure recursive module subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc128
        impure recursive module subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc64
        impure recursive module subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_1dc32

        impure recursive module subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc128
        impure recursive module subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc64
        impure recursive module subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
            character(len=*), intent(in), optional :: im
        end subroutine to_file_2dc32

        impure recursive module subroutine to_file_3dc128(x, file_name)
            complex(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc128
        impure recursive module subroutine to_file_3dc64(x, file_name)
            complex(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc64
        impure recursive module subroutine to_file_3dc32(x, file_name)
            complex(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dc32

        impure recursive module subroutine to_file_4dc128(x, file_name)
            complex(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc128
        impure recursive module subroutine to_file_4dc64(x, file_name)
            complex(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc64
        impure recursive module subroutine to_file_4dc32(x, file_name)
            complex(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dc32

        impure recursive module subroutine to_file_5dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc128
        impure recursive module subroutine to_file_5dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc64
        impure recursive module subroutine to_file_5dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dc32

        impure recursive module subroutine to_file_6dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc128
        impure recursive module subroutine to_file_6dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc64
        impure recursive module subroutine to_file_6dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dc32

        impure recursive module subroutine to_file_7dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc128
        impure recursive module subroutine to_file_7dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc64
        impure recursive module subroutine to_file_7dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dc32

        impure recursive module subroutine to_file_8dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc128
        impure recursive module subroutine to_file_8dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc64
        impure recursive module subroutine to_file_8dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dc32

        impure recursive module subroutine to_file_9dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc128
        impure recursive module subroutine to_file_9dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc64
        impure recursive module subroutine to_file_9dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dc32

        impure recursive module subroutine to_file_10dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc128
        impure recursive module subroutine to_file_10dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc64
        impure recursive module subroutine to_file_10dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dc32

        impure recursive module subroutine to_file_11dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc128
        impure recursive module subroutine to_file_11dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc64
        impure recursive module subroutine to_file_11dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dc32

        impure recursive module subroutine to_file_12dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc128
        impure recursive module subroutine to_file_12dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc64
        impure recursive module subroutine to_file_12dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dc32

        impure recursive module subroutine to_file_13dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc128
        impure recursive module subroutine to_file_13dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc64
        impure recursive module subroutine to_file_13dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dc32

        impure recursive module subroutine to_file_14dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc128
        impure recursive module subroutine to_file_14dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc64
        impure recursive module subroutine to_file_14dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dc32

        impure recursive module subroutine to_file_15dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc128
        impure recursive module subroutine to_file_15dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc64
        impure recursive module subroutine to_file_15dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dc32

        impure recursive module subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr128
        impure recursive module subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr64
        impure recursive module subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_1dr32

        impure recursive module subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr128
        impure recursive module subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr64
        impure recursive module subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
            integer, intent(in), optional :: decimals
        end subroutine to_file_2dr32

        impure recursive module subroutine to_file_3dr128(x, file_name)
            real(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr128
        impure recursive module subroutine to_file_3dr64(x, file_name)
            real(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr64
        impure recursive module subroutine to_file_3dr32(x, file_name)
            real(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3dr32

        impure recursive module subroutine to_file_4dr128(x, file_name)
            real(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr128
        impure recursive module subroutine to_file_4dr64(x, file_name)
            real(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr64
        impure recursive module subroutine to_file_4dr32(x, file_name)
            real(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4dr32

        impure recursive module subroutine to_file_5dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr128
        impure recursive module subroutine to_file_5dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr64
        impure recursive module subroutine to_file_5dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5dr32

        impure recursive module subroutine to_file_6dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr128
        impure recursive module subroutine to_file_6dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr64
        impure recursive module subroutine to_file_6dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6dr32

        impure recursive module subroutine to_file_7dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr128
        impure recursive module subroutine to_file_7dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr64
        impure recursive module subroutine to_file_7dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7dr32

        impure recursive module subroutine to_file_8dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr128
        impure recursive module subroutine to_file_8dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr64
        impure recursive module subroutine to_file_8dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8dr32

        impure recursive module subroutine to_file_9dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr128
        impure recursive module subroutine to_file_9dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr64
        impure recursive module subroutine to_file_9dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9dr32

        impure recursive module subroutine to_file_10dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr128
        impure recursive module subroutine to_file_10dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr64
        impure recursive module subroutine to_file_10dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10dr32

        impure recursive module subroutine to_file_11dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr128
        impure recursive module subroutine to_file_11dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr64
        impure recursive module subroutine to_file_11dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11dr32

        impure recursive module subroutine to_file_12dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr128
        impure recursive module subroutine to_file_12dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr64
        impure recursive module subroutine to_file_12dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12dr32

        impure recursive module subroutine to_file_13dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr128
        impure recursive module subroutine to_file_13dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr64
        impure recursive module subroutine to_file_13dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13dr32

        impure recursive module subroutine to_file_14dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr128
        impure recursive module subroutine to_file_14dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr64
        impure recursive module subroutine to_file_14dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14dr32

        impure recursive module subroutine to_file_15dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr128
        impure recursive module subroutine to_file_15dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr64
        impure recursive module subroutine to_file_15dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15dr32

        impure recursive module subroutine to_file_1di64(x, file_name, header, dim, delim, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di64
        impure recursive module subroutine to_file_1di32(x, file_name, header, dim, delim, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di32
        impure recursive module subroutine to_file_1di16(x, file_name, header, dim, delim, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di16
        impure recursive module subroutine to_file_1di8(x, file_name, header, dim, delim, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            integer, intent(in), optional :: dim
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_1di8

        impure recursive module subroutine to_file_2di64(x, file_name, header, delim, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di64
        impure recursive module subroutine to_file_2di32(x, file_name, header, delim, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di32
        impure recursive module subroutine to_file_2di16(x, file_name, header, delim, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di16
        impure recursive module subroutine to_file_2di8(x, file_name, header, delim, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in), optional :: header
            character(len=*), intent(in), optional :: delim
            character(len=*), intent(in), optional :: fmt
        end subroutine to_file_2di8

        impure recursive module subroutine to_file_3di64(x, file_name)
            integer(int64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di64
        impure recursive module subroutine to_file_3di32(x, file_name)
            integer(int32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di32
        impure recursive module subroutine to_file_3di16(x, file_name)
            integer(int16), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di16
        impure recursive module subroutine to_file_3di8(x, file_name)
            integer(int8), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_3di8

        impure recursive module subroutine to_file_4di64(x, file_name)
            integer(int64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di64
        impure recursive module subroutine to_file_4di32(x, file_name)
            integer(int32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di32
        impure recursive module subroutine to_file_4di16(x, file_name)
            integer(int16), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di16
        impure recursive module subroutine to_file_4di8(x, file_name)
            integer(int8), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_4di8

        impure recursive module subroutine to_file_5di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di64
        impure recursive module subroutine to_file_5di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di32
        impure recursive module subroutine to_file_5di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di16
        impure recursive module subroutine to_file_5di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_5di8

        impure recursive module subroutine to_file_6di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di64
        impure recursive module subroutine to_file_6di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di32
        impure recursive module subroutine to_file_6di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di16
        impure recursive module subroutine to_file_6di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_6di8

        impure recursive module subroutine to_file_7di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di64
        impure recursive module subroutine to_file_7di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di32
        impure recursive module subroutine to_file_7di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di16
        impure recursive module subroutine to_file_7di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_7di8

        impure recursive module subroutine to_file_8di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di64
        impure recursive module subroutine to_file_8di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di32
        impure recursive module subroutine to_file_8di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di16
        impure recursive module subroutine to_file_8di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_8di8

        impure recursive module subroutine to_file_9di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di64
        impure recursive module subroutine to_file_9di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di32
        impure recursive module subroutine to_file_9di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di16
        impure recursive module subroutine to_file_9di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_9di8

        impure recursive module subroutine to_file_10di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di64
        impure recursive module subroutine to_file_10di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di32
        impure recursive module subroutine to_file_10di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di16
        impure recursive module subroutine to_file_10di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_10di8

        impure recursive module subroutine to_file_11di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di64
        impure recursive module subroutine to_file_11di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di32
        impure recursive module subroutine to_file_11di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di16
        impure recursive module subroutine to_file_11di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_11di8

        impure recursive module subroutine to_file_12di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di64
        impure recursive module subroutine to_file_12di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di32
        impure recursive module subroutine to_file_12di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di16
        impure recursive module subroutine to_file_12di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_12di8

        impure recursive module subroutine to_file_13di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di64
        impure recursive module subroutine to_file_13di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di32
        impure recursive module subroutine to_file_13di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di16
        impure recursive module subroutine to_file_13di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_13di8

        impure recursive module subroutine to_file_14di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di64
        impure recursive module subroutine to_file_14di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di32
        impure recursive module subroutine to_file_14di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di16
        impure recursive module subroutine to_file_14di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_14di8

        impure recursive module subroutine to_file_15di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di64
        impure recursive module subroutine to_file_15di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di32
        impure recursive module subroutine to_file_15di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di16
        impure recursive module subroutine to_file_15di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_file_15di8
    end interface

    interface from_file                                                                             ! Submodule file_io
        !--------------------------------------------------------------------------------------------------------------
        !! Subroutine for reading an external file into an array.
        !!
        !! In the event that any actual arguments provided to `from_file` are invalid, the subprogram will not allow
        !! progression of execution of the caller and will issue an `error stop`. This is due to the critical nature of
        !! reads and the fact that the procedure may not be able to make the proper assumptions about the data being
        !! read.
        !!
        !! For a user reference, see [from_file](../page/Ref/from_file.html).
        !--------------------------------------------------------------------------------------------------------------
        impure recursive module subroutine from_textfile_1dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc128
        impure recursive module subroutine from_binaryfile_1dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc128
        impure recursive module subroutine from_textfile_1dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc64
        impure recursive module subroutine from_binaryfile_1dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc64
        impure recursive module subroutine from_textfile_1dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_1dc32
        impure recursive module subroutine from_binaryfile_1dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dc32

        impure recursive module subroutine from_textfile_2dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc128
        impure recursive module subroutine from_binaryfile_2dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc128
        impure recursive module subroutine from_textfile_2dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc64
        impure recursive module subroutine from_binaryfile_2dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc64
        impure recursive module subroutine from_textfile_2dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
            character(len=*), intent(in), optional :: im
        end subroutine from_textfile_2dc32
        impure recursive module subroutine from_binaryfile_2dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dc32

        impure recursive module subroutine from_file_3dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc128
        impure recursive module subroutine from_file_3dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc64
        impure recursive module subroutine from_file_3dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dc32

        impure recursive module subroutine from_file_4dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc128
        impure recursive module subroutine from_file_4dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc64
        impure recursive module subroutine from_file_4dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dc32

        impure recursive module subroutine from_file_5dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc128
        impure recursive module subroutine from_file_5dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc64
        impure recursive module subroutine from_file_5dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dc32

        impure recursive module subroutine from_file_6dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc128
        impure recursive module subroutine from_file_6dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc64
        impure recursive module subroutine from_file_6dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dc32

        impure recursive module subroutine from_file_7dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc128
        impure recursive module subroutine from_file_7dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc64
        impure recursive module subroutine from_file_7dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dc32

        impure recursive module subroutine from_file_8dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc128
        impure recursive module subroutine from_file_8dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc64
        impure recursive module subroutine from_file_8dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dc32

        impure recursive module subroutine from_file_9dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc128
        impure recursive module subroutine from_file_9dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc64
        impure recursive module subroutine from_file_9dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dc32

        impure recursive module subroutine from_file_10dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc128
        impure recursive module subroutine from_file_10dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc64
        impure recursive module subroutine from_file_10dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dc32

        impure recursive module subroutine from_file_11dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc128
        impure recursive module subroutine from_file_11dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc64
        impure recursive module subroutine from_file_11dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dc32

        impure recursive module subroutine from_file_12dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc128
        impure recursive module subroutine from_file_12dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc64
        impure recursive module subroutine from_file_12dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dc32

        impure recursive module subroutine from_file_13dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc128
        impure recursive module subroutine from_file_13dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc64
        impure recursive module subroutine from_file_13dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dc32

        impure recursive module subroutine from_file_14dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc128
        impure recursive module subroutine from_file_14dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc64
        impure recursive module subroutine from_file_14dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dc32

        impure recursive module subroutine from_file_15dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc128
        impure recursive module subroutine from_file_15dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc64
        impure recursive module subroutine from_file_15dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dc32

        impure recursive module subroutine from_textfile_1dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr128
        impure recursive module subroutine from_binaryfile_1dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr128
        impure recursive module subroutine from_textfile_1dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr64
        impure recursive module subroutine from_binaryfile_1dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr64
        impure recursive module subroutine from_textfile_1dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1dr32
        impure recursive module subroutine from_binaryfile_1dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1dr32

        impure recursive module subroutine from_textfile_2dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr128
        impure recursive module subroutine from_binaryfile_2dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr128
        impure recursive module subroutine from_textfile_2dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr64
        impure recursive module subroutine from_binaryfile_2dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr64
        impure recursive module subroutine from_textfile_2dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: locale
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2dr32
        impure recursive module subroutine from_binaryfile_2dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2dr32

        impure recursive module subroutine from_file_3dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr128
        impure recursive module subroutine from_file_3dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr64
        impure recursive module subroutine from_file_3dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3dr32

        impure recursive module subroutine from_file_4dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr128
        impure recursive module subroutine from_file_4dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr64
        impure recursive module subroutine from_file_4dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4dr32

        impure recursive module subroutine from_file_5dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr128
        impure recursive module subroutine from_file_5dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr64
        impure recursive module subroutine from_file_5dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5dr32

        impure recursive module subroutine from_file_6dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr128
        impure recursive module subroutine from_file_6dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr64
        impure recursive module subroutine from_file_6dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6dr32

        impure recursive module subroutine from_file_7dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr128
        impure recursive module subroutine from_file_7dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr64
        impure recursive module subroutine from_file_7dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7dr32

        impure recursive module subroutine from_file_8dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr128
        impure recursive module subroutine from_file_8dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr64
        impure recursive module subroutine from_file_8dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8dr32

        impure recursive module subroutine from_file_9dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr128
        impure recursive module subroutine from_file_9dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr64
        impure recursive module subroutine from_file_9dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9dr32

        impure recursive module subroutine from_file_10dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr128
        impure recursive module subroutine from_file_10dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr64
        impure recursive module subroutine from_file_10dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10dr32

        impure recursive module subroutine from_file_11dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr128
        impure recursive module subroutine from_file_11dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr64
        impure recursive module subroutine from_file_11dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11dr32

        impure recursive module subroutine from_file_12dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr128
        impure recursive module subroutine from_file_12dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr64
        impure recursive module subroutine from_file_12dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12dr32

        impure recursive module subroutine from_file_13dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr128
        impure recursive module subroutine from_file_13dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr64
        impure recursive module subroutine from_file_13dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13dr32

        impure recursive module subroutine from_file_14dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr128
        impure recursive module subroutine from_file_14dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr64
        impure recursive module subroutine from_file_14dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14dr32

        impure recursive module subroutine from_file_15dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr128
        impure recursive module subroutine from_file_15dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr64
        impure recursive module subroutine from_file_15dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15dr32

        impure recursive module subroutine from_textfile_1di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di64
        impure recursive module subroutine from_binaryfile_1di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di64
        impure recursive module subroutine from_textfile_1di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di32
        impure recursive module subroutine from_binaryfile_1di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di32
        impure recursive module subroutine from_textfile_1di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di16
        impure recursive module subroutine from_binaryfile_1di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di16
        impure recursive module subroutine from_textfile_1di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_1di8
        impure recursive module subroutine from_binaryfile_1di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_1di8

        impure recursive module subroutine from_textfile_2di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di64
        impure recursive module subroutine from_binaryfile_2di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di64
        impure recursive module subroutine from_textfile_2di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di32
        impure recursive module subroutine from_binaryfile_2di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di32
        impure recursive module subroutine from_textfile_2di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di16
        impure recursive module subroutine from_binaryfile_2di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di16
        impure recursive module subroutine from_textfile_2di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in), optional :: header
            character(len=*), intent(in), optional :: fmt
        end subroutine from_textfile_2di8
        impure recursive module subroutine from_binaryfile_2di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binaryfile_2di8

        impure recursive module subroutine from_file_3di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di64
        impure recursive module subroutine from_file_3di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di32
        impure recursive module subroutine from_file_3di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di16
        impure recursive module subroutine from_file_3di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_3di8

        impure recursive module subroutine from_file_4di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di64
        impure recursive module subroutine from_file_4di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di32
        impure recursive module subroutine from_file_4di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di16
        impure recursive module subroutine from_file_4di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_4di8

        impure recursive module subroutine from_file_5di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di64
        impure recursive module subroutine from_file_5di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di32
        impure recursive module subroutine from_file_5di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di16
        impure recursive module subroutine from_file_5di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_5di8

        impure recursive module subroutine from_file_6di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di64
        impure recursive module subroutine from_file_6di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di32
        impure recursive module subroutine from_file_6di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di16
        impure recursive module subroutine from_file_6di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_6di8

        impure recursive module subroutine from_file_7di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di64
        impure recursive module subroutine from_file_7di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di32
        impure recursive module subroutine from_file_7di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di16
        impure recursive module subroutine from_file_7di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_7di8

        impure recursive module subroutine from_file_8di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di64
        impure recursive module subroutine from_file_8di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di32
        impure recursive module subroutine from_file_8di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di16
        impure recursive module subroutine from_file_8di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_8di8

        impure recursive module subroutine from_file_9di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di64
        impure recursive module subroutine from_file_9di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di32
        impure recursive module subroutine from_file_9di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di16
        impure recursive module subroutine from_file_9di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_9di8

        impure recursive module subroutine from_file_10di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di64
        impure recursive module subroutine from_file_10di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di32
        impure recursive module subroutine from_file_10di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di16
        impure recursive module subroutine from_file_10di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_10di8

        impure recursive module subroutine from_file_11di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di64
        impure recursive module subroutine from_file_11di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di32
        impure recursive module subroutine from_file_11di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di16
        impure recursive module subroutine from_file_11di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_11di8

        impure recursive module subroutine from_file_12di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di64
        impure recursive module subroutine from_file_12di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di32
        impure recursive module subroutine from_file_12di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di16
        impure recursive module subroutine from_file_12di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_12di8

        impure recursive module subroutine from_file_13di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di64
        impure recursive module subroutine from_file_13di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di32
        impure recursive module subroutine from_file_13di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di16
        impure recursive module subroutine from_file_13di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_13di8

        impure recursive module subroutine from_file_14di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di64
        impure recursive module subroutine from_file_14di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di32
        impure recursive module subroutine from_file_14di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di16
        impure recursive module subroutine from_file_14di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_14di8

        impure recursive module subroutine from_file_15di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di64
        impure recursive module subroutine from_file_15di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di32
        impure recursive module subroutine from_file_15di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di16
        impure recursive module subroutine from_file_15di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_file_15di8
    end interface

    interface echo                                                                                  ! Submodule text_io
        !--------------------------------------------------------------------------------------------------------------
        !! Subroutine for writing a string to an external file.
        !!
        !! The file `file_name` will be created if it does not already exist and will be overwritten if `append` is
        !! `.false.` (if it already exists), with a new line always being inserted at the end of `string`.
        !!
        !! For a user reference, see [echo](../page/Ref/echo.html).
        !--------------------------------------------------------------------------------------------------------------
        impure recursive module subroutine echo_string(string, file_name, append)
            character(len=*), intent(in) :: string
            character(len=*), intent(in) :: file_name
            logical, optional, intent(in) :: append
        end subroutine echo_string
    end interface

    interface to_text                                                                               ! Submodule text_io
        !! Private interface for writing an array to an external text file.
        impure recursive module subroutine to_text_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc128
        impure recursive module subroutine to_text_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc64
        impure recursive module subroutine to_text_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_1dc32

        impure recursive module subroutine to_text_2dc128(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc128
        impure recursive module subroutine to_text_2dc64(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc64
        impure recursive module subroutine to_text_2dc32(x, file_name, header, locale, delim, fmt, decimals, im)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
            character(len=*), intent(in) :: im
        end subroutine to_text_2dc32

        impure recursive module subroutine to_text_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr128
        impure recursive module subroutine to_text_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr64
        impure recursive module subroutine to_text_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_1dr32

        impure recursive module subroutine to_text_2dr128(x, file_name, header, locale, delim, fmt, decimals)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr128
        impure recursive module subroutine to_text_2dr64(x, file_name, header, locale, delim, fmt, decimals)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr64
        impure recursive module subroutine to_text_2dr32(x, file_name, header, locale, delim, fmt, decimals)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
            integer, intent(in) :: decimals
        end subroutine to_text_2dr32

        impure recursive module subroutine to_text_1di64(x, file_name, header, dim, delim, fmt)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di64
        impure recursive module subroutine to_text_1di32(x, file_name, header, dim, delim, fmt)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di32
        impure recursive module subroutine to_text_1di16(x, file_name, header, dim, delim, fmt)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di16
        impure recursive module subroutine to_text_1di8(x, file_name, header, dim, delim, fmt)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            integer, intent(in) :: dim
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_1di8

        impure recursive module subroutine to_text_2di64(x, file_name, header, delim, fmt)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di64
        impure recursive module subroutine to_text_2di32(x, file_name, header, delim, fmt)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di32
        impure recursive module subroutine to_text_2di16(x, file_name, header, delim, fmt)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di16
        impure recursive module subroutine to_text_2di8(x, file_name, header, delim, fmt)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
            character(len=*), dimension(:), intent(in) :: header
            character(len=*), intent(in) :: delim
            character(len=*), intent(in) :: fmt
        end subroutine to_text_2di8
    end interface

    interface from_text                                                                             ! Submodule text_io
        !! Private interface for reading an external text file into an array.
        impure recursive module subroutine from_text_1dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc128
        impure recursive module subroutine from_text_1dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc64
        impure recursive module subroutine from_text_1dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_1dc32

        impure recursive module subroutine from_text_2dc128(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc128
        impure recursive module subroutine from_text_2dc64(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc64
        impure recursive module subroutine from_text_2dc32(file_name, into, header, locale, fmt, im)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
            character(len=*), intent(in) :: im
        end subroutine from_text_2dc32

        impure recursive module subroutine from_text_1dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr128
        impure recursive module subroutine from_text_1dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr64
        impure recursive module subroutine from_text_1dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1dr32

        impure recursive module subroutine from_text_2dr128(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr128
        impure recursive module subroutine from_text_2dr64(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr64
        impure recursive module subroutine from_text_2dr32(file_name, into, header, locale, fmt)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: locale
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2dr32

        impure recursive module subroutine from_text_1di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di64
        impure recursive module subroutine from_text_1di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di32
        impure recursive module subroutine from_text_1di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di16
        impure recursive module subroutine from_text_1di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_1di8

        impure recursive module subroutine from_text_2di64(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di64
        impure recursive module subroutine from_text_2di32(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di32
        impure recursive module subroutine from_text_2di16(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di16
        impure recursive module subroutine from_text_2di8(file_name, into, header, fmt)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            logical, intent(in) :: header
            character(len=*), intent(in) :: fmt
        end subroutine from_text_2di8
    end interface

    interface to_binary                                                                           ! Submodule binary_io
        !! Private interface for writing an array to an external binary file.
        impure recursive module subroutine to_binary_1dc128(x, file_name)
            complex(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc128
        impure recursive module subroutine to_binary_1dc64(x, file_name)
            complex(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc64
        impure recursive module subroutine to_binary_1dc32(x, file_name)
            complex(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dc32

        impure recursive module subroutine to_binary_2dc128(x, file_name)
            complex(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc128
        impure recursive module subroutine to_binary_2dc64(x, file_name)
            complex(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc64
        impure recursive module subroutine to_binary_2dc32(x, file_name)
            complex(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dc32

        impure recursive module subroutine to_binary_3dc128(x, file_name)
            complex(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc128
        impure recursive module subroutine to_binary_3dc64(x, file_name)
            complex(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc64
        impure recursive module subroutine to_binary_3dc32(x, file_name)
            complex(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dc32

        impure recursive module subroutine to_binary_4dc128(x, file_name)
            complex(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc128
        impure recursive module subroutine to_binary_4dc64(x, file_name)
            complex(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc64
        impure recursive module subroutine to_binary_4dc32(x, file_name)
            complex(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dc32

        impure recursive module subroutine to_binary_5dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc128
        impure recursive module subroutine to_binary_5dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc64
        impure recursive module subroutine to_binary_5dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dc32

        impure recursive module subroutine to_binary_6dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc128
        impure recursive module subroutine to_binary_6dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc64
        impure recursive module subroutine to_binary_6dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dc32

        impure recursive module subroutine to_binary_7dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc128
        impure recursive module subroutine to_binary_7dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc64
        impure recursive module subroutine to_binary_7dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dc32

        impure recursive module subroutine to_binary_8dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc128
        impure recursive module subroutine to_binary_8dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc64
        impure recursive module subroutine to_binary_8dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dc32

        impure recursive module subroutine to_binary_9dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc128
        impure recursive module subroutine to_binary_9dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc64
        impure recursive module subroutine to_binary_9dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dc32

        impure recursive module subroutine to_binary_10dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc128
        impure recursive module subroutine to_binary_10dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc64
        impure recursive module subroutine to_binary_10dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dc32

        impure recursive module subroutine to_binary_11dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc128
        impure recursive module subroutine to_binary_11dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc64
        impure recursive module subroutine to_binary_11dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dc32

        impure recursive module subroutine to_binary_12dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc128
        impure recursive module subroutine to_binary_12dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc64
        impure recursive module subroutine to_binary_12dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dc32

        impure recursive module subroutine to_binary_13dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc128
        impure recursive module subroutine to_binary_13dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc64
        impure recursive module subroutine to_binary_13dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dc32

        impure recursive module subroutine to_binary_14dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc128
        impure recursive module subroutine to_binary_14dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc64
        impure recursive module subroutine to_binary_14dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dc32

        impure recursive module subroutine to_binary_15dc128(x, file_name)
            complex(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc128
        impure recursive module subroutine to_binary_15dc64(x, file_name)
            complex(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc64
        impure recursive module subroutine to_binary_15dc32(x, file_name)
            complex(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dc32

        impure recursive module subroutine to_binary_1dr128(x, file_name)
            real(real128), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr128
        impure recursive module subroutine to_binary_1dr64(x, file_name)
            real(real64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr64
        impure recursive module subroutine to_binary_1dr32(x, file_name)
            real(real32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1dr32

        impure recursive module subroutine to_binary_2dr128(x, file_name)
            real(real128), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr128
        impure recursive module subroutine to_binary_2dr64(x, file_name)
            real(real64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr64
        impure recursive module subroutine to_binary_2dr32(x, file_name)
            real(real32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2dr32

        impure recursive module subroutine to_binary_3dr128(x, file_name)
            real(real128), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr128
        impure recursive module subroutine to_binary_3dr64(x, file_name)
            real(real64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr64
        impure recursive module subroutine to_binary_3dr32(x, file_name)
            real(real32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3dr32

        impure recursive module subroutine to_binary_4dr128(x, file_name)
            real(real128), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr128
        impure recursive module subroutine to_binary_4dr64(x, file_name)
            real(real64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr64
        impure recursive module subroutine to_binary_4dr32(x, file_name)
            real(real32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4dr32

        impure recursive module subroutine to_binary_5dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr128
        impure recursive module subroutine to_binary_5dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr64
        impure recursive module subroutine to_binary_5dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5dr32

        impure recursive module subroutine to_binary_6dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr128
        impure recursive module subroutine to_binary_6dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr64
        impure recursive module subroutine to_binary_6dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6dr32

        impure recursive module subroutine to_binary_7dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr128
        impure recursive module subroutine to_binary_7dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr64
        impure recursive module subroutine to_binary_7dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7dr32

        impure recursive module subroutine to_binary_8dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr128
        impure recursive module subroutine to_binary_8dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr64
        impure recursive module subroutine to_binary_8dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8dr32

        impure recursive module subroutine to_binary_9dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr128
        impure recursive module subroutine to_binary_9dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr64
        impure recursive module subroutine to_binary_9dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9dr32

        impure recursive module subroutine to_binary_10dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr128
        impure recursive module subroutine to_binary_10dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr64
        impure recursive module subroutine to_binary_10dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10dr32

        impure recursive module subroutine to_binary_11dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr128
        impure recursive module subroutine to_binary_11dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr64
        impure recursive module subroutine to_binary_11dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11dr32

        impure recursive module subroutine to_binary_12dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr128
        impure recursive module subroutine to_binary_12dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr64
        impure recursive module subroutine to_binary_12dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12dr32

        impure recursive module subroutine to_binary_13dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr128
        impure recursive module subroutine to_binary_13dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr64
        impure recursive module subroutine to_binary_13dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13dr32

        impure recursive module subroutine to_binary_14dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr128
        impure recursive module subroutine to_binary_14dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr64
        impure recursive module subroutine to_binary_14dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14dr32

        impure recursive module subroutine to_binary_15dr128(x, file_name)
            real(real128), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr128
        impure recursive module subroutine to_binary_15dr64(x, file_name)
            real(real64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr64
        impure recursive module subroutine to_binary_15dr32(x, file_name)
            real(real32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15dr32

        impure recursive module subroutine to_binary_1di64(x, file_name)
            integer(int64), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di64
        impure recursive module subroutine to_binary_1di32(x, file_name)
            integer(int32), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di32
        impure recursive module subroutine to_binary_1di16(x, file_name)
            integer(int16), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di16
        impure recursive module subroutine to_binary_1di8(x, file_name)
            integer(int8), dimension(:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_1di8

        impure recursive module subroutine to_binary_2di64(x, file_name)
            integer(int64), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di64
        impure recursive module subroutine to_binary_2di32(x, file_name)
            integer(int32), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di32
        impure recursive module subroutine to_binary_2di16(x, file_name)
            integer(int16), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di16
        impure recursive module subroutine to_binary_2di8(x, file_name)
            integer(int8), dimension(:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_2di8

        impure recursive module subroutine to_binary_3di64(x, file_name)
            integer(int64), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di64
        impure recursive module subroutine to_binary_3di32(x, file_name)
            integer(int32), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di32
        impure recursive module subroutine to_binary_3di16(x, file_name)
            integer(int16), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di16
        impure recursive module subroutine to_binary_3di8(x, file_name)
            integer(int8), dimension(:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_3di8

        impure recursive module subroutine to_binary_4di64(x, file_name)
            integer(int64), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di64
        impure recursive module subroutine to_binary_4di32(x, file_name)
            integer(int32), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di32
        impure recursive module subroutine to_binary_4di16(x, file_name)
            integer(int16), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di16
        impure recursive module subroutine to_binary_4di8(x, file_name)
            integer(int8), dimension(:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_4di8

        impure recursive module subroutine to_binary_5di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di64
        impure recursive module subroutine to_binary_5di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di32
        impure recursive module subroutine to_binary_5di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di16
        impure recursive module subroutine to_binary_5di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_5di8

        impure recursive module subroutine to_binary_6di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di64
        impure recursive module subroutine to_binary_6di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di32
        impure recursive module subroutine to_binary_6di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di16
        impure recursive module subroutine to_binary_6di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_6di8

        impure recursive module subroutine to_binary_7di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di64
        impure recursive module subroutine to_binary_7di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di32
        impure recursive module subroutine to_binary_7di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di16
        impure recursive module subroutine to_binary_7di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_7di8

        impure recursive module subroutine to_binary_8di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di64
        impure recursive module subroutine to_binary_8di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di32
        impure recursive module subroutine to_binary_8di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di16
        impure recursive module subroutine to_binary_8di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_8di8

        impure recursive module subroutine to_binary_9di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di64
        impure recursive module subroutine to_binary_9di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di32
        impure recursive module subroutine to_binary_9di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di16
        impure recursive module subroutine to_binary_9di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_9di8

        impure recursive module subroutine to_binary_10di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di64
        impure recursive module subroutine to_binary_10di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di32
        impure recursive module subroutine to_binary_10di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di16
        impure recursive module subroutine to_binary_10di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_10di8

        impure recursive module subroutine to_binary_11di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di64
        impure recursive module subroutine to_binary_11di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di32
        impure recursive module subroutine to_binary_11di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di16
        impure recursive module subroutine to_binary_11di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_11di8

        impure recursive module subroutine to_binary_12di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di64
        impure recursive module subroutine to_binary_12di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di32
        impure recursive module subroutine to_binary_12di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di16
        impure recursive module subroutine to_binary_12di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_12di8

        impure recursive module subroutine to_binary_13di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di64
        impure recursive module subroutine to_binary_13di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di32
        impure recursive module subroutine to_binary_13di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di16
        impure recursive module subroutine to_binary_13di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_13di8

        impure recursive module subroutine to_binary_14di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di64
        impure recursive module subroutine to_binary_14di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di32
        impure recursive module subroutine to_binary_14di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di16
        impure recursive module subroutine to_binary_14di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_14di8

        impure recursive module subroutine to_binary_15di64(x, file_name)
            integer(int64), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di64
        impure recursive module subroutine to_binary_15di32(x, file_name)
            integer(int32), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di32
        impure recursive module subroutine to_binary_15di16(x, file_name)
            integer(int16), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di16
        impure recursive module subroutine to_binary_15di8(x, file_name)
            integer(int8), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(in) :: x
            character(len=*), intent(in) :: file_name
        end subroutine to_binary_15di8
    end interface

    interface from_binary                                                                         ! Submodule binary_io
        !! Private interface for reading an external binary file into an array.
        impure recursive module subroutine from_binary_1dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc128
        impure recursive module subroutine from_binary_1dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc64
        impure recursive module subroutine from_binary_1dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dc32

        impure recursive module subroutine from_binary_2dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc128
        impure recursive module subroutine from_binary_2dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc64
        impure recursive module subroutine from_binary_2dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dc32

        impure recursive module subroutine from_binary_3dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc128
        impure recursive module subroutine from_binary_3dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc64
        impure recursive module subroutine from_binary_3dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dc32

        impure recursive module subroutine from_binary_4dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc128
        impure recursive module subroutine from_binary_4dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc64
        impure recursive module subroutine from_binary_4dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dc32

        impure recursive module subroutine from_binary_5dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc128
        impure recursive module subroutine from_binary_5dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc64
        impure recursive module subroutine from_binary_5dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dc32

        impure recursive module subroutine from_binary_6dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc128
        impure recursive module subroutine from_binary_6dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc64
        impure recursive module subroutine from_binary_6dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dc32

        impure recursive module subroutine from_binary_7dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc128
        impure recursive module subroutine from_binary_7dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc64
        impure recursive module subroutine from_binary_7dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dc32

        impure recursive module subroutine from_binary_8dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc128
        impure recursive module subroutine from_binary_8dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc64
        impure recursive module subroutine from_binary_8dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dc32

        impure recursive module subroutine from_binary_9dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc128
        impure recursive module subroutine from_binary_9dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc64
        impure recursive module subroutine from_binary_9dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dc32

        impure recursive module subroutine from_binary_10dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc128
        impure recursive module subroutine from_binary_10dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc64
        impure recursive module subroutine from_binary_10dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dc32

        impure recursive module subroutine from_binary_11dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc128
        impure recursive module subroutine from_binary_11dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc64
        impure recursive module subroutine from_binary_11dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dc32

        impure recursive module subroutine from_binary_12dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc128
        impure recursive module subroutine from_binary_12dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc64
        impure recursive module subroutine from_binary_12dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dc32

        impure recursive module subroutine from_binary_13dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc128
        impure recursive module subroutine from_binary_13dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc64
        impure recursive module subroutine from_binary_13dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dc32

        impure recursive module subroutine from_binary_14dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc128
        impure recursive module subroutine from_binary_14dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc64
        impure recursive module subroutine from_binary_14dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dc32

        impure recursive module subroutine from_binary_15dc128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc128
        impure recursive module subroutine from_binary_15dc64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc64
        impure recursive module subroutine from_binary_15dc32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            complex(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dc32

        impure recursive module subroutine from_binary_1dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr128
        impure recursive module subroutine from_binary_1dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr64
        impure recursive module subroutine from_binary_1dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1dr32

        impure recursive module subroutine from_binary_2dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr128
        impure recursive module subroutine from_binary_2dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr64
        impure recursive module subroutine from_binary_2dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2dr32

        impure recursive module subroutine from_binary_3dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr128
        impure recursive module subroutine from_binary_3dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr64
        impure recursive module subroutine from_binary_3dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3dr32

        impure recursive module subroutine from_binary_4dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr128
        impure recursive module subroutine from_binary_4dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr64
        impure recursive module subroutine from_binary_4dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4dr32

        impure recursive module subroutine from_binary_5dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr128
        impure recursive module subroutine from_binary_5dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr64
        impure recursive module subroutine from_binary_5dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5dr32

        impure recursive module subroutine from_binary_6dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr128
        impure recursive module subroutine from_binary_6dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr64
        impure recursive module subroutine from_binary_6dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6dr32

        impure recursive module subroutine from_binary_7dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr128
        impure recursive module subroutine from_binary_7dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr64
        impure recursive module subroutine from_binary_7dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7dr32

        impure recursive module subroutine from_binary_8dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr128
        impure recursive module subroutine from_binary_8dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr64
        impure recursive module subroutine from_binary_8dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8dr32

        impure recursive module subroutine from_binary_9dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr128
        impure recursive module subroutine from_binary_9dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr64
        impure recursive module subroutine from_binary_9dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9dr32

        impure recursive module subroutine from_binary_10dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr128
        impure recursive module subroutine from_binary_10dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr64
        impure recursive module subroutine from_binary_10dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10dr32

        impure recursive module subroutine from_binary_11dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr128
        impure recursive module subroutine from_binary_11dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr64
        impure recursive module subroutine from_binary_11dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11dr32

        impure recursive module subroutine from_binary_12dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr128
        impure recursive module subroutine from_binary_12dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr64
        impure recursive module subroutine from_binary_12dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12dr32

        impure recursive module subroutine from_binary_13dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr128
        impure recursive module subroutine from_binary_13dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr64
        impure recursive module subroutine from_binary_13dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13dr32

        impure recursive module subroutine from_binary_14dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr128
        impure recursive module subroutine from_binary_14dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr64
        impure recursive module subroutine from_binary_14dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14dr32

        impure recursive module subroutine from_binary_15dr128(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real128), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr128
        impure recursive module subroutine from_binary_15dr64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr64
        impure recursive module subroutine from_binary_15dr32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            real(real32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15dr32

        impure recursive module subroutine from_binary_1di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di64
        impure recursive module subroutine from_binary_1di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di32
        impure recursive module subroutine from_binary_1di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di16
        impure recursive module subroutine from_binary_1di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_1di8

        impure recursive module subroutine from_binary_2di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di64
        impure recursive module subroutine from_binary_2di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di32
        impure recursive module subroutine from_binary_2di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di16
        impure recursive module subroutine from_binary_2di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_2di8

        impure recursive module subroutine from_binary_3di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di64
        impure recursive module subroutine from_binary_3di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di32
        impure recursive module subroutine from_binary_3di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di16
        impure recursive module subroutine from_binary_3di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_3di8

        impure recursive module subroutine from_binary_4di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di64
        impure recursive module subroutine from_binary_4di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di32
        impure recursive module subroutine from_binary_4di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di16
        impure recursive module subroutine from_binary_4di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_4di8

        impure recursive module subroutine from_binary_5di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di64
        impure recursive module subroutine from_binary_5di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di32
        impure recursive module subroutine from_binary_5di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di16
        impure recursive module subroutine from_binary_5di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_5di8

        impure recursive module subroutine from_binary_6di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di64
        impure recursive module subroutine from_binary_6di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di32
        impure recursive module subroutine from_binary_6di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di16
        impure recursive module subroutine from_binary_6di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_6di8

        impure recursive module subroutine from_binary_7di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di64
        impure recursive module subroutine from_binary_7di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di32
        impure recursive module subroutine from_binary_7di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di16
        impure recursive module subroutine from_binary_7di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_7di8

        impure recursive module subroutine from_binary_8di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di64
        impure recursive module subroutine from_binary_8di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di32
        impure recursive module subroutine from_binary_8di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di16
        impure recursive module subroutine from_binary_8di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_8di8

        impure recursive module subroutine from_binary_9di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di64
        impure recursive module subroutine from_binary_9di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di32
        impure recursive module subroutine from_binary_9di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di16
        impure recursive module subroutine from_binary_9di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_9di8

        impure recursive module subroutine from_binary_10di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di64
        impure recursive module subroutine from_binary_10di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di32
        impure recursive module subroutine from_binary_10di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di16
        impure recursive module subroutine from_binary_10di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_10di8

        impure recursive module subroutine from_binary_11di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di64
        impure recursive module subroutine from_binary_11di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di32
        impure recursive module subroutine from_binary_11di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di16
        impure recursive module subroutine from_binary_11di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_11di8

        impure recursive module subroutine from_binary_12di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di64
        impure recursive module subroutine from_binary_12di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di32
        impure recursive module subroutine from_binary_12di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di16
        impure recursive module subroutine from_binary_12di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_12di8

        impure recursive module subroutine from_binary_13di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di64
        impure recursive module subroutine from_binary_13di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di32
        impure recursive module subroutine from_binary_13di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di16
        impure recursive module subroutine from_binary_13di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_13di8

        impure recursive module subroutine from_binary_14di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di64
        impure recursive module subroutine from_binary_14di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di32
        impure recursive module subroutine from_binary_14di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di16
        impure recursive module subroutine from_binary_14di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_14di8

        impure recursive module subroutine from_binary_15di64(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int64), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di64
        impure recursive module subroutine from_binary_15di32(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int32), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di32
        impure recursive module subroutine from_binary_15di16(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int16), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di16
        impure recursive module subroutine from_binary_15di8(file_name, into, data_shape)
            character(len=*), intent(in) :: file_name
            integer(int8), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent(out) :: into
            integer, dimension(:), intent(in) :: data_shape
        end subroutine from_binary_15di8
    end interface

    contains
    pure recursive function ext_of(file_name) result(ext)
        !! Function for parsing a file name for an extension
        character(len=*), intent(in) :: file_name
        character(len=:), allocatable :: ext

        integer :: i, l

        l = len_trim(file_name)

        do i = l, 1, -1
            if ( file_name(i:i) == '.' ) exit
        end do

        if ( i > 0 ) then
            ext = trim(adjustl(file_name(i+1:l)))
        else
            ext = ''
        end if
    end function ext_of

    pure recursive function to_str(x, delim, trimstring) result(x_str)
        !! Function for accumulating vector of strings into a single string with specified delimiter
        character(len=*), dimension(:), intent(in) :: x
        character(len=*), intent(in) :: delim
        logical, intent(in), optional :: trimstring
        character(len=:), allocatable :: x_str

        logical :: trimstring_
        integer :: i

        if ( .not. present(trimstring) ) then
            trimstring_ = .true.
        else
            trimstring_ = trimstring
        end if

        if ( trimstring_ ) then
            x_str = ''
            do i = 1, size(x)-1
                x_str = x_str//trim(adjustl(x(i)))//delim
            end do
            x_str = x_str//trim(adjustl(x(size(x))))
        else
            x_str = ''
            do i = 1, size(x)-1
                x_str = x_str//adjustr(x(i))//delim
            end do
            x_str = x_str//adjustr(x(size(x)))
        end if
    end function to_str

end module io_fortran_lib

submodule (io_fortran_lib) String_procedures
    !! This submodule provides module procedure implementations for the **public interface** `String` and for the
    !! **type-bound procedures** of type `String`.
    contains
    module procedure new_Str_c128
        character(len=:), allocatable :: locale_, fmt_, im_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure new_Str_c128
    module procedure new_Str_c64
        character(len=:), allocatable :: locale_, fmt_, im_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure new_Str_c64
    module procedure new_Str_c32
        character(len=:), allocatable :: locale_, fmt_, im_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_, im=im_)
    end procedure new_Str_c32

    module procedure new_Str_r128
        character(len=:), allocatable :: locale_, fmt_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure new_Str_r128
    module procedure new_Str_r64
        character(len=:), allocatable :: locale_, fmt_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure new_Str_r64
    module procedure new_Str_r32
        character(len=:), allocatable :: locale_, fmt_
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                locale_ = 'US'
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'e'
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        self%s = str(x, locale=locale_, fmt=fmt_, decimals=decimals_)
    end procedure new_Str_r32

    module procedure new_Str_i64
        character(len=:), allocatable :: fmt_

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'i'
            end if
        end if

        self%s = str(x, fmt=fmt_)
    end procedure new_Str_i64
    module procedure new_Str_i32
        character(len=:), allocatable :: fmt_

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'i'
            end if
        end if

        self%s = str(x, fmt=fmt_)
    end procedure new_Str_i32
    module procedure new_Str_i16
        character(len=:), allocatable :: fmt_

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'i'
            end if
        end if

        self%s = str(x, fmt=fmt_)
    end procedure new_Str_i16
    module procedure new_Str_i8
        character(len=:), allocatable :: fmt_

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                fmt_ = 'i'
            end if
        end if

        self%s = str(x, fmt=fmt_)
    end procedure new_Str_i8

    module procedure new_Str_char
        self%s = chars
    end procedure new_Str_char

    module procedure empty
        self%s = ''
    end procedure empty

    module procedure length
        if ( .not. allocated(self%s) ) then
            self_len = -1
        else
            self_len = len(self%s)
        end if
    end procedure length

    module procedure push
        if ( .not. allocated(self%s) ) then
            self%s = chars
        else
            self%s = self%s//chars
        end if
    end procedure push

    module procedure print_String
        if ( .not. allocated(self%s) ) then
            write(*,'(a)') ''
        else
            write(*,'(a)') self%s
        end if
    end procedure print_String
end submodule String_procedures

submodule (io_fortran_lib) array_printing
    !! This submodule provides module procedure implementations for the **public interface** `aprint`.
    contains
    module procedure aprint_1dc128
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1)) )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc128
    module procedure aprint_1dc64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1)) )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc64
    module procedure aprint_1dc32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1)) )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_1dc32

    module procedure aprint_2dc128
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)) )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc128
    module procedure aprint_2dc64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)) )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc64
    module procedure aprint_2dc32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, im_, xre_max_str, xre_min_str, xim_max_str, xim_min_str
        integer :: i, j, decimals_, l

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = 'j'
        else
            im_ = trim(adjustl(im))
        end if

        if ( len(im_) > 0 ) then
            l = len(im_)
        else
            l = 3
        end if

        xre_max_str = str(maxval(x%re), fmt=fmt_, decimals=decimals_)
        xre_min_str = str(minval(x%re), fmt=fmt_, decimals=decimals_)
        xim_max_str = str(maxval(x%im), fmt=fmt_, decimals=decimals_)
        xim_min_str = str(minval(x%im), fmt=fmt_, decimals=decimals_)

        if ( len(xre_max_str) > len(xre_min_str) ) then
            l = l + len(xre_max_str)
        else
            l = l + len(xre_min_str)
        end if

        if ( len(xim_max_str) > len(xim_min_str) ) then
            l = l + len(xim_max_str)
        else
            l = l + len(xim_min_str)
        end if

        allocate( character(len=l) :: x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)) )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_, im=im_)
        end do

        call aprint(x_str)
    end procedure aprint_2dc32

    module procedure aprint_1dr128
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr128
    module procedure aprint_1dr64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr64
    module procedure aprint_1dr32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_1dr32

    module procedure aprint_2dr128
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr128
    module procedure aprint_2dr64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr64
    module procedure aprint_2dr32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, x_abs_min_str, source
        integer :: i, j, decimals_

        if ( .not. present(fmt) ) then
            fmt_ = 'f'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing real array. Aborting...'
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 2
        else
            decimals_ = decimals
        end if

        x_max_str = str(maxval(x), fmt=fmt_, decimals=decimals_)
        x_min_str = str(minval(x), fmt=fmt_, decimals=decimals_)
        x_abs_min_str = str(minval(abs(x)), fmt=fmt_, decimals=decimals_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        if ( len(x_abs_min_str) > len(source) ) source = x_abs_min_str

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_, decimals=decimals_)
        end do

        call aprint(x_str)
    end procedure aprint_2dr32

    module procedure aprint_1di64
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di64
    module procedure aprint_1di32
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di32
    module procedure aprint_1di16
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di16
    module procedure aprint_1di8
        character(len=:), allocatable, dimension(:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source
        integer :: i

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1)), source=source )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i) = str(x(i), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_1di8

    module procedure aprint_2di64
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di64
    module procedure aprint_2di32
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di32
    module procedure aprint_2di16
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di16
    module procedure aprint_2di8
        character(len=:), allocatable, dimension(:,:) :: x_str
        character(len=:), allocatable :: fmt_, x_max_str, x_min_str, source, str_tmp
        integer :: i, j

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                write(*,'(a)') nl//'WARNING: Unknown format "'//fmt//'" for printing integer array. Aborting...'
                return
            end if
        end if

        x_max_str = str(maxval(x), fmt=fmt_)
        x_min_str = str(minval(x), fmt=fmt_)

        if ( len(x_max_str) > len(x_min_str) ) then
            source = x_max_str
        else
            source = x_min_str
        end if

        allocate( x_str(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)), source=source )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            x_str(i,j) = str(x(i,j), fmt=fmt_)
        end do

        call aprint(x_str)
    end procedure aprint_2di8

    module procedure aprint_1dchar
        integer :: i

        write(unit=*, fmt='(a)') nl//'    '//adjustr(x(lbound(x, dim=1)))//' '

        if ( size(x) == 1 ) return

        if ( size(x) > 2 ) then
            do i = lbound(x, dim=1) + 1, ubound(x, dim=1) - 1
                write(unit=*, fmt='(a)') '    '//adjustr(x(i))//' '
            end do
        end if
        
        write(unit=*, fmt='(a)') '    '//adjustr(x(ubound(x, dim=1)))//' '//nl
    end procedure aprint_1dchar
    
    module procedure aprint_2dchar
        integer :: i

        write(unit=*, fmt='(a)') nl//'    '//to_str(x(lbound(x, dim=1),:), delim=' ', trimstring=.false.)//' '

        if ( size(x, dim=1) == 1 ) return

        if ( size(x, dim=1) > 2 ) then
            do i = lbound(x, dim=1) + 1, ubound(x, dim=1) - 1
                write(unit=*, fmt='(a)') '    '//to_str(x(i,:), delim=' ', trimstring=.false.)//' '
            end do
        end if
        
        write(unit=*, fmt='(a)') '    '//to_str(x(ubound(x, dim=1),:), delim=' ', trimstring=.false.)//' '//nl
    end procedure aprint_2dchar

    module procedure aprint_1dString
        character(len=:), allocatable, dimension(:) :: char_arr
        integer, allocatable, dimension(:) :: lengths
        integer :: i, max_length

        lengths = x%len()
        max_length = maxval(lengths)

        allocate( character(len=max_length) :: char_arr(lbound(x, dim=1):ubound(x, dim=1)) )

        do concurrent (i = lbound(x, dim=1):ubound(x, dim=1))
            if ( lengths(i) < 0 ) then
                char_arr(i) = ''
            else
                char_arr(i) = x(i)%s
            end if
        end do

        call aprint(char_arr)
    end procedure aprint_1dString

    module procedure aprint_2dString
        character(len=:), allocatable, dimension(:,:) :: char_arr
        integer, allocatable, dimension(:,:) :: lengths
        integer :: i, j, max_length

        lengths = x%len()
        max_length = maxval(lengths)

        allocate( character(len=max_length) :: &
                  char_arr(lbound(x, dim=1):ubound(x, dim=1), lbound(x, dim=2):ubound(x, dim=2)) )

        do concurrent (j = lbound(x, dim=2):ubound(x, dim=2), i = lbound(x, dim=1):ubound(x, dim=1))
            if ( lengths(i,j) < 0 ) then
                char_arr(i,j) = ''
            else
                char_arr(i,j) = x(i,j)%s
            end if
        end do

        call aprint(char_arr)
    end procedure aprint_2dString
end submodule array_printing

submodule (io_fortran_lib) internal_io
    !! This submodule provides module procedure implementations for the **public interface** `str`.
    contains
    module procedure str_c128
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c128
    module procedure str_c64
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c64
    module procedure str_c32
        character(len=:), allocatable :: locale_, fmt_, im_, sep
        integer :: decimals_

        if ( .not. present(locale) ) then
            locale_ = 'US'
        else
            if ( any(locales == locale) ) then
                locale_ = locale
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(decimals) ) then
            decimals_ = 150
        else
            decimals_ = decimals
        end if

        if ( .not. present(im) ) then
            im_ = ''
        else
            im_ = trim(adjustl(im))
        end if

        if ( im_ == '' ) then
            if ( locale_ == 'US' ) then
                sep = ','
            else
                sep = ';'
            end if
            x_str = '('//str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//sep// &
                         str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//')'
        else
            if ( fmt_ == 'z' ) then
                x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                        str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
            else
                if ( x%im < 0 ) then
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'-'// &
                            str(abs(x%im), locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                else
                    x_str = str(x%re, locale=locale_, fmt=fmt_, decimals=decimals_)//'+'// &
                            str(x%im, locale=locale_, fmt=fmt_, decimals=decimals_)//im_
                end if
            end if
        end if
    end procedure str_c32

    module procedure str_r128
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'e' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e4)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            if ( abs(x) /= 0.0_real128 ) then
                e = int(log10(abs(x)))
            else
                e = 0
            end if

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=70) :: str_tmp )

            write(unit=str_tmp, fmt='(z70)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r128
    module procedure str_r64
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'e' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e3)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            if ( abs(x) /= 0.0_real64 ) then
                e = int(log10(abs(x)))
            else
                e = 0
            end if

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=40) :: str_tmp )

            write(unit=str_tmp, fmt='(z40)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r64
    module procedure str_r32
        character(len=:), allocatable :: decimal, fmt_, str_tmp
        integer :: i, e, max_decimals, decimals_, l, extra

        if ( .not. present(locale) ) then
            decimal = 'POINT'
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
            else
                x_str = ''
                return
            end if
        end if

        if ( .not. present(fmt) ) then
            fmt_ = 'e'
        else
            if ( any(real_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'e' ) then
            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( .not. present(decimals) ) then
                    decimals_ = max_precision - 1
                else
                    if ( decimals < 0 ) then
                        decimals_ = 0
                    else if ( decimals > (max_precision - 1) ) then
                        decimals_ = max_precision - 1
                    else
                        decimals_ = decimals
                    end if
                end if
            end associate

            l = decimals_ + 15

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(es'//str(l)//'.'//str(decimals_)//'e2)', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))
        else if ( fmt_ == 'f' ) then
            if ( abs(x) /= 0.0_real32 ) then
                e = int(log10(abs(x)))
            else
                e = 0
            end if

            associate ( max_precision => ceiling( 1.0 + log10(real(radix(x)))*digits(x) ) )
                if ( e == 0 ) then
                    if ( floor(x) == 0 ) then
                        max_decimals = max_precision
                    else
                        max_decimals = max_precision - 1
                        e = 1 + e
                    end if
                else if ( e > 0 ) then
                    max_decimals = max_precision - (1 + e)
                    e = 1 + e
                else
                    max_decimals = max_precision - e
                end if

                extra = e - max_precision
            end associate

            if ( max_decimals < 0 ) max_decimals = 0

            if ( .not. present(decimals) ) then
                decimals_ = max_decimals
            else
                if ( decimals < 0 ) then
                    decimals_ = 0
                else if ( decimals > max_decimals ) then
                    decimals_ = max_decimals
                else
                    decimals_ = decimals
                end if
            end if

            if ( e > 0 ) then
                l = decimals_ + e + 10
            else
                l = decimals_ + 10
            end if

            allocate( character(len=l) :: str_tmp )

            write(unit=str_tmp, fmt='(f'//str(l)//'.'//str(decimals_)//')', decimal=decimal) x
            x_str = trim(adjustl(str_tmp))

            if ( extra > 0 ) then
                do i = len(x_str)-1, 1, -1
                    x_str(i:i) = '0'
                    extra = extra - 1
                    if ( extra == 0 ) exit
                end do
            end if
        else if ( fmt_ == 'z' ) then
            allocate( character(len=25) :: str_tmp )

            write(unit=str_tmp, fmt='(z25)') x
            x_str = trim(adjustl(str_tmp))
        end if
    end procedure str_r32

    module procedure str_i64
        character(len=:), allocatable :: fmt_
        character(len=40) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i40)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z40)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i64
    module procedure str_i32
        character(len=:), allocatable :: fmt_
        character(len=25) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i25)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z25)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i32
    module procedure str_i16
        character(len=:), allocatable :: fmt_
        character(len=15) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i15)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z15)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i16
    module procedure str_i8
        character(len=:), allocatable :: fmt_
        character(len=10) :: str_tmp

        if ( .not. present(fmt) ) then
            fmt_ = 'i'
        else
            if ( any(int_fmts == fmt) ) then
                fmt_ = fmt
            else
                x_str = ''
                return
            end if
        end if

        if ( fmt_ == 'i' ) then
            write(unit=str_tmp, fmt='(i10)') x
        else if ( fmt_ == 'z' ) then
            write(unit=str_tmp, fmt='(z10)') x
        end if
        
        x_str = trim(adjustl(str_tmp))
    end procedure str_i8
end submodule internal_io

submodule (io_fortran_lib) file_io
    !! This submodule provides module procedure implementations for the **public interfaces** `to_file` and
    !! `from_file`.
    contains
    ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure to_file_1dc128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc128
    module procedure to_file_1dc64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc64
    module procedure to_file_1dc32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dc32

    module procedure to_file_2dc128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc128
    module procedure to_file_2dc64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc64
    module procedure to_file_2dc32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_, im_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = trim(adjustl(im))
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_, im=im_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            if ( present(im) )       write(*,'(a)') nl//'WARNING: im not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dc32

    module procedure to_file_3dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc128
    module procedure to_file_3dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc64
    module procedure to_file_3dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dc32

    module procedure to_file_4dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc128
    module procedure to_file_4dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc64
    module procedure to_file_4dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dc32

    module procedure to_file_5dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc128
    module procedure to_file_5dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc64
    module procedure to_file_5dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dc32

    module procedure to_file_6dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc128
    module procedure to_file_6dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc64
    module procedure to_file_6dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dc32

    module procedure to_file_7dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc128
    module procedure to_file_7dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc64
    module procedure to_file_7dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dc32

    module procedure to_file_8dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc128
    module procedure to_file_8dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc64
    module procedure to_file_8dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dc32

    module procedure to_file_9dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc128
    module procedure to_file_9dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc64
    module procedure to_file_9dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dc32

    module procedure to_file_10dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc128
    module procedure to_file_10dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc64
    module procedure to_file_10dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dc32

    module procedure to_file_11dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc128
    module procedure to_file_11dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc64
    module procedure to_file_11dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dc32

    module procedure to_file_12dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc128
    module procedure to_file_12dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc64
    module procedure to_file_12dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dc32

    module procedure to_file_13dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc128
    module procedure to_file_13dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc64
    module procedure to_file_13dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dc32

    module procedure to_file_14dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc128
    module procedure to_file_14dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc64
    module procedure to_file_14dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dc32

    module procedure to_file_15dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc128
    module procedure to_file_15dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc64
    module procedure to_file_15dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dc32

    module procedure to_file_1dr128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr128
    module procedure to_file_1dr64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr64
    module procedure to_file_1dr32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_, hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    if ( locale_ == 'US' ) then
                        delim_ = ','
                    else
                        delim_ = ';'
                    end if
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, dim=dim_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )      write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'
            
            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1dr32

    module procedure to_file_2dr128
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr128
    module procedure to_file_2dr64
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr64
    module procedure to_file_2dr32
        character(len=:), allocatable, dimension(:) :: header_
        character(len=:), allocatable :: ext, locale_, delim_, fmt_
        integer :: decimals_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    locale_ = 'US'
                    write(*,'(a)') nl//'WARNING: Invalid locale "'//locale//'" for file "'//file_name//'". '// &
                                       'Defaulting to US format.'// &
                                   nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(delim) ) then
                if ( locale_ == 'US' ) then
                    delim_ = ','
                else
                    delim_ = ';'
                end if
            else
                delim_ = delim
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'e'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to exponential format.'// &
                                   nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(decimals) ) then
                decimals_ = 150
            else
                decimals_ = decimals
            end if
            
            call to_text( x=x, file_name=file_name, header=header_, locale=locale_, delim=delim_, &
                          fmt=fmt_, decimals=decimals_ )
        else if ( any(binary_ext == ext) ) then
            if ( present(header) )   write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(locale) )   write(*,'(a)') nl//'WARNING: locale not supported for file type "'//ext//'".'
            if ( present(delim) )    write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )      write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'
            if ( present(decimals) ) write(*,'(a)') nl//'WARNING: decimals not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2dr32

    module procedure to_file_3dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr128
    module procedure to_file_3dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr64
    module procedure to_file_3dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3dr32

    module procedure to_file_4dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr128
    module procedure to_file_4dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr64
    module procedure to_file_4dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4dr32

    module procedure to_file_5dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr128
    module procedure to_file_5dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr64
    module procedure to_file_5dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5dr32

    module procedure to_file_6dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr128
    module procedure to_file_6dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr64
    module procedure to_file_6dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6dr32

    module procedure to_file_7dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr128
    module procedure to_file_7dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr64
    module procedure to_file_7dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7dr32

    module procedure to_file_8dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr128
    module procedure to_file_8dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr64
    module procedure to_file_8dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8dr32

    module procedure to_file_9dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr128
    module procedure to_file_9dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr64
    module procedure to_file_9dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9dr32

    module procedure to_file_10dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr128
    module procedure to_file_10dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr64
    module procedure to_file_10dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10dr32

    module procedure to_file_11dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr128
    module procedure to_file_11dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr64
    module procedure to_file_11dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11dr32

    module procedure to_file_12dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr128
    module procedure to_file_12dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr64
    module procedure to_file_12dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12dr32

    module procedure to_file_13dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr128
    module procedure to_file_13dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr64
    module procedure to_file_13dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13dr32

    module procedure to_file_14dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr128
    module procedure to_file_14dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr64
    module procedure to_file_14dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14dr32

    module procedure to_file_15dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr128
    module procedure to_file_15dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr64
    module procedure to_file_15dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15dr32

    module procedure to_file_1di64
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di64
    module procedure to_file_1di32
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di32
    module procedure to_file_1di16
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di16
    module procedure to_file_1di8
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_
        integer :: hstat, dim_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
                hstat = 0
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x)) ) then
                    header_ = ['']
                    hstat = -1
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x))//').'
                else
                    header_ = header
                    if ( size(header) == 1 ) then
                        hstat = 1
                    else
                        hstat = 2
                    end if
                end if
            end if

            if ( .not. present(dim) ) then
                if ( hstat == 2 ) then
                    dim_ = 2
                else
                    dim_ = 1
                end if
            else
                if ( hstat == 2 ) then
                    dim_ = 2
                    if ( dim /= 2 ) then
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (2).'
                    end if
                else
                    if ( dim == 1 ) then
                        dim_ = 1
                    else if ( dim == 2 ) then
                        dim_ = 2
                    else
                        dim_ = 1
                        write(*,'(a)') nl//'WARNING: Invalid dim ('//str(dim)//') in write to file "'// &
                                       file_name//'" for given header... defaulting to (1).'
                    end if
                end if
            end if

            if ( .not. present(delim) ) then
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = ','
                end if
            else
                if ( dim_ == 1 ) then
                    delim_ = ''
                else
                    delim_ = delim
                end if
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, dim=dim_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(dim) )    write(*,'(a)') nl//'WARNING: dim not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_1di8

    module procedure to_file_2di64
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di64
    module procedure to_file_2di32
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di32
    module procedure to_file_2di16
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di16
    module procedure to_file_2di8
        character(len=:), allocatable :: ext, delim_, fmt_
        character(len=:), allocatable, dimension(:) :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = ['']
            else
                if ( (size(header) /= 1) .and. (size(header) /= size(x, dim=2)) ) then
                    header_ = ['']
                    write(*,'(a)') nl//'WARNING: Invalid header for file "'//file_name//'".'// &
                                   nl//'Header for this data must have size (1) or '// & 
                                       '('//str(size(x, dim=2))//').'
                else
                    header_ = header
                end if
            end if

            if ( .not. present(delim) ) then
                delim_ = ','
            else
                delim_ = delim
            end if
            
            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    fmt_ = 'i'
                    write(*,'(a)') nl//'WARNING: Invalid format "'//fmt//'" for file "'//file_name//'". '// &
                                       'Defaulting to integer format.'// &
                                   nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call to_text(x=x, file_name=file_name, header=header_, delim=delim_, fmt=fmt_)
        else if ( any(binary_ext == ext) ) then
            if ( present(header) ) write(*,'(a)') nl//'WARNING: header not supported for file type "'//ext//'".'
            if ( present(delim) )  write(*,'(a)') nl//'WARNING: delim not supported for file type "'//ext//'".'
            if ( present(fmt) )    write(*,'(a)') nl//'WARNING: fmt not supported for file type "'//ext//'".'

            call to_binary(x=x, file_name=file_name)
        else
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                                to_str(binary_ext, delim=' ')
        end if
    end procedure to_file_2di8

    module procedure to_file_3di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di64
    module procedure to_file_3di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di32
    module procedure to_file_3di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di16
    module procedure to_file_3di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_3di8

    module procedure to_file_4di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di64
    module procedure to_file_4di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di32
    module procedure to_file_4di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di16
    module procedure to_file_4di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_4di8

    module procedure to_file_5di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di64
    module procedure to_file_5di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di32
    module procedure to_file_5di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di16
    module procedure to_file_5di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_5di8

    module procedure to_file_6di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di64
    module procedure to_file_6di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di32
    module procedure to_file_6di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di16
    module procedure to_file_6di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_6di8

    module procedure to_file_7di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di64
    module procedure to_file_7di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di32
    module procedure to_file_7di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di16
    module procedure to_file_7di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_7di8

    module procedure to_file_8di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di64
    module procedure to_file_8di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di32
    module procedure to_file_8di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di16
    module procedure to_file_8di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_8di8

    module procedure to_file_9di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di64
    module procedure to_file_9di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di32
    module procedure to_file_9di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di16
    module procedure to_file_9di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_9di8

    module procedure to_file_10di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di64
    module procedure to_file_10di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di32
    module procedure to_file_10di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di16
    module procedure to_file_10di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_10di8

    module procedure to_file_11di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di64
    module procedure to_file_11di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di32
    module procedure to_file_11di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di16
    module procedure to_file_11di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_11di8

    module procedure to_file_12di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di64
    module procedure to_file_12di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di32
    module procedure to_file_12di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di16
    module procedure to_file_12di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_12di8

    module procedure to_file_13di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di64
    module procedure to_file_13di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di32
    module procedure to_file_13di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di16
    module procedure to_file_13di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_13di8

    module procedure to_file_14di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di64
    module procedure to_file_14di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di32
    module procedure to_file_14di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di16
    module procedure to_file_14di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_14di8

    module procedure to_file_15di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di64
    module procedure to_file_15di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di32
    module procedure to_file_15di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di16
    module procedure to_file_15di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            call to_binary(x=x, file_name=file_name)
        else
            if ( any(text_ext == ext) ) then
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'". Cannot write array of '// &
                                    'dimension ('//str(rank(x))//') to text.'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            else
                write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                    'due to unsupported file extension "'//ext//'".'// &
                                nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure to_file_15di8

    ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_textfile_1dc128
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc128
    module procedure from_binaryfile_1dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc128
    module procedure from_textfile_1dc64
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc64
    module procedure from_binaryfile_1dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc64
    module procedure from_textfile_1dc32
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dc32
    module procedure from_binaryfile_1dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dc32

    module procedure from_textfile_2dc128
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc128
    module procedure from_binaryfile_2dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc128
    module procedure from_textfile_2dc64
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc64
    module procedure from_binaryfile_2dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc64
    module procedure from_textfile_2dc32
        character(len=:), allocatable :: ext, locale_, fmt_, im_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into complex array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if

            if ( .not. present(im) ) then
                im_ = ''
            else
                im_ = im
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_, im=im_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dc32
    module procedure from_binaryfile_2dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dc32

    module procedure from_file_3dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc128
    module procedure from_file_3dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc64
    module procedure from_file_3dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dc32

    module procedure from_file_4dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc128
    module procedure from_file_4dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc64
    module procedure from_file_4dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dc32

    module procedure from_file_5dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc128
    module procedure from_file_5dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc64
    module procedure from_file_5dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dc32

    module procedure from_file_6dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc128
    module procedure from_file_6dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc64
    module procedure from_file_6dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dc32

    module procedure from_file_7dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc128
    module procedure from_file_7dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc64
    module procedure from_file_7dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dc32

    module procedure from_file_8dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc128
    module procedure from_file_8dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc64
    module procedure from_file_8dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dc32

    module procedure from_file_9dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc128
    module procedure from_file_9dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc64
    module procedure from_file_9dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dc32

    module procedure from_file_10dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc128
    module procedure from_file_10dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc64
    module procedure from_file_10dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dc32

    module procedure from_file_11dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc128
    module procedure from_file_11dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc64
    module procedure from_file_11dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dc32

    module procedure from_file_12dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc128
    module procedure from_file_12dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc64
    module procedure from_file_12dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dc32

    module procedure from_file_13dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc128
    module procedure from_file_13dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc64
    module procedure from_file_13dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dc32

    module procedure from_file_14dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc128
    module procedure from_file_14dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc64
    module procedure from_file_14dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dc32

    module procedure from_file_15dc128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc128
    module procedure from_file_15dc64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc64
    module procedure from_file_15dc32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dc32

    module procedure from_textfile_1dr128
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr128
    module procedure from_binaryfile_1dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr128
    module procedure from_textfile_1dr64
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr64
    module procedure from_binaryfile_1dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr64
    module procedure from_textfile_1dr32
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1dr32
    module procedure from_binaryfile_1dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1dr32

    module procedure from_textfile_2dr128
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr128
    module procedure from_binaryfile_2dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr128
    module procedure from_textfile_2dr64
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr64
    module procedure from_binaryfile_2dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr64
    module procedure from_textfile_2dr32
        character(len=:), allocatable :: ext, locale_, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(locale) ) then
                locale_ = 'US'
            else
                if ( any(locales == locale) ) then
                    locale_ = locale
                else
                    error stop nl//'FATAL: Invalid locale "'//locale//'" for read of file "'//file_name//'".'// &
                               nl//'Locale must be one of: '//to_str(locales, delim=' ')
                end if
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'e'
            else
                if ( any(real_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into real array.'// &
                               nl//'Format must be one of: '//to_str(real_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, locale=locale_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2dr32
    module procedure from_binaryfile_2dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2dr32

    module procedure from_file_3dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr128
    module procedure from_file_3dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr64
    module procedure from_file_3dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3dr32

    module procedure from_file_4dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr128
    module procedure from_file_4dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr64
    module procedure from_file_4dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4dr32

    module procedure from_file_5dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr128
    module procedure from_file_5dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr64
    module procedure from_file_5dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5dr32

    module procedure from_file_6dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr128
    module procedure from_file_6dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr64
    module procedure from_file_6dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6dr32

    module procedure from_file_7dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr128
    module procedure from_file_7dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr64
    module procedure from_file_7dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7dr32

    module procedure from_file_8dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr128
    module procedure from_file_8dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr64
    module procedure from_file_8dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8dr32

    module procedure from_file_9dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr128
    module procedure from_file_9dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr64
    module procedure from_file_9dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9dr32

    module procedure from_file_10dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr128
    module procedure from_file_10dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr64
    module procedure from_file_10dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10dr32

    module procedure from_file_11dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr128
    module procedure from_file_11dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr64
    module procedure from_file_11dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11dr32

    module procedure from_file_12dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr128
    module procedure from_file_12dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr64
    module procedure from_file_12dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12dr32

    module procedure from_file_13dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr128
    module procedure from_file_13dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr64
    module procedure from_file_13dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13dr32

    module procedure from_file_14dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr128
    module procedure from_file_14dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr64
    module procedure from_file_14dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14dr32

    module procedure from_file_15dr128
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr128
    module procedure from_file_15dr64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr64
    module procedure from_file_15dr32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15dr32

    module procedure from_textfile_1di64
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di64
    module procedure from_binaryfile_1di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di64
    module procedure from_textfile_1di32
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di32
    module procedure from_binaryfile_1di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di32
    module procedure from_textfile_1di16
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di16
    module procedure from_binaryfile_1di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di16
    module procedure from_textfile_1di8
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_1di8
    module procedure from_binaryfile_1di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_1di8

    module procedure from_textfile_2di64
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di64
    module procedure from_binaryfile_2di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di64
    module procedure from_textfile_2di32
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di32
    module procedure from_binaryfile_2di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di32
    module procedure from_textfile_2di16
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di16
    module procedure from_binaryfile_2di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di16
    module procedure from_textfile_2di8
        character(len=:), allocatable :: ext, fmt_
        logical :: header_

        ext = ext_of(file_name)

        if ( any(text_ext == ext) ) then
            if ( .not. present(header) ) then
                header_ = .false.
            else
                header_ = header
            end if

            if ( .not. present(fmt) ) then
                fmt_ = 'i'
            else
                if ( any(int_fmts == fmt) ) then
                    fmt_ = fmt
                else
                    error stop nl//'FATAL: Invalid format "'//fmt//'" for read of file "'//file_name//'" '// &
                                   'into integer array.'// &
                               nl//'Format must be one of: '//to_str(int_fmts, delim=' ')
                end if
            end if
            
            call from_text(file_name=file_name, into=into, header=header_, fmt=fmt_)
        else
            if ( any(binary_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must be specified '// &
                               'for binary data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_textfile_2di8
    module procedure from_binaryfile_2di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'", data_shape must not be specified '// &
                               'for textual data.'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(text_ext, delim=' ')//' '// &
                           to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_binaryfile_2di8

    module procedure from_file_3di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di64
    module procedure from_file_3di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di32
    module procedure from_file_3di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di16
    module procedure from_file_3di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_3di8

    module procedure from_file_4di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di64
    module procedure from_file_4di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di32
    module procedure from_file_4di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di16
    module procedure from_file_4di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_4di8

    module procedure from_file_5di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di64
    module procedure from_file_5di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di32
    module procedure from_file_5di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di16
    module procedure from_file_5di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_5di8

    module procedure from_file_6di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di64
    module procedure from_file_6di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di32
    module procedure from_file_6di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di16
    module procedure from_file_6di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_6di8

    module procedure from_file_7di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di64
    module procedure from_file_7di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di32
    module procedure from_file_7di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di16
    module procedure from_file_7di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_7di8

    module procedure from_file_8di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di64
    module procedure from_file_8di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di32
    module procedure from_file_8di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di16
    module procedure from_file_8di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_8di8

    module procedure from_file_9di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di64
    module procedure from_file_9di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di32
    module procedure from_file_9di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di16
    module procedure from_file_9di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_9di8

    module procedure from_file_10di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di64
    module procedure from_file_10di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di32
    module procedure from_file_10di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di16
    module procedure from_file_10di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_10di8

    module procedure from_file_11di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di64
    module procedure from_file_11di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di32
    module procedure from_file_11di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di16
    module procedure from_file_11di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_11di8

    module procedure from_file_12di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di64
    module procedure from_file_12di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di32
    module procedure from_file_12di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di16
    module procedure from_file_12di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_12di8

    module procedure from_file_13di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di64
    module procedure from_file_13di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di32
    module procedure from_file_13di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di16
    module procedure from_file_13di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_13di8

    module procedure from_file_14di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di64
    module procedure from_file_14di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di32
    module procedure from_file_14di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di16
    module procedure from_file_14di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_14di8

    module procedure from_file_15di64
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di64
    module procedure from_file_15di32
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di32
    module procedure from_file_15di16
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di16
    module procedure from_file_15di8
        character(len=:), allocatable :: ext

        ext = ext_of(file_name)

        if ( any(binary_ext == ext) ) then
            if ( size(data_shape) /= rank(into) ) then
                error stop nl//'FATAL: Shape mismatch in read of file "'//file_name//'".'// &
                           nl//'Output array has dimension ('//str(rank(into))//') while data_shape has size (' &
                             //str(size(data_shape))//'). These must match.'
            end if

            call from_binary(file_name=file_name, into=into, data_shape=data_shape)
        else
            if ( any(text_ext == ext) ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". Textual data cannot be read into '// &
                               'arrays of dimension greater than (2).'
            else
                error stop nl//'FATAL: Unsupported file extension "'//ext//'" for file "'//file_name//'".'// &
                           nl//'Supported file extensions: '//to_str(binary_ext, delim=' ')
            end if
        end if
    end procedure from_file_15di8
end submodule file_io

submodule (io_fortran_lib) text_io
    !! This submodule provides module procedure implementations for the **public interface** `echo` and the **private
    !! interfaces** `to_text` and `from_text`.
    contains
    ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure echo_string
        character(len=:), allocatable :: ext
        logical :: exists, append_
        integer :: file_unit

        ext = ext_of(file_name)

        if ( .not. any(text_ext == ext) ) then
            write(*,'(a)')  nl//'WARNING: Skipping write to "'//file_name//'" '// &
                                'due to unsupported file extension "'//ext//'".'// &
                            nl//'Supported file extensions: '//to_str(text_ext, delim=' ')
            return
        end if

        if ( .not. present(append) ) then
            append_ = .true.
        else
            append_ = append
        end if

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            if ( .not. append_ ) then
                open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                      action='write', access='stream', position='rewind' )
            else
                open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                      action='write', access='stream', position='append' )
            end if
        end if

        write( unit=file_unit ) string//nl

        close(file_unit)
    end procedure echo_string

    module procedure to_text_1dc128
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dc128
    module procedure to_text_1dc64
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dc64
    module procedure to_text_1dc32
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dc32

    module procedure to_text_2dc128
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dc128
    module procedure to_text_2dc64
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dc64
    module procedure to_text_2dc32
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals, im=im)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dc32

    module procedure to_text_1dr128
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dr128
    module procedure to_text_1dr64
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dr64
    module procedure to_text_1dr32
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//delim
                else
                    string_arr(i)%s = str(x(i), locale=locale, fmt=fmt, decimals=decimals)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1dr32

    module procedure to_text_2dr128
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dr128
    module procedure to_text_2dr64
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dr64
    module procedure to_text_2dr32
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//delim
            else
                string_arr(i,j)%s = str(x(i,j), locale=locale, fmt=fmt, decimals=decimals)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2dr32

    module procedure to_text_1di64
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), fmt=fmt)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), fmt=fmt)//delim
                else
                    string_arr(i)%s = str(x(i), fmt=fmt)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1di64
    module procedure to_text_1di32
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), fmt=fmt)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), fmt=fmt)//delim
                else
                    string_arr(i)%s = str(x(i), fmt=fmt)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1di32
    module procedure to_text_1di16
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), fmt=fmt)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), fmt=fmt)//delim
                else
                    string_arr(i)%s = str(x(i), fmt=fmt)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1di16
    module procedure to_text_1di8
        type(String), allocatable, dimension(:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            if ( dim == 1 ) then
                write( unit=file_unit ) trim(adjustl(header(1)))//nl
            else if ( dim == 2 ) then
                label = trim(adjustl(header(1)))
                do i = lbound(x, dim=1), ubound(x, dim=1) - 1
                    write( unit=file_unit ) label//str(i)//delim
                end do
                write( unit=file_unit ) label//str(ubound(x, dim=1))//nl
            end if
        else if ( size(header) == size(x) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x)) )

        if ( dim == 1 ) then
            do concurrent (i = 1:size(x))
                string_arr(i)%s = str(x(i), fmt=fmt)//nl
            end do
        else if ( dim == 2 ) then
            do concurrent (i = 1:size(x))
                if ( i /= size(x) ) then
                    string_arr(i)%s = str(x(i), fmt=fmt)//delim
                else
                    string_arr(i)%s = str(x(i), fmt=fmt)//nl
                end if
            end do
        end if

        do i = 1, size(x)
            write( unit=file_unit ) string_arr(i)%s
        end do

        close(file_unit)
    end procedure to_text_1di8

    module procedure to_text_2di64
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//delim
            else
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2di64
    module procedure to_text_2di32
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//delim
            else
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2di32
    module procedure to_text_2di16
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//delim
            else
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2di16
    module procedure to_text_2di8
        type(String), allocatable, dimension(:,:) :: string_arr
        character(len=:), allocatable :: label
        integer :: file_unit, i, j
        logical :: exists

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream', position='rewind' )
        end if

        if ( all(header == '') ) then
            continue
        else if ( size(header) == 1 ) then
            label = trim(adjustl(header(1)))
            do j = lbound(x, dim=2), ubound(x, dim=2) - 1
                write( unit=file_unit ) label//str(j)//delim
            end do
            write( unit=file_unit ) label//str(ubound(x, dim=2))//nl
        else if ( size(header) == size(x, dim=2) ) then
            write( unit=file_unit ) to_str(header, delim=delim)//nl
        end if

        allocate( string_arr(size(x, dim=1), size(x, dim=2)) )

        do concurrent (j = 1:size(x, dim=2), i = 1:size(x, dim=1))
            if ( j /= size(x, dim=2) ) then
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//delim
            else
                string_arr(i,j)%s = str(x(i,j), fmt=fmt)//nl
            end if
        end do

        do i = 1, size(x, dim=1)
            do j = 1, size(x, dim=2)
                write( unit=file_unit ) string_arr(i,j)%s
            end do
        end do

        close(file_unit)
    end procedure to_text_2di8

    ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_text_1dc128
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real128) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'e' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                    read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc128
    module procedure from_text_1dc64
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real64) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'e' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                    read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc64
    module procedure from_text_1dc32
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, ind, l1, l2, sep_pos

        complex(real32) :: c
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ignore_sep = .false.
        ind = 1
        l1 = 1
        l2 = 1
        i = 1

        read_into: do while ( i <= file_length )
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else if ( current_char == im_chars(1) ) then
                number = file(l1:i-1)
                do j = 2, len(number)
                    if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                        if ( fmt == 'e' ) then
                            if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                sep_pos = j
                                exit
                            end if
                        else
                            sep_pos = j
                            exit
                        end if
                    end if
                end do
                if ( fmt == 'z' ) then
                    read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                    read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                else
                    read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                    read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                end if
                into(ind) = c
                if ( ind /= size(into) ) then
                    ind = ind + 1
                else
                    exit read_into
                end if
                l2 = i
                i = i + size(im_chars)
                cycle read_into
            else
                if ( ignore_sep ) then
                    l2 = i + 1
                    i = i + 1
                    cycle read_into
                end if

                if ( any(non_separating_chars == file(l2:l2)) ) then
                    number = file(l1+1:l2-1)
                    do j = 1, len(number)
                        if ( number(j:j) == sep ) then
                            sep_pos = j
                            exit
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                    end if
                    into(ind) = c
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
            i = i + 1
        end do read_into
    end procedure from_text_1dc32

    module procedure from_text_2dc128
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real128) :: c
        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            ignore_sep = .false.
            column = 1
            l1 = 1
            l2 = 1
            i = 1
            read_into: do while ( i <= len(lines(row)%s) )
                current_char = lines(row)%s(i:i)
                if ( current_char == '(' ) then
                    ignore_sep = .true.
                else if ( current_char == ')' ) then
                    ignore_sep = .false.
                end if

                if ( any(non_separating_chars == current_char) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else if ( current_char == im_chars(1) ) then
                    number = lines(row)%s(l1:i-1)
                    do j = 2, len(number)
                        if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                            if ( fmt == 'e' ) then
                                if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                    sep_pos = j
                                    exit
                                end if
                            else
                                sep_pos = j
                                exit
                            end if
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                    i = i + size(im_chars)
                    cycle read_into
                else
                    if ( ignore_sep ) then
                        l2 = i + 1
                        i = i + 1
                        cycle read_into
                    end if

                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        number = lines(row)%s(l1+1:l2-1)
                        do j = 1, len(number)
                            if ( number(j:j) == sep ) then
                                sep_pos = j
                                exit
                            end if
                        end do
                        if ( fmt == 'z' ) then
                            read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                            read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                        else
                            read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                            read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                        end if
                        into(row, column) = c
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
                i = i + 1
            end do read_into
        end do
    end procedure from_text_2dc128
    module procedure from_text_2dc64
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real64) :: c
        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            ignore_sep = .false.
            column = 1
            l1 = 1
            l2 = 1
            i = 1
            read_into: do while ( i <= len(lines(row)%s) )
                current_char = lines(row)%s(i:i)
                if ( current_char == '(' ) then
                    ignore_sep = .true.
                else if ( current_char == ')' ) then
                    ignore_sep = .false.
                end if

                if ( any(non_separating_chars == current_char) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else if ( current_char == im_chars(1) ) then
                    number = lines(row)%s(l1:i-1)
                    do j = 2, len(number)
                        if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                            if ( fmt == 'e' ) then
                                if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                    sep_pos = j
                                    exit
                                end if
                            else
                                sep_pos = j
                                exit
                            end if
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                    i = i + size(im_chars)
                    cycle read_into
                else
                    if ( ignore_sep ) then
                        l2 = i + 1
                        i = i + 1
                        cycle read_into
                    end if

                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        number = lines(row)%s(l1+1:l2-1)
                        do j = 1, len(number)
                            if ( number(j:j) == sep ) then
                                sep_pos = j
                                exit
                            end if
                        end do
                        if ( fmt == 'z' ) then
                            read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                            read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                        else
                            read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                            read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                        end if
                        into(row, column) = c
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
                i = i + 1
            end do read_into
        end do
    end procedure from_text_2dc64
    module procedure from_text_2dc32
        logical :: exists, ignore_sep
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, j, row, column, l1, l2, sep_pos

        complex(real32) :: c
        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: im_chars, non_separating_chars
        character(len=:), allocatable :: file, decimal, sep, number
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( len(im) > 0 ) then
            allocate( character(len=1) :: im_chars(len(im)) )
            do i = 1, len(im)
                im_chars(i) = im(i:i)
            end do
        else
            im_chars = ['']
        end if

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f', '(', ')', '+']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-', &
                                        '(', ')']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-', &
                                        '(', ')']
            end if
        end if

        if ( locale == 'US' ) then
            sep = ','
        else if ( locale == 'EU' ) then
            sep = ';'
        end if

        ignore_sep = .false.
        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)
            if ( current_char == '(' ) then
                ignore_sep = .true.
            else if ( current_char == ')' ) then
                ignore_sep = .false.
            end if

            if ( any(non_separating_chars == current_char) .or. any(im_chars == current_char) ) then
                prev_char = current_char
            else
                if ( ignore_sep ) then
                    prev_char = current_char
                    cycle
                end if

                if ( any(non_separating_chars == prev_char) .or. any(im_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            ignore_sep = .false.
            column = 1
            l1 = 1
            l2 = 1
            i = 1
            read_into: do while ( i <= len(lines(row)%s) )
                current_char = lines(row)%s(i:i)
                if ( current_char == '(' ) then
                    ignore_sep = .true.
                else if ( current_char == ')' ) then
                    ignore_sep = .false.
                end if

                if ( any(non_separating_chars == current_char) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else if ( current_char == im_chars(1) ) then
                    number = lines(row)%s(l1:i-1)
                    do j = 2, len(number)
                        if ( (number(j:j) == '+') .or. (number(j:j) == '-') ) then
                            if ( fmt == 'e' ) then
                                if ( (number(j-1:j-1) /= 'E') .and. (number(j-1:j-1) /= 'e') ) then
                                    sep_pos = j
                                    exit
                                end if
                            else
                                sep_pos = j
                                exit
                            end if
                        end if
                    end do
                    if ( fmt == 'z' ) then
                        read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                        read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                    else
                        read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                        read(unit=number(sep_pos:), fmt=*, decimal=decimal) c%im
                    end if
                    into(row, column) = c
                    if ( column /= n_columns ) then
                        column = column + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                    i = i + size(im_chars)
                    cycle read_into
                else
                    if ( ignore_sep ) then
                        l2 = i + 1
                        i = i + 1
                        cycle read_into
                    end if

                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        number = lines(row)%s(l1+1:l2-1)
                        do j = 1, len(number)
                            if ( number(j:j) == sep ) then
                                sep_pos = j
                                exit
                            end if
                        end do
                        if ( fmt == 'z' ) then
                            read(unit=number(:sep_pos-1), fmt='(z'//str(len(number(:sep_pos-1)))//')') c%re
                            read(unit=number(sep_pos+1:), fmt='(z'//str(len(number(sep_pos+1:)))//')') c%im
                        else
                            read(unit=number(:sep_pos-1), fmt=*, decimal=decimal) c%re
                            read(unit=number(sep_pos+1:), fmt=*, decimal=decimal) c%im
                        end if
                        into(row, column) = c
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
                i = i + 1
            end do read_into
        end do
    end procedure from_text_2dc32

    module procedure from_text_1dr128
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr128
    module procedure from_text_1dr64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr64
    module procedure from_text_1dr32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*, decimal=decimal) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1dr32

    module procedure from_text_2dr128
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*, decimal=decimal) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2dr128
    module procedure from_text_2dr64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*, decimal=decimal) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2dr64
    module procedure from_text_2dr32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file, decimal
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        else
            if ( locale == 'US' ) then
                decimal = 'POINT'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.', 'e', 'E', '+', '-']
            else if ( locale == 'EU' ) then
                decimal = 'COMMA'
                non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ',', 'e', 'E', '+', '-']
            end if
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*, decimal=decimal) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2dr32

    module procedure from_text_1di64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di64
    module procedure from_text_1di32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di32
    module procedure from_text_1di16
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di16
    module procedure from_text_1di8
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, ind, l1, l2

        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        if ( (n_rows > 1) .and. (n_columns > 1) ) then
            error stop nl//'Error reading file "'//file_name//'". File data cannot fit into one-dimensional array.'
            return
        else if ( n_columns == 1 ) then
            allocate( into(n_rows) )
        else if ( n_rows == 1 ) then
            allocate( into(n_columns) )
        end if
    
        ind = 1
        l1 = 1
        l2 = 1

        read_into: do i = 1, file_length
            if ( any(non_separating_chars == file(i:i)) ) then
                if ( .not. any(non_separating_chars == file(l2:l2)) ) l1 = i
                l2 = i
            else
                if ( any(non_separating_chars == file(l2:l2)) ) then
                    if ( fmt == 'z' ) then
                        read(unit=file(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(ind)
                    else
                        read(unit=file(l1:l2), fmt=*) into(ind)
                    end if
                    if ( ind /= size(into) ) then
                        ind = ind + 1
                    else
                        exit read_into
                    end if
                    l2 = i
                else
                    l2 = i
                end if
            end if
        end do read_into
    end procedure from_text_1di8

    module procedure from_text_2di64
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2di64
    module procedure from_text_2di32
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2di32
    module procedure from_text_2di16
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2di16
    module procedure from_text_2di8
        logical :: exists
        integer :: file_unit, iostat
        integer :: n_rows, n_columns
        integer :: i, row, column, l1, l2

        type(String), allocatable, dimension(:) :: lines
        character(len=:), allocatable, dimension(:) :: non_separating_chars
        character(len=:), allocatable :: file
        character(len=1) :: prev_char, current_char
        integer(int64) :: file_length

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        inquire( file=file_name, size=file_length )

        if ( file_length == 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty.'
            return
        end if

        allocate( character(len=file_length) :: file )
        read(unit=file_unit, iostat=iostat) file
        close(file_unit)

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        if ( header ) then
            do i = 1, file_length
                if ( file(i:i) == nl ) then
                    file = file(i+1:)
                    file_length = len(file)
                    exit
                else if ( i == file_length ) then
                    file = file//nl
                    file_length = file_length + 1
                    write(*,'(a)') 'WARNING: Ignoring erroneous value of (T) for header in read of file "'// &
                                    file_name//'". File has one line.'
                end if
            end do

            if ( file_length == 0 ) then
                error stop nl//'FATAL: Error reading file "'//file_name//'". File is empty after header.'
                return
            end if
        end if

        n_rows = 0

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                n_rows = n_rows + 1
            else if ( i == file_length ) then
                file = file//nl
                file_length = file_length + 1
                n_rows = n_rows + 1
            end if
        end do

        if ( fmt == 'i' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '-']
        else if ( fmt == 'z' ) then
            non_separating_chars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', &
                                    'a', 'b', 'c', 'd', 'e', 'f']
        end if

        prev_char = '0'
        n_columns = 0

        do i = 1, file_length
            current_char = file(i:i)

            if ( any(non_separating_chars == current_char) ) then
                prev_char = current_char
            else
                if ( any(non_separating_chars == prev_char) ) then
                    prev_char = current_char
                    n_columns = n_columns + 1
                else
                    prev_char = current_char
                end if
            end if

            if ( current_char == nl ) exit
        end do

        allocate( lines(n_rows) )

        row = 1
        l1 = 1

        do i = 1, file_length
            if ( file(i:i) == nl ) then
                lines(row)%s = file(l1:i)
                if ( row /= n_rows ) then
                    row = row + 1
                    l1 = i + 1
                else
                    exit
                end if
            end if
        end do

        deallocate(file)

        allocate( into(n_rows, n_columns) )

        do concurrent (row = 1:n_rows)
            column = 1
            l1 = 1
            l2 = 1
            read_into: do i = 1, len(lines(row)%s)
                if ( any(non_separating_chars == lines(row)%s(i:i)) ) then
                    if ( .not. any(non_separating_chars == lines(row)%s(l2:l2)) ) l1 = i
                    l2 = i
                else
                    if ( any(non_separating_chars == lines(row)%s(l2:l2)) ) then
                        if ( fmt == 'z' ) then
                            read(unit=lines(row)%s(l1:l2), fmt='(z'//str(l2-l1+1)//')') into(row, column)
                        else
                            read(unit=lines(row)%s(l1:l2), fmt=*) into(row, column)
                        end if
                        if ( column /= n_columns ) then
                            column = column + 1
                        else
                            exit read_into
                        end if
                        l2 = i
                    else
                        l2 = i
                    end if
                end if
            end do read_into
        end do
    end procedure from_text_2di8
end submodule text_io

submodule (io_fortran_lib) binary_io
    !! This submodule provides module procedure implementations for the **private interfaces** `to_binary` and
    !! `from_binary`.
    contains
    ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure to_binary_1dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dc128
    module procedure to_binary_1dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dc64
    module procedure to_binary_1dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_1dc32

    module procedure to_binary_2dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dc128
    module procedure to_binary_2dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dc64
    module procedure to_binary_2dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_2dc32

    module procedure to_binary_3dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dc128
    module procedure to_binary_3dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dc64
    module procedure to_binary_3dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_3dc32

    module procedure to_binary_4dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dc128
    module procedure to_binary_4dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dc64
    module procedure to_binary_4dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_4dc32

    module procedure to_binary_5dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dc128
    module procedure to_binary_5dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dc64
    module procedure to_binary_5dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_5dc32

    module procedure to_binary_6dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dc128
    module procedure to_binary_6dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dc64
    module procedure to_binary_6dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_6dc32

    module procedure to_binary_7dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dc128
    module procedure to_binary_7dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dc64
    module procedure to_binary_7dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_7dc32

    module procedure to_binary_8dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dc128
    module procedure to_binary_8dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dc64
    module procedure to_binary_8dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_8dc32

    module procedure to_binary_9dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dc128
    module procedure to_binary_9dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dc64
    module procedure to_binary_9dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_9dc32

    module procedure to_binary_10dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dc128
    module procedure to_binary_10dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dc64
    module procedure to_binary_10dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_10dc32

    module procedure to_binary_11dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dc128
    module procedure to_binary_11dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dc64
    module procedure to_binary_11dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_11dc32

    module procedure to_binary_12dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dc128
    module procedure to_binary_12dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dc64
    module procedure to_binary_12dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_12dc32

    module procedure to_binary_13dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dc128
    module procedure to_binary_13dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dc64
    module procedure to_binary_13dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_13dc32

    module procedure to_binary_14dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dc128
    module procedure to_binary_14dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dc64
    module procedure to_binary_14dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_14dc32

    module procedure to_binary_15dc128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dc128
    module procedure to_binary_15dc64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dc64
    module procedure to_binary_15dc32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_15dc32

    module procedure to_binary_1dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dr128
    module procedure to_binary_1dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1dr64
    module procedure to_binary_1dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x
        
        close(file_unit)
    end procedure to_binary_1dr32

    module procedure to_binary_2dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr128
    module procedure to_binary_2dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr64
    module procedure to_binary_2dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2dr32

    module procedure to_binary_3dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr128
    module procedure to_binary_3dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr64
    module procedure to_binary_3dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3dr32

    module procedure to_binary_4dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr128
    module procedure to_binary_4dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr64
    module procedure to_binary_4dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4dr32

    module procedure to_binary_5dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr128
    module procedure to_binary_5dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr64
    module procedure to_binary_5dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5dr32

    module procedure to_binary_6dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr128
    module procedure to_binary_6dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr64
    module procedure to_binary_6dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6dr32

    module procedure to_binary_7dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr128
    module procedure to_binary_7dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr64
    module procedure to_binary_7dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7dr32

    module procedure to_binary_8dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr128
    module procedure to_binary_8dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr64
    module procedure to_binary_8dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8dr32

    module procedure to_binary_9dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr128
    module procedure to_binary_9dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr64
    module procedure to_binary_9dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9dr32

    module procedure to_binary_10dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr128
    module procedure to_binary_10dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr64
    module procedure to_binary_10dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10dr32

    module procedure to_binary_11dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr128
    module procedure to_binary_11dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr64
    module procedure to_binary_11dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11dr32

    module procedure to_binary_12dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr128
    module procedure to_binary_12dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr64
    module procedure to_binary_12dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12dr32

    module procedure to_binary_13dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr128
    module procedure to_binary_13dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr64
    module procedure to_binary_13dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13dr32

    module procedure to_binary_14dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr128
    module procedure to_binary_14dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr64
    module procedure to_binary_14dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14dr32

    module procedure to_binary_15dr128
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr128
    module procedure to_binary_15dr64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr64
    module procedure to_binary_15dr32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15dr32

    module procedure to_binary_1di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di64
    module procedure to_binary_1di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di32
    module procedure to_binary_1di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di16
    module procedure to_binary_1di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_1di8

    module procedure to_binary_2di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di64
    module procedure to_binary_2di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di32
    module procedure to_binary_2di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di16
    module procedure to_binary_2di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_2di8

    module procedure to_binary_3di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di64
    module procedure to_binary_3di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di32
    module procedure to_binary_3di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di16
    module procedure to_binary_3di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_3di8

    module procedure to_binary_4di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di64
    module procedure to_binary_4di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di32
    module procedure to_binary_4di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di16
    module procedure to_binary_4di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_4di8

    module procedure to_binary_5di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di64
    module procedure to_binary_5di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di32
    module procedure to_binary_5di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di16
    module procedure to_binary_5di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_5di8

    module procedure to_binary_6di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di64
    module procedure to_binary_6di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di32
    module procedure to_binary_6di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di16
    module procedure to_binary_6di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_6di8

    module procedure to_binary_7di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di64
    module procedure to_binary_7di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di32
    module procedure to_binary_7di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di16
    module procedure to_binary_7di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_7di8

    module procedure to_binary_8di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di64
    module procedure to_binary_8di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di32
    module procedure to_binary_8di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di16
    module procedure to_binary_8di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_8di8

    module procedure to_binary_9di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di64
    module procedure to_binary_9di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di32
    module procedure to_binary_9di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di16
    module procedure to_binary_9di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_9di8

    module procedure to_binary_10di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di64
    module procedure to_binary_10di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di32
    module procedure to_binary_10di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di16
    module procedure to_binary_10di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_10di8

    module procedure to_binary_11di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di64
    module procedure to_binary_11di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di32
    module procedure to_binary_11di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di16
    module procedure to_binary_11di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_11di8

    module procedure to_binary_12di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di64
    module procedure to_binary_12di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di32
    module procedure to_binary_12di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di16
    module procedure to_binary_12di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_12di8

    module procedure to_binary_13di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di64
    module procedure to_binary_13di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di32
    module procedure to_binary_13di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di16
    module procedure to_binary_13di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_13di8

    module procedure to_binary_14di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di64
    module procedure to_binary_14di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di32
    module procedure to_binary_14di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di16
    module procedure to_binary_14di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_14di8

    module procedure to_binary_15di64
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di64
    module procedure to_binary_15di32
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di32
    module procedure to_binary_15di16
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di16
    module procedure to_binary_15di8
        logical :: exists
        integer :: file_unit

        inquire( file=file_name, exist=exists )

        file_unit = output_unit

        if ( .not. exists ) then
            open( newunit=file_unit, file=file_name, status='new', form='unformatted', &
                  action='write', access='stream' )
        else
            open( newunit=file_unit, file=file_name, status='replace', form='unformatted', &
                  action='write', access='stream' )
        end if

        write(unit=file_unit) x

        close(file_unit)
    end procedure to_binary_15di8

    ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    module procedure from_binary_1dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc128
    module procedure from_binary_1dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc64
    module procedure from_binary_1dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dc32

    module procedure from_binary_2dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc128
    module procedure from_binary_2dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc64
    module procedure from_binary_2dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dc32

    module procedure from_binary_3dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc128
    module procedure from_binary_3dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc64
    module procedure from_binary_3dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dc32

    module procedure from_binary_4dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc128
    module procedure from_binary_4dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc64
    module procedure from_binary_4dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dc32

    module procedure from_binary_5dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc128
    module procedure from_binary_5dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc64
    module procedure from_binary_5dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dc32

    module procedure from_binary_6dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc128
    module procedure from_binary_6dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc64
    module procedure from_binary_6dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dc32

    module procedure from_binary_7dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc128
    module procedure from_binary_7dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc64
    module procedure from_binary_7dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dc32

    module procedure from_binary_8dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc128
    module procedure from_binary_8dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc64
    module procedure from_binary_8dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dc32

    module procedure from_binary_9dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc128
    module procedure from_binary_9dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc64
    module procedure from_binary_9dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dc32

    module procedure from_binary_10dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc128
    module procedure from_binary_10dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc64
    module procedure from_binary_10dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dc32

    module procedure from_binary_11dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc128
    module procedure from_binary_11dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc64
    module procedure from_binary_11dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dc32

    module procedure from_binary_12dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc128
    module procedure from_binary_12dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc64
    module procedure from_binary_12dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dc32

    module procedure from_binary_13dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc128
    module procedure from_binary_13dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc64
    module procedure from_binary_13dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dc32

    module procedure from_binary_14dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc128
    module procedure from_binary_14dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc64
    module procedure from_binary_14dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dc32

    module procedure from_binary_15dc128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc128
    module procedure from_binary_15dc64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc64
    module procedure from_binary_15dc32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dc32

    module procedure from_binary_1dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr128
    module procedure from_binary_1dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr64
    module procedure from_binary_1dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1dr32

    module procedure from_binary_2dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr128
    module procedure from_binary_2dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr64
    module procedure from_binary_2dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2dr32

    module procedure from_binary_3dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr128
    module procedure from_binary_3dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr64
    module procedure from_binary_3dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3dr32

    module procedure from_binary_4dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr128
    module procedure from_binary_4dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr64
    module procedure from_binary_4dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4dr32

    module procedure from_binary_5dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr128
    module procedure from_binary_5dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr64
    module procedure from_binary_5dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5dr32

    module procedure from_binary_6dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr128
    module procedure from_binary_6dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr64
    module procedure from_binary_6dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6dr32

    module procedure from_binary_7dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr128
    module procedure from_binary_7dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr64
    module procedure from_binary_7dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7dr32

    module procedure from_binary_8dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr128
    module procedure from_binary_8dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr64
    module procedure from_binary_8dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8dr32

    module procedure from_binary_9dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr128
    module procedure from_binary_9dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr64
    module procedure from_binary_9dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9dr32

    module procedure from_binary_10dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr128
    module procedure from_binary_10dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr64
    module procedure from_binary_10dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10dr32

    module procedure from_binary_11dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr128
    module procedure from_binary_11dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr64
    module procedure from_binary_11dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11dr32

    module procedure from_binary_12dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr128
    module procedure from_binary_12dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr64
    module procedure from_binary_12dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12dr32

    module procedure from_binary_13dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr128
    module procedure from_binary_13dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr64
    module procedure from_binary_13dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13dr32

    module procedure from_binary_14dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr128
    module procedure from_binary_14dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr64
    module procedure from_binary_14dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14dr32

    module procedure from_binary_15dr128
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr128
    module procedure from_binary_15dr64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr64
    module procedure from_binary_15dr32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15dr32

    module procedure from_binary_1di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di64
    module procedure from_binary_1di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di32
    module procedure from_binary_1di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di16
    module procedure from_binary_1di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_1di8

    module procedure from_binary_2di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di64
    module procedure from_binary_2di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di32
    module procedure from_binary_2di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di16
    module procedure from_binary_2di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_2di8

    module procedure from_binary_3di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di64
    module procedure from_binary_3di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di32
    module procedure from_binary_3di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di16
    module procedure from_binary_3di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_3di8

    module procedure from_binary_4di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di64
    module procedure from_binary_4di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di32
    module procedure from_binary_4di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di16
    module procedure from_binary_4di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_4di8

    module procedure from_binary_5di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di64
    module procedure from_binary_5di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di32
    module procedure from_binary_5di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di16
    module procedure from_binary_5di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_5di8

    module procedure from_binary_6di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di64
    module procedure from_binary_6di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di32
    module procedure from_binary_6di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di16
    module procedure from_binary_6di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_6di8

    module procedure from_binary_7di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di64
    module procedure from_binary_7di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di32
    module procedure from_binary_7di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di16
    module procedure from_binary_7di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_7di8

    module procedure from_binary_8di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di64
    module procedure from_binary_8di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di32
    module procedure from_binary_8di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di16
    module procedure from_binary_8di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_8di8

    module procedure from_binary_9di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di64
    module procedure from_binary_9di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di32
    module procedure from_binary_9di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di16
    module procedure from_binary_9di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_9di8

    module procedure from_binary_10di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di64
    module procedure from_binary_10di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di32
    module procedure from_binary_10di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di16
    module procedure from_binary_10di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_10di8

    module procedure from_binary_11di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di64
    module procedure from_binary_11di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di32
    module procedure from_binary_11di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di16
    module procedure from_binary_11di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_11di8

    module procedure from_binary_12di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di64
    module procedure from_binary_12di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di32
    module procedure from_binary_12di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di16
    module procedure from_binary_12di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_12di8

    module procedure from_binary_13di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di64
    module procedure from_binary_13di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di32
    module procedure from_binary_13di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di16
    module procedure from_binary_13di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_13di8

    module procedure from_binary_14di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di64
    module procedure from_binary_14di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di32
    module procedure from_binary_14di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di16
    module procedure from_binary_14di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_14di8

    module procedure from_binary_15di64
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di64
    module procedure from_binary_15di32
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di32
    module procedure from_binary_15di16
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di16
    module procedure from_binary_15di8
        logical :: exists
        integer :: file_unit, iostat

        inquire( file=file_name, exist=exists )

        file_unit = input_unit

        if ( exists ) then
            open( newunit=file_unit, file=file_name, status='old', form='unformatted', &
                  action='read', access='stream', position='rewind' )
        else
            error stop nl//'FATAL: Error reading file "'//file_name//'". No such file exists.'
            return
        end if

        allocate( into(data_shape(1), data_shape(2), data_shape(3), data_shape(4), data_shape(5), data_shape(6), &
                       data_shape(7), data_shape(8), data_shape(9), data_shape(10), data_shape(11), data_shape(12), &
                       data_shape(13), data_shape(14), data_shape(15)) )
        read(unit=file_unit, iostat=iostat) into

        if ( iostat > 0 ) then
            error stop nl//'FATAL: Error reading file "'//file_name//'".'
            return
        end if

        close(file_unit)
    end procedure from_binary_15di8
end submodule binary_io
