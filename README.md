# IO Fortran Library

The IO Fortran Library is a Fortran module `io_fortran_lib` which provides high level routines for doing internal and external IO. In particular, the module provides a handful of generic interfaces for performing string-based and array-based IO that are useful for recording program data, reading data into programs, and for writing formatted logs and output. To use `io_fortran_lib` with your [fpm](https://github.com/fortran-lang/fpm) project, add the following lines to your `fpm.toml` file and `use` the module in your program units to access the routines:

```toml
[dependencies]
IO-Fortran-Library = { git="https://github.com/acbbullock/IO-Fortran-Library", branch="main" }
```

The module is fully self-contained, with no external dependencies, and is written to be portable and compliant to the Fortran 2018 standard such that no special extensions or compiler options should be required. All generic procedures which take numeric arguments support all of the standard kinds provided by the intrinsic `iso_fortran_env` module, including `int8`, `int16`, `int32`, `int64`, `real32`, `real64`, and `real128`. All array-based routines additionally support up to rank 15.

The following is a complete list of publicly accessible objects:

* [`interface str`](#pure-function-str): A function for representing a number as a string.
* [`interface echo`](#impure-subroutine-echo): A subroutine for recording a string to an external file.
* [`interface to_file`](#impure-subroutine-to_file): A subroutine for recording an array to an external file.
* [`interface from_file`](#impure-subroutine-from_file): A subroutine for reading an external file into an array.
* [`interface aprint`](#impure-subroutine-aprint): A subroutine for printing array sections to stdout.
* [`type String`](#type-string): A wrapper type for an allocatable string.
* [`parameter nl`](#parameter-nl): The new line character constant.

The API documentation for this project was generated by [FORD](https://github.com/Fortran-FOSS-Programmers/ford) and can be viewed online at [API-doc](https://acbbullock.github.io/IO-Fortran-Library/doc/index.html). To view the documentation locally, clone this repository and view `/doc/index.html` in your browser.

The remainder of this document provides a quick reference on how to use the public interfaces listed above.

## **IMPORTANT USER INFORMATION**

When writing floating point numbers of type `real` or `complex` as strings with `str` or `to_file`, any of the following text formats may be used:

```fortran
real_fmts = [ 'e', 'f', 'z' ]
```

* `'e'`: normalized exponential format (default), e.g. `1.2345678901234567E+005`
* `'f'`: decimal format, e.g. `123456.78901234567`
* `'z'`: hexadecimal format, e.g. `40FE240C9FCB68CD`

When writing `integer` data as strings with `str` or `to_file`, any of the following text formats may be used:

```fortran
int_fmts = [ 'i', 'z' ]
```

* `'i'`: integer format (default), e.g. `123456`
* `'z'`: hexadecimal format, e.g. `1E240`

Note: The `'z'` hexadecimal format is an integer format and may be used for `integer`, `real`, or `complex` data. Floating point numbers are interpreted bit-wise as integers when written with the `'z'` format, preventing any loss of precision in a round-trip conversion. This format is preferred for portable data transfers for which precision losses are intolerable.

When writing floating point numbers of type `real` or `complex` as strings with `str` or `to_file`, any of the following locales may be used:

```fortran
locales = [ 'US', 'EU' ]
```

* `'US'`: US decimal with default comma delimiter (default), e.g. `1.23456789,0.12345678`
* `'EU'`: EU decimal with default semicolon delimiter, e.g. `1,23456789;0,12345678`

When writing an array to file or reading into an array from file, a valid file extension must be present. The following are valid text file extensions for arrays of rank `1` or `2`:

```fortran
text_ext = [ 'csv', 'txt', 'ods', 'odf', 'odm', 'odt', 'xls', 'doc', 'log', 'rtf', 'org', 'dbf' ]
```

For arrays of any rank `1`-`15`, the following binary file extensions may be used:

```fortran
binary_ext = [ 'dat', 'bin' ]
```

The routines `to_file` and `from_file` will detect the file extension used and direct whether to write/read a text file or a binary file. When writing text files, it's important to note that some compilers implement extensions to the Fortran standard by default with regards to character array literals. For example, the array literal

```fortran
header = [ 'firstcol', 'secondcol' ]
```

is not standard Fortran 2018 since the strings in the array do not have identical length. Some compilers will accept this and others will not. If required, simply add padding spaces to the left or right of each string to match the length of the longest element. These padding spaces will not be present in the output file.

Note: Some compilers may allocate strings dynamically on the stack. When reading very large text files, this may result in a stack overflow or segmentation fault unless the compiler is directed to allocate everything on the heap. For example, one would specify `-heap-arrays 0` for the Intel Fortran compiler on Linux (`/heap-arrays:0` on Windows).

## `pure function str`

For `x` of type `integer`, `real`, `complex`:

```fortran
result = str(x, fmt)
```

```fortran
result = str(x, locale, fmt, decimals)
```

```fortran
result = str(x, locale, fmt, decimals, im)
```

* `locale` is `optional`, may be one of `locales` (`'US'` by default)
* `fmt` is `optional`, may be one of `int_fmts` if `x` is `integer` (`'i'` by default) or one of `real_fmts` if `x` is `real` or `complex` (`'e'` by default)
* `decimals` is `optional` and of type `integer`
* `im` is `optional` and of type `character(len=*)`

By default, the function `str` will write a `real` or `complex` number using a number of significant digits required in the worst case for a lossless round-trip conversion starting with the internal model representation of `x`. The `decimals` argument specifies the number of digits to write on the rhs of the radix point, which has a maximum allowed by precision, and a minimum of zero.

By default, `complex` numbers will be written as ordered pairs, e.g. `(2.45,3.45)`. If `im` is specified, then the number will be written as a sum with the specified imaginary unit, e.g. `2.45+3.45j` for `im='j'` or `2.45+3.45*1i` for `im='*1i'`.

## `impure subroutine echo`

```fortran
call echo(string, file_name, append)
```

* `string` is of type `character(len=*)`
* `file_name` is of type `character(len=*)`
* `append` is `optional` and of type `logical` (`.true.` by default)

The routine `echo` will write `string` to file literally, including any new line characters added on the part of the programmer, only inserting a new line at the end of the input string. The named file will be created if it does not already exist, and will be overwritten if `append == .false.` (if it already exists).

## `impure subroutine to_file`

For `x` of rank `1` and of type `integer`, `real`, `complex`:

```fortran
call to_file(x, file_name, header, dim, delim, fmt)
```

```fortran
call to_file(x, file_name, header, dim, locale, delim, fmt, decimals)
```

```fortran
call to_file(x, file_name, header, dim, locale, delim, fmt, decimals, im)
```

* `file_name` is of type `character(len=*)`
* `header` is `optional` and of type `character(len=*)` with attribute `dimension(:)`
* `dim` is `optional` and of type `integer`
* `locale` is `optional`, may be one of `locales` (`'US'` by default)
* `delim` is `optional` and of type `character(len=*)` (`','` by default for `'US'` and `';'` by default for `'EU'`)
* `fmt` is `optional`, may be one of `int_fmts` if `x` is `integer` (`'i'` by default) or one of `real_fmts` if `x` is `real` or `complex` (`'e'` by default)
* `decimals` is `optional` and of type `integer`
* `im` is `optional` and of type `character(len=*)`

For `x` of rank `2` and of type `integer`, `real`, `complex`:

```fortran
call to_file(x, file_name, header, delim, fmt)
```

```fortran
call to_file(x, file_name, header, locale, delim, fmt, decimals)
```

```fortran
call to_file(x, file_name, header, locale, delim, fmt, decimals, im)
```

* `file_name` is of type `character(len=*)`
* `header` is `optional` and of type `character(len=*)` with attribute `dimension(:)`
* `locale` is `optional`, may be one of `locales` (`'US'` by default)
* `delim` is `optional` and of type `character(len=*)` (`','` by default for `'US'` and `';'` by default for `'EU'`)
* `fmt` is `optional`, may be one of `int_fmts` if `x` is `integer` (`'i'` by default) or one of `real_fmts` if `x` is `real` or `complex` (`'e'` by default)
* `decimals` is `optional` and of type `integer`
* `im` is `optional` and of type `character(len=*)`

For `x` of rank `3`-`15` and of type `integer`, `real`, `complex`:

```fortran
call to_file(x, file_name)
```

* `file_name` is of type `character(len=*)`

Text writes are allowed if `x` has rank `1` or `2`, and binary writes are allowed if `x` has any rank `1`-`15`. For `x` of rank `1`, the `header` may be of size `1` or `size(x)` and the `dim` argument specifies whether to write along the rows (`dim=1`) or along the columns (`dim=2`), choosing the former by default unless `size(header) == size(x)`. For `x` of rank `2`, the `header` may be of size `1` or `size(x, dim=2)`. The `locale`, `fmt`, `decimals`, and `im` arguments are precisely as they are for the `str` function, and are honored in precisely the same ways, with `locale` additionally determining the default delimiter. It is always recommended to omit the delimiter argument for default unless a custom delimiter is really necessary. Any invalid actual arguments will be ignored, defaults will be assumed, and a warning message will be issued on stdout.

## `impure subroutine from_file`

For reading textual data into an `allocatable` array `into` of rank `1` or `2` and of type `integer`, `real`, `complex`:

```fortran
call from_file(file_name, into, header, fmt)
```

```fortran
call from_file(file_name, into, header, locale, fmt)
```

```fortran
call from_file(file_name, into, header, locale, fmt, im)
```

* `file_name` is of type `character(len=*)`
* `header` is `optional` and of type `logical` (`.false.` by default)
* `locale` is `optional`, may be one of `locales` (`'US'` by default)
* `fmt` is `optional`, may be one of `int_fmts` for `integer` data (`'i'` by default) or one of `real_fmts` for `real` or `complex` data (`'e'` by default)
* `im` is `optional` and of type `character(len=*)`

For reading binary data into an `allocatable` array `into` of any rank `1`-`15` and of type `integer`, `real`, `complex`:

```fortran
call from_file(file_name, into, data_shape)
```

* `file_name` is of type `character(len=*)`
* `data_shape` is of type `integer` with attribute `dimension(:)`

The corresponding actual argument of `into` must also be `allocatable`, and will lose its allocation status if already allocated upon passing into `from_file`. As a result, `from_file` does not allow reading into sections of already allocated arrays. If `im` is not present when reading textual complex data into an array of rank `1` or `2`, the data will be assumed to be in ordered pair form. When reading binary data, `data_shape` must be present and its size must equal the rank of `into` for the read to be valid. In the event that any actual arguments provided to `from_file` are invalid, the subprogram will not allow progression of execution of the caller and will issue an `error stop`. This is due to the critical nature of reads and the fact that the procedure may not be able to make the proper assumptions about the data being read.

## `impure subroutine aprint`

For `x` of rank `1` or `2` and of type `character`, `integer`, `real`, `complex`:

```fortran
call aprint(x)
```

```fortran
call aprint(x, fmt)
```

```fortran
call aprint(x, fmt, decimals)
```

```fortran
call aprint(x, fmt, decimals, im)
```

* `fmt` is `optional`, may be one of `int_fmts` for `integer` data (`'i'` by default) or one of `real_fmts` for `real` or `complex` data (`'f'` by default)
* `decimals` is `optional` and of type `integer` (`2` by default)
* `im` is `optional` and of type `character(len=*)` (`'j'` by default)

Note that the default values of the optional arguments of `aprint` are different than for `str` and `to_file`.

## `type String`

```fortran
type String
    character(len=:), allocatable :: s
end type String
```

This type is provided primarily for the purpose of standard compliance when needing to declare arrays of strings in which the elements may have non-identical lengths or for which the lengths of elements may need to vary during run-time.

## `parameter nl`

```fortran
character(len=1), parameter :: nl = new_line('a')
```

This is the new line character constant, provided for the purpose of inserting new lines in formatted output without needing to call the `new_line` intrinsic each time.
