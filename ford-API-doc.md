---
project: IO-Fortran-Library
summary: A portable, standard IO library for Modern Fortran
author: Austin C Bullock
author_email: acb.bullock@gmail.com
github: https://github.com/acbbullock
license: MIT
creation_date: %Y-%m-%d %H:%M %z
print_creation_date: true
project_github: https://github.com/acbbullock/IO-Fortran-Library
---

* [Purpose](#purpose)
* [Scope](#scope)
* [How to Use](#how-to-use)
* [Important User Information](#important-user-information)
* [License](#license)

# API Documentation

This API documentation was generated by [FORD](https://github.com/Fortran-FOSS-Programmers/ford).

## Purpose

The purpose of this project is to provide easily usable, accessible, and flexible interfaces for common input-output routines that are frequently needed for Fortran projects. The provided functionality is designed for plug-and-play with any compiler that supports the Fortran 2018 standard, and is intended to streamline workflows for projects where such functionality is needed without having to re-engineer such functionality for each project.

## Scope

The IO Fortran Library is a Fortran module `io_fortran_lib` which provides high level routines for doing internal and external IO. In particular, the module provides a handful of generic interfaces for performing string-based and array-based IO that are useful for recording program data, reading data into programs, and for writing formatted logs and output.

## How to Use

To use `io_fortran_lib` with your [fpm](https://github.com/fortran-lang/fpm) project, add the following lines to your `fpm.toml` file and `use` the module in your program units to access the routines:

```toml
[dependencies]
IO-Fortran-Library = { git="https://github.com/acbbullock/IO-Fortran-Library", branch="main" }
```

@note The module is fully self-contained, with no external dependencies, and is written to be portable and compliant to the Fortran 2018 standard such that no special extensions or compiler options should be required. All generic procedures which take numeric arguments support all of the standard kinds provided by the intrinsic `iso_fortran_env` module, including `int8`, `int16`, `int32`, `int64`, `real32`, `real64`, and `real128`. All array-based routines additionally support up to rank 15.

## Important User Information

When writing floating point numbers of type `real` or `complex` as strings with `str` or `to_file`, any of the following text formats may be used:

```fortran
real_fmts = [ 'e', 'f', 'z' ]
```

* `'e'`: normalized exponential format (default), e.g. `1.2345678901234567E+005`
* `'f'`: decimal format, e.g. `123456.78901234567`
* `'z'`: hexadecimal format, e.g. `40FE240C9FCB68CD`

When writing `integer` data as strings with `str` or `to_file`, any of the following text formats may be used:

```fortran
int_fmts = [ 'i', 'z' ]
```

* `'i'`: integer format (default), e.g. `123456`
* `'z'`: hexadecimal format, e.g. `1E240`

@note The `'z'` hexadecimal format is an integer format and may be used for `integer`, `real`, or `complex` data. Floating point numbers are interpreted bit-wise as integers when written with the `'z'` format, preventing any loss of precision in a round-trip conversion. This format is preferred for portable data transfers for which precision losses are intolerable.

When writing floating point numbers of type `real` or `complex` as strings with `str` or `to_file`, any of the following locales may be used:

```fortran
locales = [ 'US', 'EU' ]
```

* `'US'`: US decimal with default comma delimiter (default), e.g. `1.23456789,0.12345678`
* `'EU'`: EU decimal with default semicolon delimiter, e.g. `1,23456789;0,12345678`

When writing an array to file or reading into an array from file, a valid file extension must be present. The following are valid text file extensions for arrays of rank `1` or `2`:

```fortran
text_ext = [ 'csv', 'txt', 'ods', 'odf', 'odm', 'odt', 'xls', 'doc', 'log', 'rtf', 'org', 'dbf' ]
```

For arrays of any rank `1`-`15`, the following binary file extensions may be used:

```fortran
binary_ext = [ 'dat', 'bin' ]
```

The routines `to_file` and `from_file` will detect the file extension used and direct whether to write/read a text file or a binary file. When writing text files, it's important to note that some compilers implement extensions to the Fortran standard by default with regards to character array literals. For example, the array literal

```fortran
header = [ 'firstcol', 'secondcol' ]
```

is not standard Fortran 2018 since the strings in the array do not have identical length. Some compilers will accept this and others will not. If required, simply add padding spaces to the left or right of each string to match the length of the longest element. These padding spaces will not be present in the output file.

@note Some compilers may allocate strings dynamically on the stack. When reading very large text files, this may result in a stack overflow or segmentation fault unless the compiler is directed to allocate everything on the heap. For example, one would specify `-heap-arrays 0` for the Intel Fortran compiler on Linux (`/heap-arrays:0` on Windows).

## License

All source code referenced is distributed under the [MIT license](https://github.com/acbbullock/IO-Fortran-Library/blob/main/LICENCE) and available at [Github](https://github.com/acbbullock/IO-Fortran-Library).
