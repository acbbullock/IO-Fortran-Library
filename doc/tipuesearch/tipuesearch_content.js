var tipuesearch = {"pages":[{"title":" IO-Fortran-Library ","text":"IO-Fortran-Library API Documentation Purpose Scope How to Use License Contact API Documentation This API documentation was generated by FORD (the Fortran documentation generator). Purpose The purpose of this project is to provide accessible and flexible interfaces for common input-output routines that are frequently needed for Fortran projects. The provided functionality is designed for plug-and-play with any compiler that supports the Fortran 2018 standard, and is intended to streamline workflows for projects where such functionality is needed without having to re-engineer such functionality for each project. Scope The IO Fortran Library is a Fortran module io_fortran_lib which provides high level routines for doing internal and external I/O. In particular, the module provides a handful of generic interfaces for performing string-based and array-based I/O that are useful for recording program data, reading data into programs, and for writing formatted logs and output. For instance, one may write/read numeric data to/from .csv and .dat files, represent single numbers as strings inside of a string expression, and efficiently write strings to a .log file. Note The module is fully self-contained, with no external dependencies, and is written to be portable and compliant to the Fortran 2018 standard such that no special extensions or compiler options should be required. All generic interfaces which take numeric arguments support all of the standard kinds provided by the intrinsic iso_fortran_env module, including int8 , int16 , int32 , int64 , real32 , real64 , and real128 . All array-based routines additionally support up to rank 15. How to Use To use io_fortran_lib with your fpm project, add the following lines to your fpm.toml file and use the module in your program units to access the routines: [dependencies] IO-Fortran-Library = { git = \"https://github.com/acbbullock/IO-Fortran-Library\" , branch = \"main\" } See the important user information and reference guide for information about calling the routines , and further see the tutorials for complete example programs. License All source code referenced is distributed under the MIT license and available at Github . Contact For bug fixes or feature requests, feel free to open an issue at the project repository or contact acb.bullock@gmail.com . Developer Info Austin C Bullock","tags":"home","loc":"index.html"},{"title":"String – IO-Fortran-Library ","text":"type, public :: String Public wrapper type for an allocatable string. This type is provided primarily for the purpose of standard compliance when needing to declare arrays of\nstrings in which the elements may have non-identical lengths or for which the lengths of elements may need\nto vary during run-time. Contents Variables s Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s","tags":"","loc":"type/string.html"},{"title":"aprint – IO-Fortran-Library","text":"public interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . Contents Subroutines aprint_1dc128 aprint_1dc64 aprint_1dc32 aprint_2dc128 aprint_2dc64 aprint_2dc32 aprint_1dr128 aprint_1dr64 aprint_1dr32 aprint_2dr128 aprint_2dr64 aprint_2dr32 aprint_1di64 aprint_1di32 aprint_1di16 aprint_1di8 aprint_2di64 aprint_2di32 aprint_2di16 aprint_2di8 aprint_1dchar aprint_2dchar aprint_1dString aprint_2dString Subroutines private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:,:) :: x private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:,:) :: x","tags":"","loc":"interface/aprint.html"},{"title":"str – IO-Fortran-Library","text":"public interface str Function for representing a number as a string. By default behavior, str will write a real or complex number using a number of significant digits\nrequired in the worst case for a lossless round-trip conversion starting with the internal model\nrepresentation of x . For a user reference, see str . Contents Functions str_c128 str_c64 str_c32 str_r128 str_r64 str_r32 str_i64 str_i32 str_i16 str_i8 Functions private pure recursive module function str_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"to_file – IO-Fortran-Library","text":"public interface to_file Subroutine for writing an array to an external file. The file file_name will be created if it does not already exist and will be overwritten if it does exist.\nWriting to text is allowed for arrays of rank 1 or 2 , and writing to binary is allowed for arrays of any\nrank 1 - 15 . Any invalid actual arguments will be ignored, defaults will be assumed, and a warning message\nwill be issued on stdout. For a user reference, see to_file . Contents Subroutines to_file_1dc128 to_file_1dc64 to_file_1dc32 to_file_2dc128 to_file_2dc64 to_file_2dc32 to_file_3dc128 to_file_3dc64 to_file_3dc32 to_file_4dc128 to_file_4dc64 to_file_4dc32 to_file_5dc128 to_file_5dc64 to_file_5dc32 to_file_6dc128 to_file_6dc64 to_file_6dc32 to_file_7dc128 to_file_7dc64 to_file_7dc32 to_file_8dc128 to_file_8dc64 to_file_8dc32 to_file_9dc128 to_file_9dc64 to_file_9dc32 to_file_10dc128 to_file_10dc64 to_file_10dc32 to_file_11dc128 to_file_11dc64 to_file_11dc32 to_file_12dc128 to_file_12dc64 to_file_12dc32 to_file_13dc128 to_file_13dc64 to_file_13dc32 to_file_14dc128 to_file_14dc64 to_file_14dc32 to_file_15dc128 to_file_15dc64 to_file_15dc32 to_file_1dr128 to_file_1dr64 to_file_1dr32 to_file_2dr128 to_file_2dr64 to_file_2dr32 to_file_3dr128 to_file_3dr64 to_file_3dr32 to_file_4dr128 to_file_4dr64 to_file_4dr32 to_file_5dr128 to_file_5dr64 to_file_5dr32 to_file_6dr128 to_file_6dr64 to_file_6dr32 to_file_7dr128 to_file_7dr64 to_file_7dr32 to_file_8dr128 to_file_8dr64 to_file_8dr32 to_file_9dr128 to_file_9dr64 to_file_9dr32 to_file_10dr128 to_file_10dr64 to_file_10dr32 to_file_11dr128 to_file_11dr64 to_file_11dr32 to_file_12dr128 to_file_12dr64 to_file_12dr32 to_file_13dr128 to_file_13dr64 to_file_13dr32 to_file_14dr128 to_file_14dr64 to_file_14dr32 to_file_15dr128 to_file_15dr64 to_file_15dr32 to_file_1di64 to_file_1di32 to_file_1di16 to_file_1di8 to_file_2di64 to_file_2di32 to_file_2di16 to_file_2di8 to_file_3di64 to_file_3di32 to_file_3di16 to_file_3di8 to_file_4di64 to_file_4di32 to_file_4di16 to_file_4di8 to_file_5di64 to_file_5di32 to_file_5di16 to_file_5di8 to_file_6di64 to_file_6di32 to_file_6di16 to_file_6di8 to_file_7di64 to_file_7di32 to_file_7di16 to_file_7di8 to_file_8di64 to_file_8di32 to_file_8di16 to_file_8di8 to_file_9di64 to_file_9di32 to_file_9di16 to_file_9di8 to_file_10di64 to_file_10di32 to_file_10di16 to_file_10di8 to_file_11di64 to_file_11di32 to_file_11di16 to_file_11di8 to_file_12di64 to_file_12di32 to_file_12di16 to_file_12di8 to_file_13di64 to_file_13di32 to_file_13di16 to_file_13di8 to_file_14di64 to_file_14di32 to_file_14di16 to_file_14di8 to_file_15di64 to_file_15di32 to_file_15di16 to_file_15di8 Subroutines private impure recursive module subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_3dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_3dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1di64(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di32(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di16(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di8(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di64(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di32(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di16(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di8(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_3di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name","tags":"","loc":"interface/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"public interface from_file Subroutine for reading an external file into an array. In the event that any actual arguments provided to from_file are invalid, the subprogram will not allow\nprogression of execution of the caller and will issue an error stop . This is due to the critical nature of\nreads and the fact that the procedure may not be able to make the proper assumptions about the data being\nread. For a user reference, see from_file . Contents Subroutines from_textfile_1dc128 from_binaryfile_1dc128 from_textfile_1dc64 from_binaryfile_1dc64 from_textfile_1dc32 from_binaryfile_1dc32 from_textfile_2dc128 from_binaryfile_2dc128 from_textfile_2dc64 from_binaryfile_2dc64 from_textfile_2dc32 from_binaryfile_2dc32 from_file_3dc128 from_file_3dc64 from_file_3dc32 from_file_4dc128 from_file_4dc64 from_file_4dc32 from_file_5dc128 from_file_5dc64 from_file_5dc32 from_file_6dc128 from_file_6dc64 from_file_6dc32 from_file_7dc128 from_file_7dc64 from_file_7dc32 from_file_8dc128 from_file_8dc64 from_file_8dc32 from_file_9dc128 from_file_9dc64 from_file_9dc32 from_file_10dc128 from_file_10dc64 from_file_10dc32 from_file_11dc128 from_file_11dc64 from_file_11dc32 from_file_12dc128 from_file_12dc64 from_file_12dc32 from_file_13dc128 from_file_13dc64 from_file_13dc32 from_file_14dc128 from_file_14dc64 from_file_14dc32 from_file_15dc128 from_file_15dc64 from_file_15dc32 from_textfile_1dr128 from_binaryfile_1dr128 from_textfile_1dr64 from_binaryfile_1dr64 from_textfile_1dr32 from_binaryfile_1dr32 from_textfile_2dr128 from_binaryfile_2dr128 from_textfile_2dr64 from_binaryfile_2dr64 from_textfile_2dr32 from_binaryfile_2dr32 from_file_3dr128 from_file_3dr64 from_file_3dr32 from_file_4dr128 from_file_4dr64 from_file_4dr32 from_file_5dr128 from_file_5dr64 from_file_5dr32 from_file_6dr128 from_file_6dr64 from_file_6dr32 from_file_7dr128 from_file_7dr64 from_file_7dr32 from_file_8dr128 from_file_8dr64 from_file_8dr32 from_file_9dr128 from_file_9dr64 from_file_9dr32 from_file_10dr128 from_file_10dr64 from_file_10dr32 from_file_11dr128 from_file_11dr64 from_file_11dr32 from_file_12dr128 from_file_12dr64 from_file_12dr32 from_file_13dr128 from_file_13dr64 from_file_13dr32 from_file_14dr128 from_file_14dr64 from_file_14dr32 from_file_15dr128 from_file_15dr64 from_file_15dr32 from_textfile_1di64 from_binaryfile_1di64 from_textfile_1di32 from_binaryfile_1di32 from_textfile_1di16 from_binaryfile_1di16 from_textfile_1di8 from_binaryfile_1di8 from_textfile_2di64 from_binaryfile_2di64 from_textfile_2di32 from_binaryfile_2di32 from_textfile_2di16 from_binaryfile_2di16 from_textfile_2di8 from_binaryfile_2di8 from_file_3di64 from_file_3di32 from_file_3di16 from_file_3di8 from_file_4di64 from_file_4di32 from_file_4di16 from_file_4di8 from_file_5di64 from_file_5di32 from_file_5di16 from_file_5di8 from_file_6di64 from_file_6di32 from_file_6di16 from_file_6di8 from_file_7di64 from_file_7di32 from_file_7di16 from_file_7di8 from_file_8di64 from_file_8di32 from_file_8di16 from_file_8di8 from_file_9di64 from_file_9di32 from_file_9di16 from_file_9di8 from_file_10di64 from_file_10di32 from_file_10di16 from_file_10di8 from_file_11di64 from_file_11di32 from_file_11di16 from_file_11di8 from_file_12di64 from_file_12di32 from_file_12di16 from_file_12di8 from_file_13di64 from_file_13di32 from_file_13di16 from_file_13di8 from_file_14di64 from_file_14di32 from_file_14di16 from_file_14di8 from_file_15di64 from_file_15di32 from_file_15di16 from_file_15di8 Subroutines private impure recursive module subroutine from_textfile_1dc128(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc64(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc32(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc128(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc64(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc32(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr128(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr64(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr32(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr128(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr64(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr32(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di64(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di32(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di16(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di8(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di64(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di32(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di16(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di8(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape","tags":"","loc":"interface/from_file.html"},{"title":"echo – IO-Fortran-Library","text":"public interface echo Subroutine for writing a string to an external file. The file file_name will be created if it does not already exist and will be overwritten if append is .false. (if it already exists), with a new line always being inserted at the end of string . For a user reference, see echo . Contents Subroutines echo_string Subroutines private impure recursive module subroutine echo_string(string, file_name, append) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: file_name logical, intent(in), optional :: append","tags":"","loc":"interface/echo.html"},{"title":"io_fortran_lib – IO-Fortran-Library","text":"This module provides common I/O routines for arrays of complex, real, integer, and character type. Such\nroutines include printing array sections and reading/writing multidimensional arrays from/to text files\nand binary files. An interface for number -> string conversion is provided as well as a simple text logging\nroutine. This module is F2018 compliant, has no external dependencies, and has a max line length of 120. Uses iso_fortran_env Used by Descendants: array_printing binary_io file_io internal_io text_io Contents Variables nl Interfaces aprint str to_file from_file echo Derived Types String Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: nl = new_line('a') This is the new line character constant, provided for the purpose of inserting new lines into strings without\nneeding to call the new_line intrinsic each time. Interfaces public        interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:,:) :: x private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:,:) :: x public        interface str Function for representing a number as a string. By default behavior, str will write a real or complex number using a number of significant digits\nrequired in the worst case for a lossless round-trip conversion starting with the internal model\nrepresentation of x . For a user reference, see str . private pure recursive module function str_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable public        interface to_file Subroutine for writing an array to an external file. The file file_name will be created if it does not already exist and will be overwritten if it does exist.\nWriting to text is allowed for arrays of rank 1 or 2 , and writing to binary is allowed for arrays of any\nrank 1 - 15 . Any invalid actual arguments will be ignored, defaults will be assumed, and a warning message\nwill be issued on stdout. For a user reference, see to_file . private impure recursive module subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_3dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_3dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1di64(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di32(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di16(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di8(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di64(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di32(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di16(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di8(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_3di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name public        interface from_file Subroutine for reading an external file into an array. In the event that any actual arguments provided to from_file are invalid, the subprogram will not allow\nprogression of execution of the caller and will issue an error stop . This is due to the critical nature of\nreads and the fact that the procedure may not be able to make the proper assumptions about the data being\nread. For a user reference, see from_file . private impure recursive module subroutine from_textfile_1dc128(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc64(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc32(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc128(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc64(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc32(file_name, into, header, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr128(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr64(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr32(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr128(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr64(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr32(file_name, into, header, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di64(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di32(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di16(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di8(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di64(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di32(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di16(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di8(file_name, into, header, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape public        interface echo Subroutine for writing a string to an external file. The file file_name will be created if it does not already exist and will be overwritten if append is .false. (if it already exists), with a new line always being inserted at the end of string . For a user reference, see echo . private impure recursive module subroutine echo_string(string, file_name, append) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: file_name logical, intent(in), optional :: append Derived Types type, public :: String Public wrapper type for an allocatable string. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: s","tags":"","loc":"module/io_fortran_lib.html"},{"title":"array_printing – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface aprint . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/array_printing.html"},{"title":"internal_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface str . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/internal_io.html"},{"title":"file_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces to_file and from_file . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/file_io.html"},{"title":"text_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface echo and the private\ninterfaces to_text and from_text . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/text_io.html"},{"title":"binary_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the private interfaces to_binary and from_binary . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/binary_io.html"},{"title":"io_fortran_lib.f90 – IO-Fortran-Library","text":"Contents Modules io_fortran_lib Submodules array_printing internal_io file_io text_io binary_io Source Code io_fortran_lib.f90 Source Code module io_fortran_lib !------------------------------------------------------------------------------------------------------------------ !!  This module provides common I/O routines for arrays of complex, real, integer, and character type. Such !!  routines include printing array sections and reading/writing multidimensional arrays from/to text files !!  and binary files. An interface for number -> string conversion is provided as well as a simple text logging !!  routine. This module is F2018 compliant, has no external dependencies, and has a max line length of 120. !------------------------------------------------------------------------------------------------------------------ use , intrinsic :: iso_fortran_env , only : real128 , real64 , real32 , int64 , int32 , int16 , int8 , & ! Standard kinds input_unit , output_unit ! Standard input and output units implicit none ( type , external ) ! No implicit types or interfaces private ! Public API list ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ public :: aprint , to_file , from_file ! Array I/O public :: str , echo ! String I/O public :: nl ! Constants public :: String ! Classes ! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 1 ), parameter :: nl = new_line ( 'a' ) !! This is the new line character constant, provided for the purpose of inserting new lines into strings without !! needing to call the `new_line` intrinsic each time. character ( len =* ), dimension ( * ), parameter :: text_ext = [ 'csv' , 'txt' , 'ods' , & ! Allowed text extensions 'odf' , 'odm' , 'odt' , & 'xls' , 'doc' , 'log' , & 'rtf' , 'org' , 'dbf' ] character ( len =* ), dimension ( * ), parameter :: binary_ext = [ 'dat' , 'bin' ] ! Allowed binary extensions character ( len =* ), dimension ( * ), parameter :: real_fmts = [ 'e' , 'f' , 'z' ] ! Allowed formats for floats character ( len =* ), dimension ( * ), parameter :: int_fmts = [ 'i' , 'z' ] ! Allowed formats for integers character ( len =* ), dimension ( * ), parameter :: locales = [ 'US' , 'EU' ] ! Allowed locale specifiers type String ! Simple string wrapper type !-------------------------------------------------------------------------------------------------------------- !! Public wrapper type for an allocatable string. !! !! This type is provided primarily for the purpose of standard compliance when needing to declare arrays of !! strings in which the elements may have non-identical lengths or for which the lengths of elements may need !! to vary during run-time. !-------------------------------------------------------------------------------------------------------------- character ( len = :), allocatable :: s end type String interface aprint ! Submodule array_printing !-------------------------------------------------------------------------------------------------------------- !! Subroutine for printing arrays and array sections to stdout. !! !! For a user reference, see [aprint](../page/Ref/aprint.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine aprint_1dc128 ( x , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc128 impure recursive module subroutine aprint_1dc64 ( x , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc64 impure recursive module subroutine aprint_1dc32 ( x , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc32 impure recursive module subroutine aprint_2dc128 ( x , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc128 impure recursive module subroutine aprint_2dc64 ( x , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc64 impure recursive module subroutine aprint_2dc32 ( x , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc32 impure recursive module subroutine aprint_1dr128 ( x , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr128 impure recursive module subroutine aprint_1dr64 ( x , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr64 impure recursive module subroutine aprint_1dr32 ( x , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr32 impure recursive module subroutine aprint_2dr128 ( x , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr128 impure recursive module subroutine aprint_2dr64 ( x , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr64 impure recursive module subroutine aprint_2dr32 ( x , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr32 impure recursive module subroutine aprint_1di64 ( x , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di64 impure recursive module subroutine aprint_1di32 ( x , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di32 impure recursive module subroutine aprint_1di16 ( x , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di16 impure recursive module subroutine aprint_1di8 ( x , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di8 impure recursive module subroutine aprint_2di64 ( x , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di64 impure recursive module subroutine aprint_2di32 ( x , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di32 impure recursive module subroutine aprint_2di16 ( x , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di16 impure recursive module subroutine aprint_2di8 ( x , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di8 impure recursive module subroutine aprint_1dchar ( x ) character ( len =* ), dimension (:), intent ( in ) :: x end subroutine aprint_1dchar impure recursive module subroutine aprint_2dchar ( x ) character ( len =* ), dimension (:,:), intent ( in ) :: x end subroutine aprint_2dchar impure recursive module subroutine aprint_1dString ( x ) type ( String ), dimension (:), intent ( in ) :: x end subroutine aprint_1dString impure recursive module subroutine aprint_2dString ( x ) type ( String ), dimension (:,:), intent ( in ) :: x end subroutine aprint_2dString end interface interface str ! Submodule internal_io !-------------------------------------------------------------------------------------------------------------- !! Function for representing a number as a string. !! !! By default behavior, `str` will write a `real` or `complex` number using a number of significant digits !! required in the worst case for a lossless round-trip conversion starting with the internal model !! representation of `x`. !! !! For a user reference, see [str](../page/Ref/str.html). !-------------------------------------------------------------------------------------------------------------- pure recursive module function str_c128 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_c128 pure recursive module function str_c64 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_c64 pure recursive module function str_c32 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_c32 pure recursive module function str_r128 ( x , locale , fmt , decimals ) result ( x_str ) real ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_r128 pure recursive module function str_r64 ( x , locale , fmt , decimals ) result ( x_str ) real ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_r64 pure recursive module function str_r32 ( x , locale , fmt , decimals ) result ( x_str ) real ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_r32 pure recursive module function str_i64 ( x , fmt ) result ( x_str ) integer ( int64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_i64 pure recursive module function str_i32 ( x , fmt ) result ( x_str ) integer ( int32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_i32 pure recursive module function str_i16 ( x , fmt ) result ( x_str ) integer ( int16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_i16 pure recursive module function str_i8 ( x , fmt ) result ( x_str ) integer ( int8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_i8 end interface interface to_file ! Submodule file_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for writing an array to an external file. !! !! The file `file_name` will be created if it does not already exist and will be overwritten if it does exist. !! Writing to text is allowed for arrays of rank `1` or `2`, and writing to binary is allowed for arrays of any !! rank `1`-`15`. Any invalid actual arguments will be ignored, defaults will be assumed, and a warning message !! will be issued on stdout. !! !! For a user reference, see [to_file](../page/Ref/to_file.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_file_1dc128 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc128 impure recursive module subroutine to_file_1dc64 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc64 impure recursive module subroutine to_file_1dc32 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc32 impure recursive module subroutine to_file_2dc128 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc128 impure recursive module subroutine to_file_2dc64 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc64 impure recursive module subroutine to_file_2dc32 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc32 impure recursive module subroutine to_file_3dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc128 impure recursive module subroutine to_file_3dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc64 impure recursive module subroutine to_file_3dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc32 impure recursive module subroutine to_file_4dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc128 impure recursive module subroutine to_file_4dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc64 impure recursive module subroutine to_file_4dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc32 impure recursive module subroutine to_file_5dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc128 impure recursive module subroutine to_file_5dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc64 impure recursive module subroutine to_file_5dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc32 impure recursive module subroutine to_file_6dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc128 impure recursive module subroutine to_file_6dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc64 impure recursive module subroutine to_file_6dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc32 impure recursive module subroutine to_file_7dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc128 impure recursive module subroutine to_file_7dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc64 impure recursive module subroutine to_file_7dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc32 impure recursive module subroutine to_file_8dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc128 impure recursive module subroutine to_file_8dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc64 impure recursive module subroutine to_file_8dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc32 impure recursive module subroutine to_file_9dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc128 impure recursive module subroutine to_file_9dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc64 impure recursive module subroutine to_file_9dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc32 impure recursive module subroutine to_file_10dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc128 impure recursive module subroutine to_file_10dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc64 impure recursive module subroutine to_file_10dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc32 impure recursive module subroutine to_file_11dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc128 impure recursive module subroutine to_file_11dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc64 impure recursive module subroutine to_file_11dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc32 impure recursive module subroutine to_file_12dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc128 impure recursive module subroutine to_file_12dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc64 impure recursive module subroutine to_file_12dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc32 impure recursive module subroutine to_file_13dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc128 impure recursive module subroutine to_file_13dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc64 impure recursive module subroutine to_file_13dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc32 impure recursive module subroutine to_file_14dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc128 impure recursive module subroutine to_file_14dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc64 impure recursive module subroutine to_file_14dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc32 impure recursive module subroutine to_file_15dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc128 impure recursive module subroutine to_file_15dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc64 impure recursive module subroutine to_file_15dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc32 impure recursive module subroutine to_file_1dr128 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr128 impure recursive module subroutine to_file_1dr64 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr64 impure recursive module subroutine to_file_1dr32 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr32 impure recursive module subroutine to_file_2dr128 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr128 impure recursive module subroutine to_file_2dr64 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr64 impure recursive module subroutine to_file_2dr32 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr32 impure recursive module subroutine to_file_3dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr128 impure recursive module subroutine to_file_3dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr64 impure recursive module subroutine to_file_3dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr32 impure recursive module subroutine to_file_4dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr128 impure recursive module subroutine to_file_4dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr64 impure recursive module subroutine to_file_4dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr32 impure recursive module subroutine to_file_5dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr128 impure recursive module subroutine to_file_5dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr64 impure recursive module subroutine to_file_5dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr32 impure recursive module subroutine to_file_6dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr128 impure recursive module subroutine to_file_6dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr64 impure recursive module subroutine to_file_6dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr32 impure recursive module subroutine to_file_7dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr128 impure recursive module subroutine to_file_7dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr64 impure recursive module subroutine to_file_7dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr32 impure recursive module subroutine to_file_8dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr128 impure recursive module subroutine to_file_8dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr64 impure recursive module subroutine to_file_8dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr32 impure recursive module subroutine to_file_9dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr128 impure recursive module subroutine to_file_9dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr64 impure recursive module subroutine to_file_9dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr32 impure recursive module subroutine to_file_10dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr128 impure recursive module subroutine to_file_10dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr64 impure recursive module subroutine to_file_10dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr32 impure recursive module subroutine to_file_11dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr128 impure recursive module subroutine to_file_11dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr64 impure recursive module subroutine to_file_11dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr32 impure recursive module subroutine to_file_12dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr128 impure recursive module subroutine to_file_12dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr64 impure recursive module subroutine to_file_12dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr32 impure recursive module subroutine to_file_13dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr128 impure recursive module subroutine to_file_13dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr64 impure recursive module subroutine to_file_13dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr32 impure recursive module subroutine to_file_14dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr128 impure recursive module subroutine to_file_14dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr64 impure recursive module subroutine to_file_14dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr32 impure recursive module subroutine to_file_15dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr128 impure recursive module subroutine to_file_15dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr64 impure recursive module subroutine to_file_15dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr32 impure recursive module subroutine to_file_1di64 ( x , file_name , header , dim , delim , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di64 impure recursive module subroutine to_file_1di32 ( x , file_name , header , dim , delim , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di32 impure recursive module subroutine to_file_1di16 ( x , file_name , header , dim , delim , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di16 impure recursive module subroutine to_file_1di8 ( x , file_name , header , dim , delim , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di8 impure recursive module subroutine to_file_2di64 ( x , file_name , header , delim , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di64 impure recursive module subroutine to_file_2di32 ( x , file_name , header , delim , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di32 impure recursive module subroutine to_file_2di16 ( x , file_name , header , delim , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di16 impure recursive module subroutine to_file_2di8 ( x , file_name , header , delim , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di8 impure recursive module subroutine to_file_3di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di64 impure recursive module subroutine to_file_3di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di32 impure recursive module subroutine to_file_3di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di16 impure recursive module subroutine to_file_3di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di8 impure recursive module subroutine to_file_4di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di64 impure recursive module subroutine to_file_4di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di32 impure recursive module subroutine to_file_4di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di16 impure recursive module subroutine to_file_4di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di8 impure recursive module subroutine to_file_5di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di64 impure recursive module subroutine to_file_5di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di32 impure recursive module subroutine to_file_5di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di16 impure recursive module subroutine to_file_5di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di8 impure recursive module subroutine to_file_6di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di64 impure recursive module subroutine to_file_6di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di32 impure recursive module subroutine to_file_6di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di16 impure recursive module subroutine to_file_6di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di8 impure recursive module subroutine to_file_7di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di64 impure recursive module subroutine to_file_7di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di32 impure recursive module subroutine to_file_7di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di16 impure recursive module subroutine to_file_7di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di8 impure recursive module subroutine to_file_8di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di64 impure recursive module subroutine to_file_8di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di32 impure recursive module subroutine to_file_8di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di16 impure recursive module subroutine to_file_8di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di8 impure recursive module subroutine to_file_9di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di64 impure recursive module subroutine to_file_9di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di32 impure recursive module subroutine to_file_9di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di16 impure recursive module subroutine to_file_9di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di8 impure recursive module subroutine to_file_10di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di64 impure recursive module subroutine to_file_10di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di32 impure recursive module subroutine to_file_10di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di16 impure recursive module subroutine to_file_10di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di8 impure recursive module subroutine to_file_11di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di64 impure recursive module subroutine to_file_11di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di32 impure recursive module subroutine to_file_11di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di16 impure recursive module subroutine to_file_11di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di8 impure recursive module subroutine to_file_12di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di64 impure recursive module subroutine to_file_12di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di32 impure recursive module subroutine to_file_12di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di16 impure recursive module subroutine to_file_12di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di8 impure recursive module subroutine to_file_13di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di64 impure recursive module subroutine to_file_13di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di32 impure recursive module subroutine to_file_13di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di16 impure recursive module subroutine to_file_13di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di8 impure recursive module subroutine to_file_14di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di64 impure recursive module subroutine to_file_14di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di32 impure recursive module subroutine to_file_14di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di16 impure recursive module subroutine to_file_14di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di8 impure recursive module subroutine to_file_15di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di64 impure recursive module subroutine to_file_15di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di32 impure recursive module subroutine to_file_15di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di16 impure recursive module subroutine to_file_15di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di8 end interface interface from_file ! Submodule file_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for reading an external file into an array. !! !! In the event that any actual arguments provided to `from_file` are invalid, the subprogram will not allow !! progression of execution of the caller and will issue an `error stop`. This is due to the critical nature of !! reads and the fact that the procedure may not be able to make the proper assumptions about the data being !! read. !! !! For a user reference, see [from_file](../page/Ref/from_file.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_textfile_1dc128 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc128 impure recursive module subroutine from_binaryfile_1dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc128 impure recursive module subroutine from_textfile_1dc64 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc64 impure recursive module subroutine from_binaryfile_1dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc64 impure recursive module subroutine from_textfile_1dc32 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc32 impure recursive module subroutine from_binaryfile_1dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc32 impure recursive module subroutine from_textfile_2dc128 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc128 impure recursive module subroutine from_binaryfile_2dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc128 impure recursive module subroutine from_textfile_2dc64 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc64 impure recursive module subroutine from_binaryfile_2dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc64 impure recursive module subroutine from_textfile_2dc32 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc32 impure recursive module subroutine from_binaryfile_2dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc32 impure recursive module subroutine from_file_3dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc128 impure recursive module subroutine from_file_3dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc64 impure recursive module subroutine from_file_3dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc32 impure recursive module subroutine from_file_4dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc128 impure recursive module subroutine from_file_4dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc64 impure recursive module subroutine from_file_4dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc32 impure recursive module subroutine from_file_5dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc128 impure recursive module subroutine from_file_5dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc64 impure recursive module subroutine from_file_5dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc32 impure recursive module subroutine from_file_6dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc128 impure recursive module subroutine from_file_6dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc64 impure recursive module subroutine from_file_6dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc32 impure recursive module subroutine from_file_7dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc128 impure recursive module subroutine from_file_7dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc64 impure recursive module subroutine from_file_7dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc32 impure recursive module subroutine from_file_8dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc128 impure recursive module subroutine from_file_8dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc64 impure recursive module subroutine from_file_8dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc32 impure recursive module subroutine from_file_9dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc128 impure recursive module subroutine from_file_9dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc64 impure recursive module subroutine from_file_9dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc32 impure recursive module subroutine from_file_10dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc128 impure recursive module subroutine from_file_10dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc64 impure recursive module subroutine from_file_10dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc32 impure recursive module subroutine from_file_11dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc128 impure recursive module subroutine from_file_11dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc64 impure recursive module subroutine from_file_11dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc32 impure recursive module subroutine from_file_12dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc128 impure recursive module subroutine from_file_12dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc64 impure recursive module subroutine from_file_12dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc32 impure recursive module subroutine from_file_13dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc128 impure recursive module subroutine from_file_13dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc64 impure recursive module subroutine from_file_13dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc32 impure recursive module subroutine from_file_14dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc128 impure recursive module subroutine from_file_14dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc64 impure recursive module subroutine from_file_14dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc32 impure recursive module subroutine from_file_15dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc128 impure recursive module subroutine from_file_15dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc64 impure recursive module subroutine from_file_15dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc32 impure recursive module subroutine from_textfile_1dr128 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr128 impure recursive module subroutine from_binaryfile_1dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr128 impure recursive module subroutine from_textfile_1dr64 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr64 impure recursive module subroutine from_binaryfile_1dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr64 impure recursive module subroutine from_textfile_1dr32 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr32 impure recursive module subroutine from_binaryfile_1dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr32 impure recursive module subroutine from_textfile_2dr128 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr128 impure recursive module subroutine from_binaryfile_2dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr128 impure recursive module subroutine from_textfile_2dr64 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr64 impure recursive module subroutine from_binaryfile_2dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr64 impure recursive module subroutine from_textfile_2dr32 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr32 impure recursive module subroutine from_binaryfile_2dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr32 impure recursive module subroutine from_file_3dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr128 impure recursive module subroutine from_file_3dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr64 impure recursive module subroutine from_file_3dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr32 impure recursive module subroutine from_file_4dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr128 impure recursive module subroutine from_file_4dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr64 impure recursive module subroutine from_file_4dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr32 impure recursive module subroutine from_file_5dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr128 impure recursive module subroutine from_file_5dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr64 impure recursive module subroutine from_file_5dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr32 impure recursive module subroutine from_file_6dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr128 impure recursive module subroutine from_file_6dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr64 impure recursive module subroutine from_file_6dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr32 impure recursive module subroutine from_file_7dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr128 impure recursive module subroutine from_file_7dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr64 impure recursive module subroutine from_file_7dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr32 impure recursive module subroutine from_file_8dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr128 impure recursive module subroutine from_file_8dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr64 impure recursive module subroutine from_file_8dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr32 impure recursive module subroutine from_file_9dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr128 impure recursive module subroutine from_file_9dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr64 impure recursive module subroutine from_file_9dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr32 impure recursive module subroutine from_file_10dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr128 impure recursive module subroutine from_file_10dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr64 impure recursive module subroutine from_file_10dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr32 impure recursive module subroutine from_file_11dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr128 impure recursive module subroutine from_file_11dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr64 impure recursive module subroutine from_file_11dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr32 impure recursive module subroutine from_file_12dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr128 impure recursive module subroutine from_file_12dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr64 impure recursive module subroutine from_file_12dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr32 impure recursive module subroutine from_file_13dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr128 impure recursive module subroutine from_file_13dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr64 impure recursive module subroutine from_file_13dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr32 impure recursive module subroutine from_file_14dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr128 impure recursive module subroutine from_file_14dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr64 impure recursive module subroutine from_file_14dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr32 impure recursive module subroutine from_file_15dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr128 impure recursive module subroutine from_file_15dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr64 impure recursive module subroutine from_file_15dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr32 impure recursive module subroutine from_textfile_1di64 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di64 impure recursive module subroutine from_binaryfile_1di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di64 impure recursive module subroutine from_textfile_1di32 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di32 impure recursive module subroutine from_binaryfile_1di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di32 impure recursive module subroutine from_textfile_1di16 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di16 impure recursive module subroutine from_binaryfile_1di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di16 impure recursive module subroutine from_textfile_1di8 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di8 impure recursive module subroutine from_binaryfile_1di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di8 impure recursive module subroutine from_textfile_2di64 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di64 impure recursive module subroutine from_binaryfile_2di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di64 impure recursive module subroutine from_textfile_2di32 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di32 impure recursive module subroutine from_binaryfile_2di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di32 impure recursive module subroutine from_textfile_2di16 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di16 impure recursive module subroutine from_binaryfile_2di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di16 impure recursive module subroutine from_textfile_2di8 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di8 impure recursive module subroutine from_binaryfile_2di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di8 impure recursive module subroutine from_file_3di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di64 impure recursive module subroutine from_file_3di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di32 impure recursive module subroutine from_file_3di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di16 impure recursive module subroutine from_file_3di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di8 impure recursive module subroutine from_file_4di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di64 impure recursive module subroutine from_file_4di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di32 impure recursive module subroutine from_file_4di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di16 impure recursive module subroutine from_file_4di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di8 impure recursive module subroutine from_file_5di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di64 impure recursive module subroutine from_file_5di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di32 impure recursive module subroutine from_file_5di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di16 impure recursive module subroutine from_file_5di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di8 impure recursive module subroutine from_file_6di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di64 impure recursive module subroutine from_file_6di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di32 impure recursive module subroutine from_file_6di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di16 impure recursive module subroutine from_file_6di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di8 impure recursive module subroutine from_file_7di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di64 impure recursive module subroutine from_file_7di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di32 impure recursive module subroutine from_file_7di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di16 impure recursive module subroutine from_file_7di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di8 impure recursive module subroutine from_file_8di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di64 impure recursive module subroutine from_file_8di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di32 impure recursive module subroutine from_file_8di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di16 impure recursive module subroutine from_file_8di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di8 impure recursive module subroutine from_file_9di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di64 impure recursive module subroutine from_file_9di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di32 impure recursive module subroutine from_file_9di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di16 impure recursive module subroutine from_file_9di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di8 impure recursive module subroutine from_file_10di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di64 impure recursive module subroutine from_file_10di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di32 impure recursive module subroutine from_file_10di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di16 impure recursive module subroutine from_file_10di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di8 impure recursive module subroutine from_file_11di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di64 impure recursive module subroutine from_file_11di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di32 impure recursive module subroutine from_file_11di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di16 impure recursive module subroutine from_file_11di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di8 impure recursive module subroutine from_file_12di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di64 impure recursive module subroutine from_file_12di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di32 impure recursive module subroutine from_file_12di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di16 impure recursive module subroutine from_file_12di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di8 impure recursive module subroutine from_file_13di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di64 impure recursive module subroutine from_file_13di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di32 impure recursive module subroutine from_file_13di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di16 impure recursive module subroutine from_file_13di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di8 impure recursive module subroutine from_file_14di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di64 impure recursive module subroutine from_file_14di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di32 impure recursive module subroutine from_file_14di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di16 impure recursive module subroutine from_file_14di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di8 impure recursive module subroutine from_file_15di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di64 impure recursive module subroutine from_file_15di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di32 impure recursive module subroutine from_file_15di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di16 impure recursive module subroutine from_file_15di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di8 end interface interface echo ! Submodule text_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for writing a string to an external file. !! !! The file `file_name` will be created if it does not already exist and will be overwritten if `append` is !! `.false.` (if it already exists), with a new line always being inserted at the end of `string`. !! !! For a user reference, see [echo](../page/Ref/echo.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine echo_string ( string , file_name , append ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: file_name logical , optional , intent ( in ) :: append end subroutine echo_string end interface interface to_text ! Submodule text_io !! Private interface for writing an array to an external text file. impure recursive module subroutine to_text_1dc128 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc128 impure recursive module subroutine to_text_1dc64 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc64 impure recursive module subroutine to_text_1dc32 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc32 impure recursive module subroutine to_text_2dc128 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc128 impure recursive module subroutine to_text_2dc64 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc64 impure recursive module subroutine to_text_2dc32 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc32 impure recursive module subroutine to_text_1dr128 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr128 impure recursive module subroutine to_text_1dr64 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr64 impure recursive module subroutine to_text_1dr32 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr32 impure recursive module subroutine to_text_2dr128 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr128 impure recursive module subroutine to_text_2dr64 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr64 impure recursive module subroutine to_text_2dr32 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr32 impure recursive module subroutine to_text_1di64 ( x , file_name , header , dim , delim , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di64 impure recursive module subroutine to_text_1di32 ( x , file_name , header , dim , delim , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di32 impure recursive module subroutine to_text_1di16 ( x , file_name , header , dim , delim , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di16 impure recursive module subroutine to_text_1di8 ( x , file_name , header , dim , delim , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di8 impure recursive module subroutine to_text_2di64 ( x , file_name , header , delim , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di64 impure recursive module subroutine to_text_2di32 ( x , file_name , header , delim , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di32 impure recursive module subroutine to_text_2di16 ( x , file_name , header , delim , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di16 impure recursive module subroutine to_text_2di8 ( x , file_name , header , delim , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di8 end interface interface from_text ! Submodule text_io !! Private interface for reading an external text file into an array. impure recursive module subroutine from_text_1dc128 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc128 impure recursive module subroutine from_text_1dc64 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc64 impure recursive module subroutine from_text_1dc32 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc32 impure recursive module subroutine from_text_2dc128 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc128 impure recursive module subroutine from_text_2dc64 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc64 impure recursive module subroutine from_text_2dc32 ( file_name , into , header , locale , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc32 impure recursive module subroutine from_text_1dr128 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr128 impure recursive module subroutine from_text_1dr64 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr64 impure recursive module subroutine from_text_1dr32 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr32 impure recursive module subroutine from_text_2dr128 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr128 impure recursive module subroutine from_text_2dr64 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr64 impure recursive module subroutine from_text_2dr32 ( file_name , into , header , locale , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr32 impure recursive module subroutine from_text_1di64 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di64 impure recursive module subroutine from_text_1di32 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di32 impure recursive module subroutine from_text_1di16 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di16 impure recursive module subroutine from_text_1di8 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di8 impure recursive module subroutine from_text_2di64 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di64 impure recursive module subroutine from_text_2di32 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di32 impure recursive module subroutine from_text_2di16 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di16 impure recursive module subroutine from_text_2di8 ( file_name , into , header , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di8 end interface interface to_binary ! Submodule binary_io !! Private interface for writing an array to an external binary file. impure recursive module subroutine to_binary_1dc128 ( x , file_name ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc128 impure recursive module subroutine to_binary_1dc64 ( x , file_name ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc64 impure recursive module subroutine to_binary_1dc32 ( x , file_name ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc32 impure recursive module subroutine to_binary_2dc128 ( x , file_name ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc128 impure recursive module subroutine to_binary_2dc64 ( x , file_name ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc64 impure recursive module subroutine to_binary_2dc32 ( x , file_name ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc32 impure recursive module subroutine to_binary_3dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc128 impure recursive module subroutine to_binary_3dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc64 impure recursive module subroutine to_binary_3dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc32 impure recursive module subroutine to_binary_4dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc128 impure recursive module subroutine to_binary_4dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc64 impure recursive module subroutine to_binary_4dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc32 impure recursive module subroutine to_binary_5dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc128 impure recursive module subroutine to_binary_5dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc64 impure recursive module subroutine to_binary_5dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc32 impure recursive module subroutine to_binary_6dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc128 impure recursive module subroutine to_binary_6dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc64 impure recursive module subroutine to_binary_6dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc32 impure recursive module subroutine to_binary_7dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc128 impure recursive module subroutine to_binary_7dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc64 impure recursive module subroutine to_binary_7dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc32 impure recursive module subroutine to_binary_8dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc128 impure recursive module subroutine to_binary_8dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc64 impure recursive module subroutine to_binary_8dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc32 impure recursive module subroutine to_binary_9dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc128 impure recursive module subroutine to_binary_9dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc64 impure recursive module subroutine to_binary_9dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc32 impure recursive module subroutine to_binary_10dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc128 impure recursive module subroutine to_binary_10dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc64 impure recursive module subroutine to_binary_10dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc32 impure recursive module subroutine to_binary_11dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc128 impure recursive module subroutine to_binary_11dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc64 impure recursive module subroutine to_binary_11dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc32 impure recursive module subroutine to_binary_12dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc128 impure recursive module subroutine to_binary_12dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc64 impure recursive module subroutine to_binary_12dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc32 impure recursive module subroutine to_binary_13dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc128 impure recursive module subroutine to_binary_13dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc64 impure recursive module subroutine to_binary_13dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc32 impure recursive module subroutine to_binary_14dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc128 impure recursive module subroutine to_binary_14dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc64 impure recursive module subroutine to_binary_14dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc32 impure recursive module subroutine to_binary_15dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc128 impure recursive module subroutine to_binary_15dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc64 impure recursive module subroutine to_binary_15dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc32 impure recursive module subroutine to_binary_1dr128 ( x , file_name ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr128 impure recursive module subroutine to_binary_1dr64 ( x , file_name ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr64 impure recursive module subroutine to_binary_1dr32 ( x , file_name ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr32 impure recursive module subroutine to_binary_2dr128 ( x , file_name ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr128 impure recursive module subroutine to_binary_2dr64 ( x , file_name ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr64 impure recursive module subroutine to_binary_2dr32 ( x , file_name ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr32 impure recursive module subroutine to_binary_3dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr128 impure recursive module subroutine to_binary_3dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr64 impure recursive module subroutine to_binary_3dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr32 impure recursive module subroutine to_binary_4dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr128 impure recursive module subroutine to_binary_4dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr64 impure recursive module subroutine to_binary_4dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr32 impure recursive module subroutine to_binary_5dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr128 impure recursive module subroutine to_binary_5dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr64 impure recursive module subroutine to_binary_5dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr32 impure recursive module subroutine to_binary_6dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr128 impure recursive module subroutine to_binary_6dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr64 impure recursive module subroutine to_binary_6dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr32 impure recursive module subroutine to_binary_7dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr128 impure recursive module subroutine to_binary_7dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr64 impure recursive module subroutine to_binary_7dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr32 impure recursive module subroutine to_binary_8dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr128 impure recursive module subroutine to_binary_8dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr64 impure recursive module subroutine to_binary_8dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr32 impure recursive module subroutine to_binary_9dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr128 impure recursive module subroutine to_binary_9dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr64 impure recursive module subroutine to_binary_9dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr32 impure recursive module subroutine to_binary_10dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr128 impure recursive module subroutine to_binary_10dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr64 impure recursive module subroutine to_binary_10dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr32 impure recursive module subroutine to_binary_11dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr128 impure recursive module subroutine to_binary_11dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr64 impure recursive module subroutine to_binary_11dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr32 impure recursive module subroutine to_binary_12dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr128 impure recursive module subroutine to_binary_12dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr64 impure recursive module subroutine to_binary_12dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr32 impure recursive module subroutine to_binary_13dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr128 impure recursive module subroutine to_binary_13dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr64 impure recursive module subroutine to_binary_13dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr32 impure recursive module subroutine to_binary_14dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr128 impure recursive module subroutine to_binary_14dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr64 impure recursive module subroutine to_binary_14dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr32 impure recursive module subroutine to_binary_15dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr128 impure recursive module subroutine to_binary_15dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr64 impure recursive module subroutine to_binary_15dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr32 impure recursive module subroutine to_binary_1di64 ( x , file_name ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di64 impure recursive module subroutine to_binary_1di32 ( x , file_name ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di32 impure recursive module subroutine to_binary_1di16 ( x , file_name ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di16 impure recursive module subroutine to_binary_1di8 ( x , file_name ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di8 impure recursive module subroutine to_binary_2di64 ( x , file_name ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di64 impure recursive module subroutine to_binary_2di32 ( x , file_name ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di32 impure recursive module subroutine to_binary_2di16 ( x , file_name ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di16 impure recursive module subroutine to_binary_2di8 ( x , file_name ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di8 impure recursive module subroutine to_binary_3di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di64 impure recursive module subroutine to_binary_3di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di32 impure recursive module subroutine to_binary_3di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di16 impure recursive module subroutine to_binary_3di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di8 impure recursive module subroutine to_binary_4di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di64 impure recursive module subroutine to_binary_4di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di32 impure recursive module subroutine to_binary_4di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di16 impure recursive module subroutine to_binary_4di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di8 impure recursive module subroutine to_binary_5di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di64 impure recursive module subroutine to_binary_5di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di32 impure recursive module subroutine to_binary_5di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di16 impure recursive module subroutine to_binary_5di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di8 impure recursive module subroutine to_binary_6di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di64 impure recursive module subroutine to_binary_6di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di32 impure recursive module subroutine to_binary_6di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di16 impure recursive module subroutine to_binary_6di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di8 impure recursive module subroutine to_binary_7di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di64 impure recursive module subroutine to_binary_7di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di32 impure recursive module subroutine to_binary_7di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di16 impure recursive module subroutine to_binary_7di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di8 impure recursive module subroutine to_binary_8di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di64 impure recursive module subroutine to_binary_8di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di32 impure recursive module subroutine to_binary_8di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di16 impure recursive module subroutine to_binary_8di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di8 impure recursive module subroutine to_binary_9di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di64 impure recursive module subroutine to_binary_9di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di32 impure recursive module subroutine to_binary_9di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di16 impure recursive module subroutine to_binary_9di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di8 impure recursive module subroutine to_binary_10di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di64 impure recursive module subroutine to_binary_10di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di32 impure recursive module subroutine to_binary_10di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di16 impure recursive module subroutine to_binary_10di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di8 impure recursive module subroutine to_binary_11di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di64 impure recursive module subroutine to_binary_11di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di32 impure recursive module subroutine to_binary_11di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di16 impure recursive module subroutine to_binary_11di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di8 impure recursive module subroutine to_binary_12di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di64 impure recursive module subroutine to_binary_12di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di32 impure recursive module subroutine to_binary_12di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di16 impure recursive module subroutine to_binary_12di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di8 impure recursive module subroutine to_binary_13di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di64 impure recursive module subroutine to_binary_13di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di32 impure recursive module subroutine to_binary_13di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di16 impure recursive module subroutine to_binary_13di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di8 impure recursive module subroutine to_binary_14di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di64 impure recursive module subroutine to_binary_14di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di32 impure recursive module subroutine to_binary_14di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di16 impure recursive module subroutine to_binary_14di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di8 impure recursive module subroutine to_binary_15di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di64 impure recursive module subroutine to_binary_15di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di32 impure recursive module subroutine to_binary_15di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di16 impure recursive module subroutine to_binary_15di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di8 end interface interface from_binary ! Submodule binary_io !! Private interface for reading an external binary file into an array. impure recursive module subroutine from_binary_1dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc128 impure recursive module subroutine from_binary_1dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc64 impure recursive module subroutine from_binary_1dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc32 impure recursive module subroutine from_binary_2dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc128 impure recursive module subroutine from_binary_2dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc64 impure recursive module subroutine from_binary_2dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc32 impure recursive module subroutine from_binary_3dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc128 impure recursive module subroutine from_binary_3dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc64 impure recursive module subroutine from_binary_3dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc32 impure recursive module subroutine from_binary_4dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc128 impure recursive module subroutine from_binary_4dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc64 impure recursive module subroutine from_binary_4dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc32 impure recursive module subroutine from_binary_5dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc128 impure recursive module subroutine from_binary_5dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc64 impure recursive module subroutine from_binary_5dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc32 impure recursive module subroutine from_binary_6dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc128 impure recursive module subroutine from_binary_6dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc64 impure recursive module subroutine from_binary_6dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc32 impure recursive module subroutine from_binary_7dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc128 impure recursive module subroutine from_binary_7dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc64 impure recursive module subroutine from_binary_7dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc32 impure recursive module subroutine from_binary_8dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc128 impure recursive module subroutine from_binary_8dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc64 impure recursive module subroutine from_binary_8dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc32 impure recursive module subroutine from_binary_9dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc128 impure recursive module subroutine from_binary_9dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc64 impure recursive module subroutine from_binary_9dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc32 impure recursive module subroutine from_binary_10dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc128 impure recursive module subroutine from_binary_10dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc64 impure recursive module subroutine from_binary_10dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc32 impure recursive module subroutine from_binary_11dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc128 impure recursive module subroutine from_binary_11dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc64 impure recursive module subroutine from_binary_11dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc32 impure recursive module subroutine from_binary_12dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc128 impure recursive module subroutine from_binary_12dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc64 impure recursive module subroutine from_binary_12dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc32 impure recursive module subroutine from_binary_13dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc128 impure recursive module subroutine from_binary_13dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc64 impure recursive module subroutine from_binary_13dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc32 impure recursive module subroutine from_binary_14dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc128 impure recursive module subroutine from_binary_14dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc64 impure recursive module subroutine from_binary_14dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc32 impure recursive module subroutine from_binary_15dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc128 impure recursive module subroutine from_binary_15dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc64 impure recursive module subroutine from_binary_15dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc32 impure recursive module subroutine from_binary_1dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr128 impure recursive module subroutine from_binary_1dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr64 impure recursive module subroutine from_binary_1dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr32 impure recursive module subroutine from_binary_2dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr128 impure recursive module subroutine from_binary_2dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr64 impure recursive module subroutine from_binary_2dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr32 impure recursive module subroutine from_binary_3dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr128 impure recursive module subroutine from_binary_3dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr64 impure recursive module subroutine from_binary_3dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr32 impure recursive module subroutine from_binary_4dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr128 impure recursive module subroutine from_binary_4dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr64 impure recursive module subroutine from_binary_4dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr32 impure recursive module subroutine from_binary_5dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr128 impure recursive module subroutine from_binary_5dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr64 impure recursive module subroutine from_binary_5dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr32 impure recursive module subroutine from_binary_6dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr128 impure recursive module subroutine from_binary_6dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr64 impure recursive module subroutine from_binary_6dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr32 impure recursive module subroutine from_binary_7dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr128 impure recursive module subroutine from_binary_7dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr64 impure recursive module subroutine from_binary_7dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr32 impure recursive module subroutine from_binary_8dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr128 impure recursive module subroutine from_binary_8dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr64 impure recursive module subroutine from_binary_8dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr32 impure recursive module subroutine from_binary_9dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr128 impure recursive module subroutine from_binary_9dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr64 impure recursive module subroutine from_binary_9dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr32 impure recursive module subroutine from_binary_10dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr128 impure recursive module subroutine from_binary_10dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr64 impure recursive module subroutine from_binary_10dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr32 impure recursive module subroutine from_binary_11dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr128 impure recursive module subroutine from_binary_11dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr64 impure recursive module subroutine from_binary_11dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr32 impure recursive module subroutine from_binary_12dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr128 impure recursive module subroutine from_binary_12dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr64 impure recursive module subroutine from_binary_12dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr32 impure recursive module subroutine from_binary_13dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr128 impure recursive module subroutine from_binary_13dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr64 impure recursive module subroutine from_binary_13dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr32 impure recursive module subroutine from_binary_14dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr128 impure recursive module subroutine from_binary_14dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr64 impure recursive module subroutine from_binary_14dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr32 impure recursive module subroutine from_binary_15dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr128 impure recursive module subroutine from_binary_15dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr64 impure recursive module subroutine from_binary_15dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr32 impure recursive module subroutine from_binary_1di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di64 impure recursive module subroutine from_binary_1di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di32 impure recursive module subroutine from_binary_1di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di16 impure recursive module subroutine from_binary_1di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di8 impure recursive module subroutine from_binary_2di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di64 impure recursive module subroutine from_binary_2di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di32 impure recursive module subroutine from_binary_2di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di16 impure recursive module subroutine from_binary_2di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di8 impure recursive module subroutine from_binary_3di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di64 impure recursive module subroutine from_binary_3di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di32 impure recursive module subroutine from_binary_3di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di16 impure recursive module subroutine from_binary_3di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di8 impure recursive module subroutine from_binary_4di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di64 impure recursive module subroutine from_binary_4di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di32 impure recursive module subroutine from_binary_4di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di16 impure recursive module subroutine from_binary_4di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di8 impure recursive module subroutine from_binary_5di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di64 impure recursive module subroutine from_binary_5di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di32 impure recursive module subroutine from_binary_5di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di16 impure recursive module subroutine from_binary_5di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di8 impure recursive module subroutine from_binary_6di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di64 impure recursive module subroutine from_binary_6di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di32 impure recursive module subroutine from_binary_6di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di16 impure recursive module subroutine from_binary_6di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di8 impure recursive module subroutine from_binary_7di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di64 impure recursive module subroutine from_binary_7di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di32 impure recursive module subroutine from_binary_7di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di16 impure recursive module subroutine from_binary_7di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di8 impure recursive module subroutine from_binary_8di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di64 impure recursive module subroutine from_binary_8di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di32 impure recursive module subroutine from_binary_8di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di16 impure recursive module subroutine from_binary_8di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di8 impure recursive module subroutine from_binary_9di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di64 impure recursive module subroutine from_binary_9di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di32 impure recursive module subroutine from_binary_9di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di16 impure recursive module subroutine from_binary_9di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di8 impure recursive module subroutine from_binary_10di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di64 impure recursive module subroutine from_binary_10di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di32 impure recursive module subroutine from_binary_10di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di16 impure recursive module subroutine from_binary_10di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di8 impure recursive module subroutine from_binary_11di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di64 impure recursive module subroutine from_binary_11di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di32 impure recursive module subroutine from_binary_11di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di16 impure recursive module subroutine from_binary_11di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di8 impure recursive module subroutine from_binary_12di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di64 impure recursive module subroutine from_binary_12di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di32 impure recursive module subroutine from_binary_12di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di16 impure recursive module subroutine from_binary_12di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di8 impure recursive module subroutine from_binary_13di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di64 impure recursive module subroutine from_binary_13di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di32 impure recursive module subroutine from_binary_13di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di16 impure recursive module subroutine from_binary_13di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di8 impure recursive module subroutine from_binary_14di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di64 impure recursive module subroutine from_binary_14di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di32 impure recursive module subroutine from_binary_14di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di16 impure recursive module subroutine from_binary_14di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di8 impure recursive module subroutine from_binary_15di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di64 impure recursive module subroutine from_binary_15di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di32 impure recursive module subroutine from_binary_15di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di16 impure recursive module subroutine from_binary_15di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di8 end interface contains pure recursive function ext_of ( file_name ) result ( ext ) !! Function for parsing a file name for an extension character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: ext integer :: i , l l = len_trim ( file_name ) do i = l , 1 , - 1 if ( file_name ( i : i ) == '.' ) exit end do if ( i > 0 ) then ext = trim ( adjustl ( file_name ( i + 1 : l ))) else ext = '' end if end function ext_of pure recursive function to_str ( x , delim , trimstring ) result ( x_str ) !! Function for accumulating vector of strings into a single string with specified delimiter character ( len =* ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: delim logical , intent ( in ), optional :: trimstring character ( len = :), allocatable :: x_str logical :: trimstring_ integer :: i if ( . not . present ( trimstring ) ) then trimstring_ = . true . else trimstring_ = trimstring end if if ( trimstring_ ) then x_str = '' do i = 1 , size ( x ) - 1 x_str = x_str // trim ( adjustl ( x ( i ))) // delim end do x_str = x_str // trim ( adjustl ( x ( size ( x )))) else x_str = '' do i = 1 , size ( x ) - 1 x_str = x_str // adjustr ( x ( i )) // delim end do x_str = x_str // adjustr ( x ( size ( x ))) end if end function to_str end module io_fortran_lib submodule ( io_fortran_lib ) array_printing !! This submodule provides module procedure implementations for the **public interface** `aprint`. contains module procedure aprint_1dc128 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc128 module procedure aprint_1dc64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc64 module procedure aprint_1dc32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc32 module procedure aprint_2dc128 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc128 module procedure aprint_2dc64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc64 module procedure aprint_2dc32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc32 module procedure aprint_1dr128 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr128 module procedure aprint_1dr64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr64 module procedure aprint_1dr32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr32 module procedure aprint_2dr128 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr128 module procedure aprint_2dr64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr64 module procedure aprint_2dr32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing real array. Aborting...' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr32 module procedure aprint_1di64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di64 module procedure aprint_1di32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di32 module procedure aprint_1di16 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di16 module procedure aprint_1di8 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di8 module procedure aprint_2di64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di64 module procedure aprint_2di32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di32 module procedure aprint_2di16 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di16 module procedure aprint_2di8 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else write ( * , '(a)' ) nl // 'WARNING: Unknown format \"' // fmt // '\" for printing integer array. Aborting...' return end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di8 module procedure aprint_1dchar integer :: i write ( unit =* , fmt = '(a)' ) nl // '   ┣ ' // adjustr ( x ( lbound ( x , dim = 1 ))) // ' ┫' if ( size ( x ) == 1 ) return if ( size ( x ) > 2 ) then do i = lbound ( x , dim = 1 ) + 1 , ubound ( x , dim = 1 ) - 1 write ( unit =* , fmt = '(a)' ) '   ┃ ' // adjustr ( x ( i )) // ' ┃' end do end if write ( unit =* , fmt = '(a)' ) '   ┣ ' // adjustr ( x ( ubound ( x , dim = 1 ))) // ' ┫' // nl end procedure aprint_1dchar module procedure aprint_2dchar integer :: i write ( unit =* , fmt = '(a)' ) nl // '   ┣ ' // to_str ( x ( lbound ( x , dim = 1 ),:), delim = ' ' , trimstring = . false .) // ' ┫' if ( size ( x , dim = 1 ) == 1 ) return if ( size ( x , dim = 1 ) > 2 ) then do i = lbound ( x , dim = 1 ) + 1 , ubound ( x , dim = 1 ) - 1 write ( unit =* , fmt = '(a)' ) '   ┃ ' // to_str ( x ( i ,:), delim = ' ' , trimstring = . false .) // ' ┃' end do end if write ( unit =* , fmt = '(a)' ) '   ┣ ' // to_str ( x ( ubound ( x , dim = 1 ),:), delim = ' ' , trimstring = . false .) // ' ┫' // nl end procedure aprint_2dchar module procedure aprint_1dString integer :: i , max_length character ( len = :), allocatable , dimension (:) :: char_arr max_length = 0 do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( len ( x ( i )% s ) > max_length ) max_length = len ( x ( i )% s ) end do allocate ( character ( len = max_length ) :: char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) char_arr ( i ) = x ( i )% s end do call aprint ( char_arr ) end procedure aprint_1dString module procedure aprint_2dString integer :: i , j , max_length character ( len = :), allocatable , dimension (:,:) :: char_arr max_length = 0 do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( len ( x ( i , j )% s ) > max_length ) max_length = len ( x ( i , j )% s ) end do end do allocate ( character ( len = max_length ) :: & char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) char_arr ( i , j ) = x ( i , j )% s end do call aprint ( char_arr ) end procedure aprint_2dString end submodule array_printing submodule ( io_fortran_lib ) internal_io !! This submodule provides module procedure implementations for the **public interface** `str`. contains module procedure str_c128 character ( len = :), allocatable :: locale_ , fmt_ , im_ , sep integer :: decimals_ if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if if ( im_ == '' ) then if ( locale_ == 'US' ) then sep = ',' else sep = ';' end if x_str = '(' // str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // sep // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // ')' else if ( fmt_ == 'z' ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else if ( x % im < 0 ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '-' // & str ( abs ( x % im ), locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ end if end if end if end procedure str_c128 module procedure str_c64 character ( len = :), allocatable :: locale_ , fmt_ , im_ , sep integer :: decimals_ if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if if ( im_ == '' ) then if ( locale_ == 'US' ) then sep = ',' else sep = ';' end if x_str = '(' // str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // sep // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // ')' else if ( fmt_ == 'z' ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else if ( x % im < 0 ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '-' // & str ( abs ( x % im ), locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ end if end if end if end procedure str_c64 module procedure str_c32 character ( len = :), allocatable :: locale_ , fmt_ , im_ , sep integer :: decimals_ if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if if ( im_ == '' ) then if ( locale_ == 'US' ) then sep = ',' else sep = ';' end if x_str = '(' // str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // sep // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // ')' else if ( fmt_ == 'z' ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else if ( x % im < 0 ) then x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '-' // & str ( abs ( x % im ), locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ else x_str = str ( x % re , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // '+' // & str ( x % im , locale = locale_ , fmt = fmt_ , decimals = decimals_ ) // im_ end if end if end if end procedure str_c32 module procedure str_r128 character ( len = :), allocatable :: decimal , fmt_ , str_tmp integer :: i , e , max_decimals , decimals_ , l , extra if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'e' ) then associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( . not . present ( decimals ) ) then decimals_ = max_precision - 1 else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > ( max_precision - 1 ) ) then decimals_ = max_precision - 1 else decimals_ = decimals end if end if end associate l = decimals_ + 15 allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(es' // str ( l ) // '.' // str ( decimals_ ) // 'e4)' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x ))) else e = 0 end if associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( e == 0 ) then if ( floor ( x ) == 0 ) then max_decimals = max_precision else max_decimals = max_precision - 1 e = 1 + e end if else if ( e > 0 ) then max_decimals = max_precision - ( 1 + e ) e = 1 + e else max_decimals = max_precision - e end if extra = e - max_precision end associate if ( max_decimals < 0 ) max_decimals = 0 if ( . not . present ( decimals ) ) then decimals_ = max_decimals else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > max_decimals ) then decimals_ = max_decimals else decimals_ = decimals end if end if if ( e > 0 ) then l = decimals_ + e + 10 else l = decimals_ + 10 end if allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(f' // str ( l ) // '.' // str ( decimals_ ) // ')' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) if ( extra > 0 ) then do i = len ( x_str ) - 1 , 1 , - 1 x_str ( i : i ) = '0' extra = extra - 1 if ( extra == 0 ) exit end do end if else if ( fmt_ == 'z' ) then allocate ( character ( len = 70 ) :: str_tmp ) write ( unit = str_tmp , fmt = '(z70)' ) x x_str = trim ( adjustl ( str_tmp )) end if end procedure str_r128 module procedure str_r64 character ( len = :), allocatable :: decimal , fmt_ , str_tmp integer :: i , e , max_decimals , decimals_ , l , extra if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'e' ) then associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( . not . present ( decimals ) ) then decimals_ = max_precision - 1 else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > ( max_precision - 1 ) ) then decimals_ = max_precision - 1 else decimals_ = decimals end if end if end associate l = decimals_ + 15 allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(es' // str ( l ) // '.' // str ( decimals_ ) // 'e3)' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x ))) else e = 0 end if associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( e == 0 ) then if ( floor ( x ) == 0 ) then max_decimals = max_precision else max_decimals = max_precision - 1 e = 1 + e end if else if ( e > 0 ) then max_decimals = max_precision - ( 1 + e ) e = 1 + e else max_decimals = max_precision - e end if extra = e - max_precision end associate if ( max_decimals < 0 ) max_decimals = 0 if ( . not . present ( decimals ) ) then decimals_ = max_decimals else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > max_decimals ) then decimals_ = max_decimals else decimals_ = decimals end if end if if ( e > 0 ) then l = decimals_ + e + 10 else l = decimals_ + 10 end if allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(f' // str ( l ) // '.' // str ( decimals_ ) // ')' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) if ( extra > 0 ) then do i = len ( x_str ) - 1 , 1 , - 1 x_str ( i : i ) = '0' extra = extra - 1 if ( extra == 0 ) exit end do end if else if ( fmt_ == 'z' ) then allocate ( character ( len = 40 ) :: str_tmp ) write ( unit = str_tmp , fmt = '(z40)' ) x x_str = trim ( adjustl ( str_tmp )) end if end procedure str_r64 module procedure str_r32 character ( len = :), allocatable :: decimal , fmt_ , str_tmp integer :: i , e , max_decimals , decimals_ , l , extra if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = '' return end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'e' ) then associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( . not . present ( decimals ) ) then decimals_ = max_precision - 1 else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > ( max_precision - 1 ) ) then decimals_ = max_precision - 1 else decimals_ = decimals end if end if end associate l = decimals_ + 15 allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(es' // str ( l ) // '.' // str ( decimals_ ) // 'e2)' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x ))) else e = 0 end if associate ( max_precision => ceiling ( 1.0 + log10 ( real ( radix ( x ))) * digits ( x ) ) ) if ( e == 0 ) then if ( floor ( x ) == 0 ) then max_decimals = max_precision else max_decimals = max_precision - 1 e = 1 + e end if else if ( e > 0 ) then max_decimals = max_precision - ( 1 + e ) e = 1 + e else max_decimals = max_precision - e end if extra = e - max_precision end associate if ( max_decimals < 0 ) max_decimals = 0 if ( . not . present ( decimals ) ) then decimals_ = max_decimals else if ( decimals < 0 ) then decimals_ = 0 else if ( decimals > max_decimals ) then decimals_ = max_decimals else decimals_ = decimals end if end if if ( e > 0 ) then l = decimals_ + e + 10 else l = decimals_ + 10 end if allocate ( character ( len = l ) :: str_tmp ) write ( unit = str_tmp , fmt = '(f' // str ( l ) // '.' // str ( decimals_ ) // ')' , decimal = decimal ) x x_str = trim ( adjustl ( str_tmp )) if ( extra > 0 ) then do i = len ( x_str ) - 1 , 1 , - 1 x_str ( i : i ) = '0' extra = extra - 1 if ( extra == 0 ) exit end do end if else if ( fmt_ == 'z' ) then allocate ( character ( len = 25 ) :: str_tmp ) write ( unit = str_tmp , fmt = '(z25)' ) x x_str = trim ( adjustl ( str_tmp )) end if end procedure str_r32 module procedure str_i64 character ( len = :), allocatable :: fmt_ character ( len = 40 ) :: str_tmp if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'i' ) then write ( unit = str_tmp , fmt = '(i40)' ) x else if ( fmt_ == 'z' ) then write ( unit = str_tmp , fmt = '(z40)' ) x end if x_str = trim ( adjustl ( str_tmp )) end procedure str_i64 module procedure str_i32 character ( len = :), allocatable :: fmt_ character ( len = 25 ) :: str_tmp if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'i' ) then write ( unit = str_tmp , fmt = '(i25)' ) x else if ( fmt_ == 'z' ) then write ( unit = str_tmp , fmt = '(z25)' ) x end if x_str = trim ( adjustl ( str_tmp )) end procedure str_i32 module procedure str_i16 character ( len = :), allocatable :: fmt_ character ( len = 15 ) :: str_tmp if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'i' ) then write ( unit = str_tmp , fmt = '(i15)' ) x else if ( fmt_ == 'z' ) then write ( unit = str_tmp , fmt = '(z15)' ) x end if x_str = trim ( adjustl ( str_tmp )) end procedure str_i16 module procedure str_i8 character ( len = :), allocatable :: fmt_ character ( len = 10 ) :: str_tmp if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else x_str = '' return end if end if if ( fmt_ == 'i' ) then write ( unit = str_tmp , fmt = '(i10)' ) x else if ( fmt_ == 'z' ) then write ( unit = str_tmp , fmt = '(z10)' ) x end if x_str = trim ( adjustl ( str_tmp )) end procedure str_i8 end submodule internal_io submodule ( io_fortran_lib ) file_io !! This submodule provides module procedure implementations for the **public interfaces** `to_file` and !! `from_file`. contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_file_1dc128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dc128 module procedure to_file_1dc64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dc64 module procedure to_file_1dc32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dc32 module procedure to_file_2dc128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dc128 module procedure to_file_2dc64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dc64 module procedure to_file_2dc32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = '' else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) nl // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dc32 module procedure to_file_3dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dc128 module procedure to_file_3dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dc64 module procedure to_file_3dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dc32 module procedure to_file_4dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dc128 module procedure to_file_4dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dc64 module procedure to_file_4dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dc32 module procedure to_file_5dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dc128 module procedure to_file_5dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dc64 module procedure to_file_5dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dc32 module procedure to_file_6dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dc128 module procedure to_file_6dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dc64 module procedure to_file_6dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dc32 module procedure to_file_7dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dc128 module procedure to_file_7dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dc64 module procedure to_file_7dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dc32 module procedure to_file_8dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dc128 module procedure to_file_8dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dc64 module procedure to_file_8dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dc32 module procedure to_file_9dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dc128 module procedure to_file_9dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dc64 module procedure to_file_9dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dc32 module procedure to_file_10dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dc128 module procedure to_file_10dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dc64 module procedure to_file_10dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dc32 module procedure to_file_11dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dc128 module procedure to_file_11dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dc64 module procedure to_file_11dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dc32 module procedure to_file_12dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dc128 module procedure to_file_12dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dc64 module procedure to_file_12dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dc32 module procedure to_file_13dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dc128 module procedure to_file_13dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dc64 module procedure to_file_13dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dc32 module procedure to_file_14dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dc128 module procedure to_file_14dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dc64 module procedure to_file_14dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dc32 module procedure to_file_15dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dc128 module procedure to_file_15dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dc64 module procedure to_file_15dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dc32 module procedure to_file_1dr128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dr128 module procedure to_file_1dr64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dr64 module procedure to_file_1dr32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1dr32 module procedure to_file_2dr128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dr128 module procedure to_file_2dr64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dr64 module procedure to_file_2dr32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) nl // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = ',' else delim_ = ';' end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) nl // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) nl // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2dr32 module procedure to_file_3dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dr128 module procedure to_file_3dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dr64 module procedure to_file_3dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3dr32 module procedure to_file_4dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dr128 module procedure to_file_4dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dr64 module procedure to_file_4dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4dr32 module procedure to_file_5dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dr128 module procedure to_file_5dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dr64 module procedure to_file_5dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5dr32 module procedure to_file_6dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dr128 module procedure to_file_6dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dr64 module procedure to_file_6dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6dr32 module procedure to_file_7dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dr128 module procedure to_file_7dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dr64 module procedure to_file_7dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7dr32 module procedure to_file_8dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dr128 module procedure to_file_8dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dr64 module procedure to_file_8dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8dr32 module procedure to_file_9dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dr128 module procedure to_file_9dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dr64 module procedure to_file_9dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9dr32 module procedure to_file_10dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dr128 module procedure to_file_10dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dr64 module procedure to_file_10dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10dr32 module procedure to_file_11dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dr128 module procedure to_file_11dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dr64 module procedure to_file_11dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11dr32 module procedure to_file_12dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dr128 module procedure to_file_12dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dr64 module procedure to_file_12dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12dr32 module procedure to_file_13dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dr128 module procedure to_file_13dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dr64 module procedure to_file_13dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13dr32 module procedure to_file_14dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dr128 module procedure to_file_14dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dr64 module procedure to_file_14dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14dr32 module procedure to_file_15dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dr128 module procedure to_file_15dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dr64 module procedure to_file_15dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15dr32 module procedure to_file_1di64 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else delim_ = ',' end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1di64 module procedure to_file_1di32 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else delim_ = ',' end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1di32 module procedure to_file_1di16 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else delim_ = ',' end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1di16 module procedure to_file_1di8 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] hstat = 0 else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x )) ) then header_ = [ '' ] hstat = - 1 write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x )) // ').' else header_ = header if ( size ( header ) == 1 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) nl // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = '' else delim_ = ',' end if else if ( dim_ == 1 ) then delim_ = '' else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) nl // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_1di8 module procedure to_file_2di64 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = ',' else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2di64 module procedure to_file_2di32 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = ',' else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2di32 module procedure to_file_2di16 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = ',' else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2di16 module procedure to_file_2di8 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = [ '' ] else if ( ( size ( header ) /= 1 ) . and . ( size ( header ) /= size ( x , dim = 2 )) ) then header_ = [ '' ] write ( * , '(a)' ) nl // 'WARNING: Invalid header for file \"' // file_name // '\".' // & nl // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = ',' else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) nl // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) nl // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) nl // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) nl // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end procedure to_file_2di8 module procedure to_file_3di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3di64 module procedure to_file_3di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3di32 module procedure to_file_3di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3di16 module procedure to_file_3di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_3di8 module procedure to_file_4di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4di64 module procedure to_file_4di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4di32 module procedure to_file_4di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4di16 module procedure to_file_4di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_4di8 module procedure to_file_5di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5di64 module procedure to_file_5di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5di32 module procedure to_file_5di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5di16 module procedure to_file_5di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_5di8 module procedure to_file_6di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6di64 module procedure to_file_6di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6di32 module procedure to_file_6di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6di16 module procedure to_file_6di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_6di8 module procedure to_file_7di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7di64 module procedure to_file_7di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7di32 module procedure to_file_7di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7di16 module procedure to_file_7di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_7di8 module procedure to_file_8di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8di64 module procedure to_file_8di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8di32 module procedure to_file_8di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8di16 module procedure to_file_8di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_8di8 module procedure to_file_9di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9di64 module procedure to_file_9di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9di32 module procedure to_file_9di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9di16 module procedure to_file_9di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_9di8 module procedure to_file_10di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10di64 module procedure to_file_10di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10di32 module procedure to_file_10di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10di16 module procedure to_file_10di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_10di8 module procedure to_file_11di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11di64 module procedure to_file_11di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11di32 module procedure to_file_11di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11di16 module procedure to_file_11di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_11di8 module procedure to_file_12di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12di64 module procedure to_file_12di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12di32 module procedure to_file_12di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12di16 module procedure to_file_12di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_12di8 module procedure to_file_13di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13di64 module procedure to_file_13di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13di32 module procedure to_file_13di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13di16 module procedure to_file_13di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_13di8 module procedure to_file_14di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14di64 module procedure to_file_14di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14di32 module procedure to_file_14di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14di16 module procedure to_file_14di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_14di8 module procedure to_file_15di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15di64 module procedure to_file_15di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15di32 module procedure to_file_15di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15di16 module procedure to_file_15di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) else write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure to_file_15di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_textfile_1dc128 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dc128 module procedure from_binaryfile_1dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dc128 module procedure from_textfile_1dc64 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dc64 module procedure from_binaryfile_1dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dc64 module procedure from_textfile_1dc32 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dc32 module procedure from_binaryfile_1dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dc32 module procedure from_textfile_2dc128 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dc128 module procedure from_binaryfile_2dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dc128 module procedure from_textfile_2dc64 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dc64 module procedure from_binaryfile_2dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dc64 module procedure from_textfile_2dc32 character ( len = :), allocatable :: ext , locale_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if if ( . not . present ( im ) ) then im_ = '' else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ , im = im_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dc32 module procedure from_binaryfile_2dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dc32 module procedure from_file_3dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dc128 module procedure from_file_3dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dc64 module procedure from_file_3dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dc32 module procedure from_file_4dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dc128 module procedure from_file_4dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dc64 module procedure from_file_4dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dc32 module procedure from_file_5dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dc128 module procedure from_file_5dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dc64 module procedure from_file_5dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dc32 module procedure from_file_6dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dc128 module procedure from_file_6dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dc64 module procedure from_file_6dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dc32 module procedure from_file_7dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dc128 module procedure from_file_7dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dc64 module procedure from_file_7dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dc32 module procedure from_file_8dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dc128 module procedure from_file_8dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dc64 module procedure from_file_8dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dc32 module procedure from_file_9dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dc128 module procedure from_file_9dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dc64 module procedure from_file_9dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dc32 module procedure from_file_10dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dc128 module procedure from_file_10dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dc64 module procedure from_file_10dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dc32 module procedure from_file_11dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dc128 module procedure from_file_11dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dc64 module procedure from_file_11dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dc32 module procedure from_file_12dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dc128 module procedure from_file_12dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dc64 module procedure from_file_12dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dc32 module procedure from_file_13dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dc128 module procedure from_file_13dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dc64 module procedure from_file_13dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dc32 module procedure from_file_14dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dc128 module procedure from_file_14dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dc64 module procedure from_file_14dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dc32 module procedure from_file_15dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dc128 module procedure from_file_15dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dc64 module procedure from_file_15dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dc32 module procedure from_textfile_1dr128 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dr128 module procedure from_binaryfile_1dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dr128 module procedure from_textfile_1dr64 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dr64 module procedure from_binaryfile_1dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dr64 module procedure from_textfile_1dr32 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1dr32 module procedure from_binaryfile_1dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1dr32 module procedure from_textfile_2dr128 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dr128 module procedure from_binaryfile_2dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dr128 module procedure from_textfile_2dr64 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dr64 module procedure from_binaryfile_2dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dr64 module procedure from_textfile_2dr32 character ( len = :), allocatable :: ext , locale_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( locales == locale ) ) then locale_ = locale else error stop nl // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & nl // 'Locale must be one of: ' // to_str ( locales , delim = ' ' ) end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( real_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & nl // 'Format must be one of: ' // to_str ( real_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2dr32 module procedure from_binaryfile_2dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2dr32 module procedure from_file_3dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dr128 module procedure from_file_3dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dr64 module procedure from_file_3dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3dr32 module procedure from_file_4dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dr128 module procedure from_file_4dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dr64 module procedure from_file_4dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4dr32 module procedure from_file_5dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dr128 module procedure from_file_5dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dr64 module procedure from_file_5dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5dr32 module procedure from_file_6dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dr128 module procedure from_file_6dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dr64 module procedure from_file_6dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6dr32 module procedure from_file_7dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dr128 module procedure from_file_7dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dr64 module procedure from_file_7dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7dr32 module procedure from_file_8dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dr128 module procedure from_file_8dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dr64 module procedure from_file_8dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8dr32 module procedure from_file_9dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dr128 module procedure from_file_9dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dr64 module procedure from_file_9dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9dr32 module procedure from_file_10dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dr128 module procedure from_file_10dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dr64 module procedure from_file_10dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10dr32 module procedure from_file_11dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dr128 module procedure from_file_11dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dr64 module procedure from_file_11dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11dr32 module procedure from_file_12dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dr128 module procedure from_file_12dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dr64 module procedure from_file_12dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12dr32 module procedure from_file_13dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dr128 module procedure from_file_13dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dr64 module procedure from_file_13dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13dr32 module procedure from_file_14dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dr128 module procedure from_file_14dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dr64 module procedure from_file_14dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14dr32 module procedure from_file_15dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dr128 module procedure from_file_15dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dr64 module procedure from_file_15dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15dr32 module procedure from_textfile_1di64 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1di64 module procedure from_binaryfile_1di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1di64 module procedure from_textfile_1di32 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1di32 module procedure from_binaryfile_1di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1di32 module procedure from_textfile_1di16 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1di16 module procedure from_binaryfile_1di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1di16 module procedure from_textfile_1di8 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_1di8 module procedure from_binaryfile_1di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_1di8 module procedure from_textfile_2di64 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2di64 module procedure from_binaryfile_2di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2di64 module procedure from_textfile_2di32 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2di32 module procedure from_binaryfile_2di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2di32 module procedure from_textfile_2di16 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2di16 module procedure from_binaryfile_2di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2di16 module procedure from_textfile_2di8 character ( len = :), allocatable :: ext , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( text_ext == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( int_fmts == fmt ) ) then fmt_ = fmt else error stop nl // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & nl // 'Format must be one of: ' // to_str ( int_fmts , delim = ' ' ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , fmt = fmt_ ) else if ( any ( binary_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_textfile_2di8 module procedure from_binaryfile_2di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) // ' ' // & to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_binaryfile_2di8 module procedure from_file_3di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3di64 module procedure from_file_3di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3di32 module procedure from_file_3di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3di16 module procedure from_file_3di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_3di8 module procedure from_file_4di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4di64 module procedure from_file_4di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4di32 module procedure from_file_4di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4di16 module procedure from_file_4di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_4di8 module procedure from_file_5di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5di64 module procedure from_file_5di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5di32 module procedure from_file_5di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5di16 module procedure from_file_5di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_5di8 module procedure from_file_6di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6di64 module procedure from_file_6di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6di32 module procedure from_file_6di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6di16 module procedure from_file_6di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_6di8 module procedure from_file_7di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7di64 module procedure from_file_7di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7di32 module procedure from_file_7di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7di16 module procedure from_file_7di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_7di8 module procedure from_file_8di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8di64 module procedure from_file_8di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8di32 module procedure from_file_8di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8di16 module procedure from_file_8di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_8di8 module procedure from_file_9di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9di64 module procedure from_file_9di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9di32 module procedure from_file_9di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9di16 module procedure from_file_9di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_9di8 module procedure from_file_10di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10di64 module procedure from_file_10di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10di32 module procedure from_file_10di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10di16 module procedure from_file_10di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_10di8 module procedure from_file_11di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11di64 module procedure from_file_11di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11di32 module procedure from_file_11di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11di16 module procedure from_file_11di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_11di8 module procedure from_file_12di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12di64 module procedure from_file_12di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12di32 module procedure from_file_12di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12di16 module procedure from_file_12di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_12di8 module procedure from_file_13di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13di64 module procedure from_file_13di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13di32 module procedure from_file_13di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13di16 module procedure from_file_13di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_13di8 module procedure from_file_14di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14di64 module procedure from_file_14di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14di32 module procedure from_file_14di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14di16 module procedure from_file_14di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_14di8 module procedure from_file_15di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15di64 module procedure from_file_15di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15di32 module procedure from_file_15di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15di16 module procedure from_file_15di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( binary_ext == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop nl // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & nl // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( text_ext == ext ) ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop nl // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & nl // 'Supported file extensions: ' // to_str ( binary_ext , delim = ' ' ) end if end if end procedure from_file_15di8 end submodule file_io submodule ( io_fortran_lib ) text_io !! This submodule provides module procedure implementations for the **public interface** `echo` and the **private !! interfaces** `to_text` and `from_text`. contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure echo_string character ( len = :), allocatable :: ext logical :: exists , append_ integer :: file_unit ext = ext_of ( file_name ) if ( . not . any ( text_ext == ext ) ) then write ( * , '(a)' ) nl // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & nl // 'Supported file extensions: ' // to_str ( text_ext , delim = ' ' ) return end if if ( . not . present ( append ) ) then append_ = . true . else append_ = append end if inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'append' ) end if end if write ( unit = file_unit ) string // nl close ( file_unit ) end procedure echo_string module procedure to_text_1dc128 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dc128 module procedure to_text_1dc64 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dc64 module procedure to_text_1dc32 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dc32 module procedure to_text_2dc128 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dc128 module procedure to_text_2dc64 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dc64 module procedure to_text_2dc32 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals , im = im ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dc32 module procedure to_text_1dr128 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dr128 module procedure to_text_1dr64 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dr64 module procedure to_text_1dr32 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i )% s = str ( x ( i ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1dr32 module procedure to_text_2dr128 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dr128 module procedure to_text_2dr64 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dr64 module procedure to_text_2dr32 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), locale = locale , fmt = fmt , decimals = decimals ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2dr32 module procedure to_text_1di64 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // delim else string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1di64 module procedure to_text_1di32 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // delim else string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1di32 module procedure to_text_1di16 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // delim else string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1di16 module procedure to_text_1di8 type ( String ), allocatable , dimension (:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then if ( dim == 1 ) then write ( unit = file_unit ) trim ( adjustl ( header ( 1 ))) // nl else if ( dim == 2 ) then label = trim ( adjustl ( header ( 1 ))) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) - 1 write ( unit = file_unit ) label // str ( i ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 1 )) // nl end if else if ( size ( header ) == size ( x ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x )) ) if ( dim == 1 ) then do concurrent ( i = 1 : size ( x )) string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end do else if ( dim == 2 ) then do concurrent ( i = 1 : size ( x )) if ( i /= size ( x ) ) then string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // delim else string_arr ( i )% s = str ( x ( i ), fmt = fmt ) // nl end if end do end if do i = 1 , size ( x ) write ( unit = file_unit ) string_arr ( i )% s end do close ( file_unit ) end procedure to_text_1di8 module procedure to_text_2di64 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2di64 module procedure to_text_2di32 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2di32 module procedure to_text_2di16 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2di16 module procedure to_text_2di8 type ( String ), allocatable , dimension (:,:) :: string_arr character ( len = :), allocatable :: label integer :: file_unit , i , j logical :: exists inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'rewind' ) end if if ( all ( header == '' ) ) then continue else if ( size ( header ) == 1 ) then label = trim ( adjustl ( header ( 1 ))) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) - 1 write ( unit = file_unit ) label // str ( j ) // delim end do write ( unit = file_unit ) label // str ( ubound ( x , dim = 2 )) // nl else if ( size ( header ) == size ( x , dim = 2 ) ) then write ( unit = file_unit ) to_str ( header , delim = delim ) // nl end if allocate ( string_arr ( size ( x , dim = 1 ), size ( x , dim = 2 )) ) do concurrent ( j = 1 : size ( x , dim = 2 ), i = 1 : size ( x , dim = 1 )) if ( j /= size ( x , dim = 2 ) ) then string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // delim else string_arr ( i , j )% s = str ( x ( i , j ), fmt = fmt ) // nl end if end do do i = 1 , size ( x , dim = 1 ) do j = 1 , size ( x , dim = 2 ) write ( unit = file_unit ) string_arr ( i , j )% s end do end do close ( file_unit ) end procedure to_text_2di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_text_1dc128 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , ind , l1 , l2 , sep_pos complex ( real128 ) :: c character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ignore_sep = . false . ind = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= file_length ) current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = file ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == file ( l2 : l2 )) ) then number = file ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end procedure from_text_1dc128 module procedure from_text_1dc64 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , ind , l1 , l2 , sep_pos complex ( real64 ) :: c character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ignore_sep = . false . ind = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= file_length ) current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = file ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == file ( l2 : l2 )) ) then number = file ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end procedure from_text_1dc64 module procedure from_text_1dc32 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , ind , l1 , l2 , sep_pos complex ( real32 ) :: c character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ignore_sep = . false . ind = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= file_length ) current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = file ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == file ( l2 : l2 )) ) then number = file ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( ind ) = c if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end procedure from_text_1dc32 module procedure from_text_2dc128 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , row , column , l1 , l2 , sep_pos complex ( real128 ) :: c type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) ignore_sep = . false . column = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= len ( lines ( row )% s ) ) current_char = lines ( row )% s ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = lines ( row )% s ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then number = lines ( row )% s ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end do end procedure from_text_2dc128 module procedure from_text_2dc64 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , row , column , l1 , l2 , sep_pos complex ( real64 ) :: c type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) ignore_sep = . false . column = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= len ( lines ( row )% s ) ) current_char = lines ( row )% s ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = lines ( row )% s ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then number = lines ( row )% s ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end do end procedure from_text_2dc64 module procedure from_text_2dc32 logical :: exists , ignore_sep integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , j , row , column , l1 , l2 , sep_pos complex ( real32 ) :: c type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: im_chars , non_separating_chars character ( len = :), allocatable :: file , decimal , sep , number character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( len ( im ) > 0 ) then allocate ( character ( len = 1 ) :: im_chars ( len ( im )) ) do i = 1 , len ( im ) im_chars ( i ) = im ( i : i ) end do else im_chars = [ '' ] end if if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' , '(' , ')' , '+' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' , & '(' , ')' ] end if end if if ( locale == 'US' ) then sep = ',' else if ( locale == 'EU' ) then sep = ';' end if ignore_sep = . false . prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) . or . any ( im_chars == current_char ) ) then prev_char = current_char else if ( ignore_sep ) then prev_char = current_char cycle end if if ( any ( non_separating_chars == prev_char ) . or . any ( im_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) ignore_sep = . false . column = 1 l1 = 1 l2 = 1 i = 1 read_into : do while ( i <= len ( lines ( row )% s ) ) current_char = lines ( row )% s ( i : i ) if ( current_char == '(' ) then ignore_sep = . true . else if ( current_char == ')' ) then ignore_sep = . false . end if if ( any ( non_separating_chars == current_char ) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( current_char == im_chars ( 1 ) ) then number = lines ( row )% s ( l1 : i - 1 ) do j = 2 , len ( number ) if ( ( number ( j : j ) == '+' ) . or . ( number ( j : j ) == '-' ) ) then if ( fmt == 'e' ) then if ( ( number ( j - 1 : j - 1 ) /= 'E' ) . and . ( number ( j - 1 : j - 1 ) /= 'e' ) ) then sep_pos = j exit end if else sep_pos = j exit end if end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i i = i + size ( im_chars ) cycle read_into else if ( ignore_sep ) then l2 = i + 1 i = i + 1 cycle read_into end if if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then number = lines ( row )% s ( l1 + 1 : l2 - 1 ) do j = 1 , len ( number ) if ( number ( j : j ) == sep ) then sep_pos = j exit end if end do if ( fmt == 'z' ) then read ( unit = number (: sep_pos - 1 ), fmt = '(z' // str ( len ( number (: sep_pos - 1 ))) // ')' ) c % re read ( unit = number ( sep_pos + 1 :), fmt = '(z' // str ( len ( number ( sep_pos + 1 :))) // ')' ) c % im else read ( unit = number (: sep_pos - 1 ), fmt =* , decimal = decimal ) c % re read ( unit = number ( sep_pos + 1 :), fmt =* , decimal = decimal ) c % im end if into ( row , column ) = c if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if i = i + 1 end do read_into end do end procedure from_text_2dc32 module procedure from_text_1dr128 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* , decimal = decimal ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1dr128 module procedure from_text_1dr64 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* , decimal = decimal ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1dr64 module procedure from_text_1dr32 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* , decimal = decimal ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1dr32 module procedure from_text_2dr128 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* , decimal = decimal ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2dr128 module procedure from_text_2dr64 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* , decimal = decimal ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2dr64 module procedure from_text_2dr32 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file , decimal character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] else if ( locale == 'US' ) then decimal = 'POINT' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '.' , 'e' , 'E' , '+' , '-' ] else if ( locale == 'EU' ) then decimal = 'COMMA' non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , ',' , 'e' , 'E' , '+' , '-' ] end if end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* , decimal = decimal ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2dr32 module procedure from_text_1di64 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1di64 module procedure from_text_1di32 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1di32 module procedure from_text_1di16 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1di16 module procedure from_text_1di8 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , ind , l1 , l2 character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do if ( ( n_rows > 1 ) . and . ( n_columns > 1 ) ) then error stop nl // 'Error reading file \"' // file_name // '\". File data cannot fit into one-dimensional array.' return else if ( n_columns == 1 ) then allocate ( into ( n_rows ) ) else if ( n_rows == 1 ) then allocate ( into ( n_columns ) ) end if ind = 1 l1 = 1 l2 = 1 read_into : do i = 1 , file_length if ( any ( non_separating_chars == file ( i : i )) ) then if ( . not . any ( non_separating_chars == file ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == file ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = file ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( ind ) else read ( unit = file ( l1 : l2 ), fmt =* ) into ( ind ) end if if ( ind /= size ( into ) ) then ind = ind + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end procedure from_text_1di8 module procedure from_text_2di64 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2di64 module procedure from_text_2di32 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2di32 module procedure from_text_2di16 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2di16 module procedure from_text_2di8 logical :: exists integer :: file_unit , iostat integer :: n_rows , n_columns integer :: i , row , column , l1 , l2 type ( String ), allocatable , dimension (:) :: lines character ( len = :), allocatable , dimension (:) :: non_separating_chars character ( len = :), allocatable :: file character ( len = 1 ) :: prev_char , current_char integer ( int64 ) :: file_length inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: file ) read ( unit = file_unit , iostat = iostat ) file close ( file_unit ) if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if if ( header ) then do i = 1 , file_length if ( file ( i : i ) == nl ) then file = file ( i + 1 :) file_length = len ( file ) exit else if ( i == file_length ) then file = file // nl file_length = file_length + 1 write ( * , '(a)' ) 'WARNING: Ignoring erroneous value of (T) for header in read of file \"' // & file_name // '\". File has one line.' end if end do if ( file_length == 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\". File is empty after header.' return end if end if n_rows = 0 do i = 1 , file_length if ( file ( i : i ) == nl ) then n_rows = n_rows + 1 else if ( i == file_length ) then file = file // nl file_length = file_length + 1 n_rows = n_rows + 1 end if end do if ( fmt == 'i' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , '+' , '-' ] else if ( fmt == 'z' ) then non_separating_chars = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , 'A' , 'B' , 'C' , 'D' , 'E' , 'F' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] end if prev_char = '0' n_columns = 0 do i = 1 , file_length current_char = file ( i : i ) if ( any ( non_separating_chars == current_char ) ) then prev_char = current_char else if ( any ( non_separating_chars == prev_char ) ) then prev_char = current_char n_columns = n_columns + 1 else prev_char = current_char end if end if if ( current_char == nl ) exit end do allocate ( lines ( n_rows ) ) row = 1 l1 = 1 do i = 1 , file_length if ( file ( i : i ) == nl ) then lines ( row )% s = file ( l1 : i ) if ( row /= n_rows ) then row = row + 1 l1 = i + 1 else exit end if end if end do deallocate ( file ) allocate ( into ( n_rows , n_columns ) ) do concurrent ( row = 1 : n_rows ) column = 1 l1 = 1 l2 = 1 read_into : do i = 1 , len ( lines ( row )% s ) if ( any ( non_separating_chars == lines ( row )% s ( i : i )) ) then if ( . not . any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) l1 = i l2 = i else if ( any ( non_separating_chars == lines ( row )% s ( l2 : l2 )) ) then if ( fmt == 'z' ) then read ( unit = lines ( row )% s ( l1 : l2 ), fmt = '(z' // str ( l2 - l1 + 1 ) // ')' ) into ( row , column ) else read ( unit = lines ( row )% s ( l1 : l2 ), fmt =* ) into ( row , column ) end if if ( column /= n_columns ) then column = column + 1 else exit read_into end if l2 = i else l2 = i end if end if end do read_into end do end procedure from_text_2di8 end submodule text_io submodule ( io_fortran_lib ) binary_io !! This submodule provides module procedure implementations for the **private interfaces** `to_binary` and !! `from_binary`. contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_binary_1dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc128 module procedure to_binary_1dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc64 module procedure to_binary_1dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc32 module procedure to_binary_2dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc128 module procedure to_binary_2dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc64 module procedure to_binary_2dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc32 module procedure to_binary_3dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc128 module procedure to_binary_3dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc64 module procedure to_binary_3dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc32 module procedure to_binary_4dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc128 module procedure to_binary_4dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc64 module procedure to_binary_4dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc32 module procedure to_binary_5dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc128 module procedure to_binary_5dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc64 module procedure to_binary_5dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc32 module procedure to_binary_6dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc128 module procedure to_binary_6dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc64 module procedure to_binary_6dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc32 module procedure to_binary_7dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc128 module procedure to_binary_7dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc64 module procedure to_binary_7dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc32 module procedure to_binary_8dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc128 module procedure to_binary_8dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc64 module procedure to_binary_8dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc32 module procedure to_binary_9dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc128 module procedure to_binary_9dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc64 module procedure to_binary_9dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc32 module procedure to_binary_10dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc128 module procedure to_binary_10dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc64 module procedure to_binary_10dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc32 module procedure to_binary_11dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc128 module procedure to_binary_11dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc64 module procedure to_binary_11dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc32 module procedure to_binary_12dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc128 module procedure to_binary_12dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc64 module procedure to_binary_12dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc32 module procedure to_binary_13dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc128 module procedure to_binary_13dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc64 module procedure to_binary_13dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc32 module procedure to_binary_14dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc128 module procedure to_binary_14dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc64 module procedure to_binary_14dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc32 module procedure to_binary_15dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc128 module procedure to_binary_15dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc64 module procedure to_binary_15dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc32 module procedure to_binary_1dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr128 module procedure to_binary_1dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr64 module procedure to_binary_1dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr32 module procedure to_binary_2dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr128 module procedure to_binary_2dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr64 module procedure to_binary_2dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr32 module procedure to_binary_3dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr128 module procedure to_binary_3dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr64 module procedure to_binary_3dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr32 module procedure to_binary_4dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr128 module procedure to_binary_4dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr64 module procedure to_binary_4dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr32 module procedure to_binary_5dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr128 module procedure to_binary_5dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr64 module procedure to_binary_5dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr32 module procedure to_binary_6dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr128 module procedure to_binary_6dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr64 module procedure to_binary_6dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr32 module procedure to_binary_7dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr128 module procedure to_binary_7dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr64 module procedure to_binary_7dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr32 module procedure to_binary_8dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr128 module procedure to_binary_8dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr64 module procedure to_binary_8dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr32 module procedure to_binary_9dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr128 module procedure to_binary_9dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr64 module procedure to_binary_9dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr32 module procedure to_binary_10dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr128 module procedure to_binary_10dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr64 module procedure to_binary_10dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr32 module procedure to_binary_11dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr128 module procedure to_binary_11dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr64 module procedure to_binary_11dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr32 module procedure to_binary_12dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr128 module procedure to_binary_12dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr64 module procedure to_binary_12dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr32 module procedure to_binary_13dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr128 module procedure to_binary_13dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr64 module procedure to_binary_13dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr32 module procedure to_binary_14dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr128 module procedure to_binary_14dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr64 module procedure to_binary_14dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr32 module procedure to_binary_15dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr128 module procedure to_binary_15dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr64 module procedure to_binary_15dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr32 module procedure to_binary_1di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di64 module procedure to_binary_1di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di32 module procedure to_binary_1di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di16 module procedure to_binary_1di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di8 module procedure to_binary_2di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di64 module procedure to_binary_2di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di32 module procedure to_binary_2di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di16 module procedure to_binary_2di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di8 module procedure to_binary_3di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di64 module procedure to_binary_3di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di32 module procedure to_binary_3di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di16 module procedure to_binary_3di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di8 module procedure to_binary_4di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di64 module procedure to_binary_4di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di32 module procedure to_binary_4di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di16 module procedure to_binary_4di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di8 module procedure to_binary_5di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di64 module procedure to_binary_5di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di32 module procedure to_binary_5di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di16 module procedure to_binary_5di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di8 module procedure to_binary_6di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di64 module procedure to_binary_6di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di32 module procedure to_binary_6di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di16 module procedure to_binary_6di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di8 module procedure to_binary_7di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di64 module procedure to_binary_7di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di32 module procedure to_binary_7di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di16 module procedure to_binary_7di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di8 module procedure to_binary_8di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di64 module procedure to_binary_8di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di32 module procedure to_binary_8di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di16 module procedure to_binary_8di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di8 module procedure to_binary_9di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di64 module procedure to_binary_9di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di32 module procedure to_binary_9di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di16 module procedure to_binary_9di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di8 module procedure to_binary_10di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di64 module procedure to_binary_10di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di32 module procedure to_binary_10di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di16 module procedure to_binary_10di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di8 module procedure to_binary_11di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di64 module procedure to_binary_11di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di32 module procedure to_binary_11di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di16 module procedure to_binary_11di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di8 module procedure to_binary_12di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di64 module procedure to_binary_12di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di32 module procedure to_binary_12di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di16 module procedure to_binary_12di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di8 module procedure to_binary_13di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di64 module procedure to_binary_13di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di32 module procedure to_binary_13di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di16 module procedure to_binary_13di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di8 module procedure to_binary_14di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di64 module procedure to_binary_14di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di32 module procedure to_binary_14di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di16 module procedure to_binary_14di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di8 module procedure to_binary_15di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di64 module procedure to_binary_15di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di32 module procedure to_binary_15di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di16 module procedure to_binary_15di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_binary_1dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dc128 module procedure from_binary_1dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dc64 module procedure from_binary_1dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dc32 module procedure from_binary_2dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dc128 module procedure from_binary_2dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dc64 module procedure from_binary_2dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dc32 module procedure from_binary_3dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dc128 module procedure from_binary_3dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dc64 module procedure from_binary_3dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dc32 module procedure from_binary_4dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dc128 module procedure from_binary_4dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dc64 module procedure from_binary_4dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dc32 module procedure from_binary_5dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dc128 module procedure from_binary_5dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dc64 module procedure from_binary_5dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dc32 module procedure from_binary_6dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dc128 module procedure from_binary_6dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dc64 module procedure from_binary_6dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dc32 module procedure from_binary_7dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dc128 module procedure from_binary_7dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dc64 module procedure from_binary_7dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dc32 module procedure from_binary_8dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dc128 module procedure from_binary_8dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dc64 module procedure from_binary_8dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dc32 module procedure from_binary_9dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dc128 module procedure from_binary_9dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dc64 module procedure from_binary_9dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dc32 module procedure from_binary_10dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dc128 module procedure from_binary_10dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dc64 module procedure from_binary_10dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dc32 module procedure from_binary_11dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dc128 module procedure from_binary_11dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dc64 module procedure from_binary_11dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dc32 module procedure from_binary_12dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dc128 module procedure from_binary_12dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dc64 module procedure from_binary_12dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dc32 module procedure from_binary_13dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dc128 module procedure from_binary_13dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dc64 module procedure from_binary_13dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dc32 module procedure from_binary_14dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dc128 module procedure from_binary_14dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dc64 module procedure from_binary_14dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dc32 module procedure from_binary_15dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dc128 module procedure from_binary_15dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dc64 module procedure from_binary_15dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dc32 module procedure from_binary_1dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dr128 module procedure from_binary_1dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dr64 module procedure from_binary_1dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1dr32 module procedure from_binary_2dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dr128 module procedure from_binary_2dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dr64 module procedure from_binary_2dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2dr32 module procedure from_binary_3dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dr128 module procedure from_binary_3dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dr64 module procedure from_binary_3dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3dr32 module procedure from_binary_4dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dr128 module procedure from_binary_4dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dr64 module procedure from_binary_4dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4dr32 module procedure from_binary_5dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dr128 module procedure from_binary_5dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dr64 module procedure from_binary_5dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5dr32 module procedure from_binary_6dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dr128 module procedure from_binary_6dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dr64 module procedure from_binary_6dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6dr32 module procedure from_binary_7dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dr128 module procedure from_binary_7dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dr64 module procedure from_binary_7dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7dr32 module procedure from_binary_8dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dr128 module procedure from_binary_8dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dr64 module procedure from_binary_8dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8dr32 module procedure from_binary_9dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dr128 module procedure from_binary_9dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dr64 module procedure from_binary_9dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9dr32 module procedure from_binary_10dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dr128 module procedure from_binary_10dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dr64 module procedure from_binary_10dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10dr32 module procedure from_binary_11dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dr128 module procedure from_binary_11dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dr64 module procedure from_binary_11dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11dr32 module procedure from_binary_12dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dr128 module procedure from_binary_12dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dr64 module procedure from_binary_12dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12dr32 module procedure from_binary_13dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dr128 module procedure from_binary_13dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dr64 module procedure from_binary_13dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13dr32 module procedure from_binary_14dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dr128 module procedure from_binary_14dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dr64 module procedure from_binary_14dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14dr32 module procedure from_binary_15dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dr128 module procedure from_binary_15dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dr64 module procedure from_binary_15dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15dr32 module procedure from_binary_1di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1di64 module procedure from_binary_1di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1di32 module procedure from_binary_1di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1di16 module procedure from_binary_1di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_1di8 module procedure from_binary_2di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2di64 module procedure from_binary_2di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2di32 module procedure from_binary_2di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2di16 module procedure from_binary_2di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_2di8 module procedure from_binary_3di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3di64 module procedure from_binary_3di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3di32 module procedure from_binary_3di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3di16 module procedure from_binary_3di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_3di8 module procedure from_binary_4di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4di64 module procedure from_binary_4di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4di32 module procedure from_binary_4di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4di16 module procedure from_binary_4di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_4di8 module procedure from_binary_5di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5di64 module procedure from_binary_5di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5di32 module procedure from_binary_5di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5di16 module procedure from_binary_5di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_5di8 module procedure from_binary_6di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6di64 module procedure from_binary_6di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6di32 module procedure from_binary_6di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6di16 module procedure from_binary_6di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_6di8 module procedure from_binary_7di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7di64 module procedure from_binary_7di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7di32 module procedure from_binary_7di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7di16 module procedure from_binary_7di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_7di8 module procedure from_binary_8di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8di64 module procedure from_binary_8di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8di32 module procedure from_binary_8di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8di16 module procedure from_binary_8di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_8di8 module procedure from_binary_9di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9di64 module procedure from_binary_9di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9di32 module procedure from_binary_9di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9di16 module procedure from_binary_9di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_9di8 module procedure from_binary_10di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10di64 module procedure from_binary_10di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10di32 module procedure from_binary_10di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10di16 module procedure from_binary_10di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_10di8 module procedure from_binary_11di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11di64 module procedure from_binary_11di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11di32 module procedure from_binary_11di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11di16 module procedure from_binary_11di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_11di8 module procedure from_binary_12di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12di64 module procedure from_binary_12di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12di32 module procedure from_binary_12di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12di16 module procedure from_binary_12di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_12di8 module procedure from_binary_13di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13di64 module procedure from_binary_13di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13di32 module procedure from_binary_13di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13di16 module procedure from_binary_13di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_13di8 module procedure from_binary_14di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14di64 module procedure from_binary_14di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14di32 module procedure from_binary_14di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14di16 module procedure from_binary_14di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_14di8 module procedure from_binary_15di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15di64 module procedure from_binary_15di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15di32 module procedure from_binary_15di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15di16 module procedure from_binary_15di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop nl // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop nl // 'FATAL: Error reading file \"' // file_name // '\".' return end if close ( file_unit ) end procedure from_binary_15di8 end submodule binary_io","tags":"","loc":"sourcefile/io_fortran_lib.f90.html"},{"title":"API Design – IO-Fortran-Library","text":"The API is made available for use through the following statement: use io_fortran_lib which may be placed at the start of any compilation unit, immediately following the program , module , function , or subroutine statement, and before any implicit statement. The functionality provided by the API is distributed via a handful of generic interfaces for routines that operate on numeric data and which take a minimal number of arguments with optional arguments to customize output for particular use cases. This ensures ease of use and flexibility for the end-user, without the need for any specific knowledge regarding the internal implementations. Object-oriented designs for file I/O are avoided, as these incur additional overhead for both users and programs, without much additional functionality. For convenience, two simple data structures are also provided: String nl These data structures are not required to use any of the functionality provided by the interfaces. Note All external I/O (both text and binary) is conducted as unformatted, stream-access reads and writes as introduced in Fortran 2003, which is much more flexible and typically must faster than record-based I/O.","tags":"","loc":"page/index.html"},{"title":"Important User Information – IO-Fortran-Library","text":"The following subsections detail important information for users: Numeric text formats Locales File extensions Compiler-dependent behavior Thread safety","tags":"","loc":"page/UserInfo/index.html"},{"title":"Numeric text formats – IO-Fortran-Library","text":"When writing integer data as strings with str or to_file , any of the following text formats may be used: int_fmts = [ 'i' , 'z' ] 'i' : integer format (default), e.g. 123456 'z' : hexadecimal format, e.g. 1E240 When writing floating point numbers of type real or complex as strings with str or to_file , any of the following text formats may be used: real_fmts = [ 'e' , 'f' , 'z' ] 'e' : normalized exponential format (default), e.g. 1.2345678901234567E+005 'f' : decimal format, e.g. 123456.78901234567 'z' : hexadecimal format, e.g. 40FE240C9FCB68CD Note The 'z' hexadecimal format is an integer format and may be used for integer , real , or complex data. Floating point numbers are interpreted bit-wise as integers when written with the 'z' format, preventing any loss of precision in a round-trip conversion. This format is preferred for portable data transfers for which precision losses are intolerable.","tags":"","loc":"page/UserInfo/text-fmts.html"},{"title":"Locales – IO-Fortran-Library","text":"When writing floating point numbers of type real or complex as strings with str or to_file , any of the following locales may be used: locales = [ 'US' , 'EU' ] 'US' : US decimal with default comma delimiter (default), e.g. 1.23456789,0.12345678 'EU' : EU decimal with default semicolon delimiter, e.g. 1,23456789;0,12345678","tags":"","loc":"page/UserInfo/locale-fmts.html"},{"title":"File extensions – IO-Fortran-Library","text":"When writing to file or reading from file with echo , to_file , or from_file , a valid file extension must be present. The following are valid text file extensions: text_ext = [ 'csv' , 'txt' , 'ods' , 'odf' , 'odm' , 'odt' , 'xls' , 'doc' , 'log' , 'rtf' , 'org' , 'dbf' ] The following are valid binary file extensions: binary_ext = [ 'dat' , 'bin' ] The routines to_file and from_file will detect the file extension used and direct whether to write/read a text file or a binary file.","tags":"","loc":"page/UserInfo/file-ext.html"},{"title":"Compiler-dependent behavior – IO-Fortran-Library","text":"When writing text files, it's important to note that some compilers implement extensions to the Fortran standard by default with regards to character array literals. For example, the array literal header = [ 'firstcol' , 'secondcol' ] is not standard Fortran 2018 since the strings in the array do not have identical length. Some compilers will accept this and others will not. If required, simply add padding spaces to the left or right of each string to match the length of the longest element. These padding spaces will not be present in the output file. Note Some compilers may allocate strings dynamically on the stack. When reading very large text files, this may result in a stack overflow or segmentation fault unless the compiler is directed to allocate everything on the heap. For example, one would specify -heap-arrays 0 for the Intel Fortran compiler on Linux ( /heap-arrays:0 on Windows).","tags":"","loc":"page/UserInfo/compilers.html"},{"title":"Thread safety – IO-Fortran-Library","text":"As of Fortran 2018, all functions and subroutines are recursive by default without having to specify the recursive keyword. However, at the time of writing, the implementation of this behavior remains unfinished by major compilers, and this may result in catastrophic race conditions when multiple threads attempt to write to the same file in a parallel region. The IO Fortran Library avoids this by explicitly enforcing recursion with the recursive keyword on all functions and subroutines, private and public. However, even with recursion enforced, some programs may not operate as expected when performing I/O in parallel regions. For instance, inspect the output of the following program with multiple coarray images: program main use io_fortran_lib implicit none ( type , external ) call echo ( string = 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end program main Warning Even with recursion, the above program will likely not behave as expected. The proper way to compose the above program is by nesting echo inside a critical block to enforce strict thread-safety in the region: program main use io_fortran_lib implicit none ( type , external ) critical call echo ( string = 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end critical end program main Another common scenario involves performing I/O on a single image, which is thread-safe: program main use io_fortran_lib implicit none ( type , external ) if ( this_image () == 1 ) then call echo ( string = 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end if end program main","tags":"","loc":"page/UserInfo/thread-safety.html"},{"title":"Reference Guide – IO-Fortran-Library","text":"The following subsections provide user instructions for each of the publicly accessible interfaces : str : A function for representing a number as a string. echo : A subroutine for recording a string to an external file. to_file : A subroutine for recording an array to an external file. from_file : A subroutine for reading an external file into an array. aprint : A subroutine for printing arrays and array sections to stdout.","tags":"","loc":"page/Ref/index.html"},{"title":"str – IO-Fortran-Library","text":"interface str For x of type integer : result = str ( x , fmt ) fmt is optional , may be one of int_fmts For x of type real : result = str ( x , locale , fmt , decimals ) locale is optional , may be one of locales fmt is optional , may be one of real_fmts decimals is optional and of type integer For x of type complex : result = str ( x , locale , fmt , decimals , im ) locale is optional , may be one of locales fmt is optional , may be one of real_fmts decimals is optional and of type integer im is optional and of type character(len=*) Optional Arguments Integer formats (default is 'i' ): int_fmts = [ 'i' , 'z' ] Real formats (default is 'e' ): real_fmts = [ 'e' , 'f' , 'z' ] Locales (default is 'US' ): locales = [ 'US' , 'EU' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By default, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as a sum with the specified imaginary unit, e.g. 2.45+3.45j for im='j' or 2.45+3.45*1i for im='*1i' .","tags":"","loc":"page/Ref/str.html"},{"title":"echo – IO-Fortran-Library","text":"interface echo call echo ( string , file_name , append ) string is of type character(len=*) file_name is of type character(len=*) append is optional and of type logical Warning file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Optional Arguments Append (default is .true. ): append specifies whether to append string to file file_name .","tags":"","loc":"page/Ref/echo.html"},{"title":"to_file – IO-Fortran-Library","text":"interface to_file For x of type integer and of rank 1 , 2 : call to_file ( x , file_name , header , dim , delim , fmt ) call to_file ( x , file_name , header , delim , fmt ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer delim is optional and of type character(len=*) fmt is optional , may be one of int_fmts For x of type real and of rank 1 , 2 : call to_file ( x , file_name , header , dim , locale , delim , fmt , decimals ) call to_file ( x , file_name , header , locale , delim , fmt , decimals ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer locale is optional , may be one of locales delim is optional and of type character(len=*) fmt is optional , may be one of real_fmts decimals is optional and of type integer For x of type complex and of rank 1 , 2 : call to_file ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) call to_file ( x , file_name , header , locale , delim , fmt , decimals , im ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer locale is optional , may be one of locales delim is optional and of type character(len=*) fmt is optional , may be one of real_fmts decimals is optional and of type integer im is optional and of type character(len=*) For x of any rank 3 - 15 and of type integer , real , complex : call to_file ( x , file_name ) file_name is of type character(len=*) Warning file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Optional Arguments Header (default is none): header is a character array literal . For x of rank 1 , header may be of size 1 or size(x) . For x of rank 2 , header may be of size 1 or size(x, dim=2) . Dimension: dim specifies whether to write along the rows ( dim=1 ) or along the columns ( dim=2 ), choosing the former by default unless size(header) is size(x) . Locales (default is 'US' ): locales = [ 'US' , 'EU' ] Delimiter (default is ',' ): data separator. Default is ',' for 'US' locale and ';' for 'EU' locale. It is always recommended to omit the delimiter argument for default unless a custom delimiter is really necessary. Integer formats (default is 'i' ): int_fmts = [ 'i' , 'z' ] Real formats (default is 'e' ): real_fmts = [ 'e' , 'f' , 'z' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By default, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as a sum with the specified imaginary unit, e.g. 2.45+3.45j for im='j' or 2.45+3.45*1i for im='*1i' .","tags":"","loc":"page/Ref/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"interface from_file For reading textual data into array into of rank 1 or 2 and of type integer : call from_file ( file_name , into , header , fmt ) file_name is of type character(len=*) header is optional and of type logical fmt is optional , may be one of int_fmts For reading textual data into array into of rank 1 or 2 and of type real : call from_file ( file_name , into , header , locale , fmt ) file_name is of type character(len=*) header is optional and of type logical locale is optional , may be one of locales fmt is optional , may be one of real_fmts For reading textual data into array into of rank 1 or 2 and of type complex : call from_file ( file_name , into , header , locale , fmt , im ) file_name is of type character(len=*) header is optional and of type logical locale is optional , may be one of locales fmt is optional , may be one of real_fmts im is optional and of type character(len=*) For reading binary data into array into of any rank 1 - 15 and of type integer , real , complex : call from_file ( file_name , into , data_shape ) file_name is of type character(len=*) data_shape is of type integer, dimension(:) Warning file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. If file_name does not exist, from_file will issue an error stop . Warning The actual argument of into must be allocatable , and will lose its allocation status upon passing into from_file if already allocated. As a result, from_file does not allow reading into sections of already allocated arrays (this may be added as a feature). Warning When reading binary data, data_shape must be present and its size must equal the rank of into for the read to be valid, or else from_file will issue an error stop . Optional Arguments Header (default is .false. ): specifies whether a header line is present. Locales (default is 'US' ): locales = [ 'US' , 'EU' ] Integer formats (default is 'i' ): int_fmts = [ 'i' , 'z' ] Real formats (default is 'e' ): real_fmts = [ 'e' , 'f' , 'z' ] Imaginary unit: im specifies the form of a complex number. If not present, complex numbers will be assumed to be written as ordered pairs, e.g. (2.45,3.45) .","tags":"","loc":"page/Ref/from_file.html"},{"title":"aprint – IO-Fortran-Library","text":"interface aprint For x of rank 1 or 2 and of type character , String : call aprint ( x ) For x of rank 1 or 2 and of type integer : call aprint ( x , fmt ) fmt is optional , may be one of int_fmts For x of rank 1 or 2 and of type real : call aprint ( x , fmt , decimals ) fmt is optional , may be one of real_fmts decimals is optional and of type integer For x of rank 1 or 2 and of type complex : call aprint ( x , fmt , decimals , im ) fmt is optional , may be one of real_fmts decimals is optional and of type integer im is optional and of type character(len=*) Optional Arguments Integer formats (default is 'i' ): int_fmts = [ 'i' , 'z' ] Real formats (default is 'f' ): real_fmts = [ 'e' , 'f' , 'z' ] Decimals (default is 2 ): decimals specifies the number of digits on the rhs of the radix point. Imaginary unit (default is 'j' ): im specifies the form of a complex number. Note The optional arguments for aprint are different than for str and to_file , and better suited for easy viewing of array sections.","tags":"","loc":"page/Ref/aprint.html"},{"title":"Tutorials – IO-Fortran-Library","text":"The following subsections provide complete example programs for common use cases of the public interfaces : csv file I/O binary file I/O log file output fizzbuzz","tags":"","loc":"page/Examples/index.html"},{"title":"csv file I/O – IO-Fortran-Library","text":"The following program demonstrates the use of to_file and from_file for writing real data to a .csv file in each possible text format , reading each file back into the program, and testing for exact equality to ensure that there has been no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_e , x_f , x_z call random_number ( x ) call to_file ( x , file_name = 'x_e.csv' , header = [ 'x' ], fmt = 'e' ) call to_file ( x , file_name = 'x_f.csv' , header = [ 'x' ], fmt = 'f' ) call to_file ( x , file_name = 'x_z.csv' , header = [ 'x' ], fmt = 'z' ) call from_file ( 'x_e.csv' , into = x_e , header = . true ., fmt = 'e' ) call from_file ( 'x_f.csv' , into = x_f , header = . true ., fmt = 'f' ) call from_file ( 'x_z.csv' , into = x_z , header = . true ., fmt = 'z' ) write ( * , * ) 'x == x_e : ' , all ( x == x_e ) write ( * , * ) 'x == x_f : ' , all ( x == x_f ) write ( * , * ) 'x == x_z : ' , all ( x == x_z ) end program main Warning Default text format for writing and reading is 'e' for data of type real or complex , and 'i' for data of type integer . Attempting to read data with a format that does not correspond to the format in the file will result in an I/O syntax error. Warning Default value for header when reading is .false. . If a header is actually present, the output array will have an extra row with default initialized values.","tags":"","loc":"page/Examples/csv.html"},{"title":"binary file I/O – IO-Fortran-Library","text":"The following program demonstrates the use of to_file and from_file for writing real data to a .dat file, reading the file back into the program, and testing for exact equality to ensure that there has been no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_dat call random_number ( x ) call to_file ( x , file_name = 'x.dat' ) call from_file ( 'x.dat' , into = x_dat , data_shape = shape ( x )) write ( * , * ) 'x == x_dat : ' , all ( x == x_dat ) end program main Note Tip: The shape of an array may be written to file as a .csv so that the value of data_shape can be read into the program before reading in the main array with the corresponding value. The following program demonstrates the above tip: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_dat integer , allocatable , dimension (:) :: x_shape call random_number ( x ) call to_file ( x , file_name = 'x.dat' ) call to_file ( shape ( x ), file_name = 'x_shape.csv' ) call from_file ( 'x_shape.csv' , into = x_shape ) call from_file ( 'x.dat' , into = x_dat , data_shape = x_shape ) write ( * , * ) 'x == x_dat : ' , all ( x == x_dat ) end program main","tags":"","loc":"page/Examples/binary.html"},{"title":"log file output – IO-Fortran-Library","text":"The following program demonstrates the use of echo for writing messages to a .log file, supplemented with the use of nl and str : program main use io_fortran_lib , only : echo , nl , str implicit none ( type , external ) character ( len = :), allocatable :: logfile , logmsg character ( len = 10 ) :: date , time integer :: errstat call date_and_time ( date = date , time = time ) logfile = 'logfile_main_' // trim ( adjustl ( date )) // '_' // time // '.log' logmsg = 'PROGRAM MAIN - BEGINNING EXECUTION' call echo ( string = logmsg // nl // repeat ( '-' , ncopies = len ( logmsg )) // nl , file_name = logfile ) errstat = 1 if ( errstat /= 0 ) then logmsg = 'Process has non-zero exit status: ' // str ( errstat ) // nl // 'Stopping...' call echo ( logmsg , logfile ) error stop logmsg end if end program main","tags":"","loc":"page/Examples/logging.html"},{"title":"fizzbuzz – IO-Fortran-Library","text":"The following program demonstrates the use of aprint for printing an array of type String containing values of the first 100 FizzBuzz numbers, supplemented with the use of str : program main use io_fortran_lib , only : String , aprint , str implicit none ( type , external ) integer , allocatable , dimension (:) :: nums integer :: i nums = [( i , i = 1 , 100 )] call aprint ( FizzBuzz ( nums ) ) contains pure elemental type ( String ) function FizzBuzz ( number ) result ( res ) integer , intent ( in ) :: number if ( mod ( number , 5 ) /= 0 ) then if ( mod ( number , 3 ) /= 0 ) then res = String ( str ( number )) else res = String ( 'fizz' ) end if else if ( mod ( number , 3 ) /= 0 ) then res = String ( 'buzz' ) else res = String ( 'fizzbuzz' ) end if end if end function FizzBuzz end program main","tags":"","loc":"page/Examples/fizzbuzz.html"}]}