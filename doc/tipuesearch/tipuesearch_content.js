var tipuesearch = {"pages":[{"title":" IO-Fortran-Library ","text":"IO-Fortran-Library API Documentation Purpose Scope How to Use License Contact API Documentation This API documentation was generated by FORD (the Fortran\ndocumentation generator). Purpose The purpose of this project is to provide a portable, standard I/O\nlibrary for Modern Fortran programs supporting the Fortran 2018\nstandard, with the goal of enabling essential I/O functionality for\nFortran programmers on any system and with any modern compiler. Scope The IO Fortran Library is a Fortran module io_fortran_lib which\nprovides high level routines for doing internal and external I/O. In\nparticular, the module provides a handful of generic interfaces and a\nsimple derived type for doing string-based and array-based I/O that are\nuseful for recording program data, reading data into programs, writing\nformatted logs and output, and for doing advanced string manipulations.\nFor instance, one may read and write data from/to .csv and .dat files, represent numbers as strings inside of a string expression,\nefficiently write text to a .log file, and dynamically manipulate\nstrings with a String type (including casting between numeric and\nstring data). Note The module is fully self-contained, with no external\ndependencies, and is written to be portable and compliant to the\nFortran 2018 standard such that no special extensions or compiler\noptions should be required. The public interfaces accept all intrinsic\nnumeric types ( integer , real , and complex ) and all standard kinds\nprovided by the intrinsic iso_fortran_env module ( int8 , int16 , int32 , int64 , real32 , real64 , and real128 ). All array-based\nroutines additionally support up to rank 15. How to Use To use io_fortran_lib with your fpm project, add the following\nlines to your fpm.toml file and use the module in your program\nunits to access the routines: [dependencies] IO-Fortran-Library = { git = \"https://github.com/acbbullock/IO-Fortran-Library\" , branch = \"main\" } See the important user information and reference guide for information about calling\nthe routines , and further see the tutorials for complete example programs. License All source code referenced is distributed under the MIT license and available at Github . Contact For bug fixes or feature requests, feel free to open an issue at the project repository or contact acb.bullock@gmail.com . Developer Info Austin C Bullock","tags":"home","loc":"index.html"},{"title":"String – IO-Fortran-Library ","text":"type, public :: String A growable string type for advanced character handling and text I/O. For a user reference, see String , String methods , and Operators . Note TECHNICAL NOTE: The String type is memory safe. The user will never need to be concerned about\naccessing invalid memory when using the String type. Any operation defined in this documentation for the String type which may involve a String with an unallocated component, or arrays of String s in which\nsome of the elements may have unallocated components, is well-defined. In all such cases, the component is\ntreated as the empty string . Constructor public        interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String ) Finalization Procedures final :: scrub private  interface scrub() Methods for the String type. Arguments None Type-Bound Procedures generic, public :: cast => cast_string_to_c128, cast_string_to_c64, cast_string_to_c32, cast_string_to_r128, cast_string_to_r64, cast_string_to_r32, cast_string_to_i64, cast_string_to_i32, cast_string_to_i16, cast_string_to_i8 private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i64), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i32), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i16), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i8), intent(out) :: into character(len=*), intent(in), optional :: fmt generic, public :: count => count_substring_chars, count_substring_string private  interface count_substring_chars() Methods for the String type. Arguments None private  interface count_substring_string() Methods for the String type. Arguments None generic, public :: echo => echo_string private impure recursive module subroutine echo_string(substring, file, append, terminator, stat, errmsg) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file logical, intent(in), optional, target :: append character(len=*), intent(in), optional, target :: terminator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg generic, public :: push => push_chars, push_string private  interface push_chars() Methods for the String type. Arguments None private  interface push_string() Methods for the String type. Arguments None generic, public :: replace => replace_ch_copy, replace_st_copy, replace_chst_copy, replace_stch_copy private  interface replace_ch_copy() Methods for the String type. Arguments None private  interface replace_st_copy() Methods for the String type. Arguments None private  interface replace_chst_copy() Methods for the String type. Arguments None private  interface replace_stch_copy() Methods for the String type. Arguments None generic, public :: replace_inplace => replace_ch_inplace, replace_st_inplace, replace_chst_inplace, replace_stch_inplace private  interface replace_ch_inplace() Methods for the String type. Arguments None private  interface replace_st_inplace() Methods for the String type. Arguments None private  interface replace_chst_inplace() Methods for the String type. Arguments None private  interface replace_stch_inplace() Methods for the String type. Arguments None generic, public :: split => split_string private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, (:) generic, public :: write(formatted) => write_string private  interface write_string() Methods for the String type. Arguments None procedure, public, pass(self) :: as_str interface Methods for the String type. private pure recursive module function as_str(self) result(string_slice) Returns a copy of the string slice component of a scalar String . For a user reference, see as_str . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value character(len=:), allocatable procedure, public, pass(self) :: empty interface Methods for the String type. private pure elemental recursive module subroutine empty(self) Sets the string slice component to the empty string elementally. This procedure is identical in function\nto the assignment self = String() . For a user reference, see empty . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self procedure, public, pass(self) :: join => join_into_self interface Methods for the String type. private pure recursive module subroutine join_into_self(self, tokens, separator) Joins a String vector tokens into self with given separator. Default separator is SPACE. The\nstring slice component will be replaced if already allocated. For a user reference, see join . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self type( String ), intent(in) :: tokens (:) character(len=*), intent(in), optional :: separator procedure, public, pass(self) :: len => length interface Methods for the String type. private pure elemental recursive module function length(self) result(self_len) Returns the length of the string slice component elementally. Unallocated components return -1 . For a user reference, see len . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value integer procedure, public, pass(self) :: len64 => length64 interface Methods for the String type. private pure elemental recursive module function length64(self) result(self_len) Returns the length of the string slice component elementally. Unallocated components return -1 . This\nfunction is identical to len for strings of 2,147,483,647 bytes or smaller. For a user reference, see len . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value integer(kind=i64) procedure, public, pass(self) :: read_file interface Methods for the String type. private impure recursive module subroutine read_file(self, file, cell_array, row_separator, column_separator, stat, errmsg) Reads raw text file contents into self and optionally populates a cell array using the designated row_separator and column_separator whose default values are LF and COMMA respectively. For a user reference, see read_file . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self character(len=*), intent(in) :: file type( String ), intent(out), optional, allocatable :: cell_array (:,:) character(len=*), intent(in), optional, target :: row_separator character(len=*), intent(in), optional, target :: column_separator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg procedure, public, pass(self) :: trim => trim_copy interface Methods for the String type. private pure elemental recursive module function trim_copy(self) result(new) Returns a copy of a String elementally in which each string slice component has been trimmed of any\nleading or trailing whitespace. For a user reference, see trim . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value type( String ) procedure, public, pass(self) :: trim_inplace interface Methods for the String type. private pure elemental recursive module subroutine trim_inplace(self) Removes any leading or trailing whitespace of the string slice component of a String elementally and\nin place. For a user reference, see trim_inplace . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self procedure, public, pass(self) :: write_file interface Methods for the String type. private impure recursive module subroutine write_file(self, cell_array, file, row_separator, column_separator, append, stat, errmsg) Writes the content of a cell array to a text file. The cell array's entire contents are populated into self and then streamed to an external text file using the designated row_separator and column_separator whose default values are LF and COMMA respectively. For a user reference, see write_file . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self type( String ), intent(in) :: cell_array (:,:) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: row_separator character(len=*), intent(in), optional, target :: column_separator logical, intent(in), optional, target :: append integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg","tags":"","loc":"type/string.html"},{"title":"operator(//) – IO-Fortran-Library","text":"public interface operator(//) Concatenation operator for character and String , lifted from character . Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . Functions private pure elemental recursive module function string_concatenation(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concatenation(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concatenation(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(SLASHSLASH).html"},{"title":"operator(+) – IO-Fortran-Library","text":"public interface operator(+) Concatenation operator for character and String (as addition). Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . Functions private pure elemental recursive module function char_concat_plus(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value character(len=len) private pure elemental recursive module function string_concat_plus(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concat_plus(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concat_plus(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(+).html"},{"title":"operator(-) – IO-Fortran-Library","text":"public interface operator(-) Excision operator for character and String (as subtraction). Mixed type excision of character and String is explicitly defined. For a user reference, see Excision . Functions private pure elemental recursive module function char_excision(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function string_excision(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_excision(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_excision(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(-).html"},{"title":"operator(**) – IO-Fortran-Library","text":"public interface operator(**) Repetition operator for character and String (as exponentiation). For a user reference, see Repetition . Functions private pure elemental recursive module function repeat_chars(char_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char_base integer, intent(in) :: ncopies Return Value character(len=len) private pure elemental recursive module function repeat_String(String_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: String_base integer, intent(in) :: ncopies Return Value type( String )","tags":"","loc":"interface/operator(ASTERISKASTERISK).html"},{"title":"operator(==) – IO-Fortran-Library","text":"public interface operator(==) Equivalence operator for character and String . Mixed type equivalence of character and String is\nexplicitly defined. For a user reference, see Equivalence . Note The equivalence operator == is interchangeable with .eq. . Functions private pure elemental recursive module function string_equivalence(Stringl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_equivalence(Stringl, charsr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_equivalence(charsl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(/=) – IO-Fortran-Library","text":"public interface operator(/=) Non-equivalence operator for character and String . Mixed type non-equivalence of character and String is explicitly defined. For a user reference, see Non-equivalence . Note The non-equivalence operator /= is interchangeable with .ne. . Functions private pure elemental recursive module function string_nonequivalence(Stringl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_nonequivalence(Stringl, charsr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_nonequivalence(charsl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"String – IO-Fortran-Library","text":"public interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . Functions private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String )","tags":"","loc":"interface/string.html"},{"title":"str – IO-Fortran-Library","text":"public interface str Function for returning a character representation of a number. For a user reference, see str . Functions private pure recursive module function str_from_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_string(x) result(x_str) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_char(x) result(x_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_empty() result(x_str) Arguments None Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"cast – IO-Fortran-Library","text":"public interface cast Subroutine for casting between numeric and string data. For a user reference, see cast . Subroutines private pure elemental recursive module subroutine cast_c128_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c64_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c32_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_r128_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r64_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r32_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_i64_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i32_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i16_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i8_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_c128_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c64_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c32_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_r128_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r64_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r32_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_i64_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i32_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i16_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i8_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i64), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i32), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i16), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i8), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i64), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i32), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i16), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i8), intent(out) :: into character(len=*), intent(in), optional :: fmt","tags":"","loc":"interface/cast.html"},{"title":"join – IO-Fortran-Library","text":"public interface join Function for joining a vector of tokens into a scalar character or String . For a user reference, see join . Functions private pure recursive module function join_char(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tokens (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable private pure recursive module function join_string(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name type( String ), intent(in) :: tokens (:) character(len=*), intent(in), optional :: separator Return Value type( String )","tags":"","loc":"interface/join.html"},{"title":"split – IO-Fortran-Library","text":"public interface split Function for splitting a scalar character or String into a vector of tokens . For a user reference, see split . Functions private pure recursive module function split_char(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, (:) private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, (:)","tags":"","loc":"interface/split.html"},{"title":"to_file – IO-Fortran-Library","text":"public interface to_file Subroutine for writing an array of uniform numeric data type to an external file. For a user reference, see to_file . Subroutines private impure recursive module subroutine to_file_c128(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_c64(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_c32(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r128(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r64(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r32(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i64(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i32(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i16(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i8(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg","tags":"","loc":"interface/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"public interface from_file Subroutine for reading an external file of uniform numeric data type and format into an array. For a user reference, see from_file . Subroutines private impure recursive module subroutine from_textfile_c128(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r128), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_c64(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_c32(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c128(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r128), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r128(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r128), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r64(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r32(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r128(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r128), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i64(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i32(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i16(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i16), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i8(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i8), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i16(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i16), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i8(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i8), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg","tags":"","loc":"interface/from_file.html"},{"title":"echo – IO-Fortran-Library","text":"public interface echo Subroutine for writing a scalar character or String to an external text file. For a user reference, see echo . Subroutines private impure recursive module subroutine echo_chars(substring, file, append, terminator, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in) :: file logical, intent(in), optional, target :: append character(len=*), intent(in), optional, target :: terminator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine echo_string(substring, file, append, terminator, stat, errmsg) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file logical, intent(in), optional, target :: append character(len=*), intent(in), optional, target :: terminator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg","tags":"","loc":"interface/echo.html"},{"title":"aprint – IO-Fortran-Library","text":"public interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . Subroutines private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:) private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:,:) private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x (:) private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x (:,:)","tags":"","loc":"interface/aprint.html"},{"title":"random_gauss – IO-Fortran-Library","text":"public interface random_gauss Applies gauss to whole arrays and scalars. Subroutines private impure elemental module subroutine random_gauss_r128(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(inout) :: x real(kind=r128), intent(in) :: mu real(kind=r128), intent(in) :: sig private impure elemental module subroutine random_gauss_r64(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: x real(kind=r64), intent(in) :: mu real(kind=r64), intent(in) :: sig private impure elemental module subroutine random_gauss_r32(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: x real(kind=r32), intent(in) :: mu real(kind=r32), intent(in) :: sig","tags":"","loc":"interface/random_gauss.html"},{"title":"io_fortran_lib – IO-Fortran-Library","text":"This module provides common I/O routines for data of integer , real , complex , and character type, and\na derived type String for advanced character handling and text file I/O. This module is F2018 compliant, has\nno external dependencies, and has a max line length of 120. Uses iso_fortran_env iso_c_binding Used by Descendants: array_printing binary_io file_io internal_io join_split operators string_methods text_io Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: NL = new_line(\"a\") The newline character (system agnostic) character(len=1), public, parameter :: SPACE = achar(32) The space character character(len=1), public, parameter :: CR = achar(13) The carriage return character character(len=1), public, parameter :: FF = achar(12) The form feed character character(len=1), public, parameter :: VT = achar(11) The vertical tab character character(len=1), public, parameter :: LF = achar(10) The line feed character character(len=1), public, parameter :: TAB = achar(9) The horizontal tab character character(len=1), public, parameter :: HT = achar(9) The horizontal tab character (alternate name) character(len=1), public, parameter :: BELL = achar(7) The bell/alert character character(len=1), public, parameter :: NUL = achar(0) The null character character(len=1), public, parameter :: CNUL = c_null_char The C null character re-exported from iso_c_binding Interfaces public        interface operator(//) Concatenation operator for character and String , lifted from character . Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . private pure elemental recursive module function string_concatenation(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concatenation(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concatenation(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(+) Concatenation operator for character and String (as addition). Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . private pure elemental recursive module function char_concat_plus(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value character(len=len) private pure elemental recursive module function string_concat_plus(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concat_plus(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concat_plus(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(-) Excision operator for character and String (as subtraction). Mixed type excision of character and String is explicitly defined. For a user reference, see Excision . private pure elemental recursive module function char_excision(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function string_excision(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_excision(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_excision(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(**) Repetition operator for character and String (as exponentiation). For a user reference, see Repetition . private pure elemental recursive module function repeat_chars(char_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char_base integer, intent(in) :: ncopies Return Value character(len=len) private pure elemental recursive module function repeat_String(String_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: String_base integer, intent(in) :: ncopies Return Value type( String ) public        interface operator(==) Equivalence operator for character and String . Mixed type equivalence of character and String is\nexplicitly defined. For a user reference, see Equivalence . Note The equivalence operator == is interchangeable with .eq. . private pure elemental recursive module function string_equivalence(Stringl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_equivalence(Stringl, charsr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_equivalence(charsl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical public        interface operator(/=) Non-equivalence operator for character and String . Mixed type non-equivalence of character and String is explicitly defined. For a user reference, see Non-equivalence . Note The non-equivalence operator /= is interchangeable with .ne. . private pure elemental recursive module function string_nonequivalence(Stringl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_nonequivalence(Stringl, charsr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_nonequivalence(charsl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical public        interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String ) public        interface str Function for returning a character representation of a number. For a user reference, see str . private pure recursive module function str_from_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_string(x) result(x_str) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_char(x) result(x_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_empty() result(x_str) Arguments None Return Value character(len=:), allocatable public        interface cast Subroutine for casting between numeric and string data. For a user reference, see cast . private pure elemental recursive module subroutine cast_c128_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c64_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c32_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_r128_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r64_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r32_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_i64_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i32_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i16_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i8_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_c128_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c64_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c32_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_r128_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r64_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r32_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_i64_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i32_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i16_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i8_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i64), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i32), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i16), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=i8), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r128), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r64), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=r32), intent(out) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i64), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i32), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i16), intent(out) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=i8), intent(out) :: into character(len=*), intent(in), optional :: fmt public        interface join Function for joining a vector of tokens into a scalar character or String . For a user reference, see join . private pure recursive module function join_char(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: tokens (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable private pure recursive module function join_string(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name type( String ), intent(in) :: tokens (:) character(len=*), intent(in), optional :: separator Return Value type( String ) public        interface split Function for splitting a scalar character or String into a vector of tokens . For a user reference, see split . private pure recursive module function split_char(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, (:) private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, (:) public        interface to_file Subroutine for writing an array of uniform numeric data type to an external file. For a user reference, see to_file . private impure recursive module subroutine to_file_c128(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_c64(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_c32(x, file, header, locale, delim, fmt, decimals, im, stat, errmsg) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r128(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r64(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_r32(x, file, header, locale, delim, fmt, decimals, stat, errmsg) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(in), optional, target :: decimals integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i64(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i32(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i16(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine to_file_i8(x, file, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (..) character(len=*), intent(in) :: file character(len=*), intent(in), optional, target :: header (:) character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg public        interface from_file Subroutine for reading an external file of uniform numeric data type and format into an array. For a user reference, see from_file . private impure recursive module subroutine from_textfile_c128(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r128), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_c64(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_c32(file, into, header, locale, delim, fmt, im, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt character(len=*), intent(in), optional, target :: im integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c128(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r128), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_c32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file complex(kind=r32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r128(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r128), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r64(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_r32(file, into, header, locale, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: locale character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r128(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r128), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_r32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file real(kind=r32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i64(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i64), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i32(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i32), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i16(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i16), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_textfile_i8(file, into, header, delim, fmt, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i8), intent(out), allocatable :: into (..) logical, intent(in), optional, target :: header character(len=*), intent(in), optional, target :: delim character(len=*), intent(in), optional, target :: fmt integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i64(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i64), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i32(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i32), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i16(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i16), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine from_binaryfile_i8(file, into, data_shape, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file integer(kind=i8), intent(out), allocatable :: into (..) integer, intent(in) :: data_shape (:) integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg public        interface echo Subroutine for writing a scalar character or String to an external text file. For a user reference, see echo . private impure recursive module subroutine echo_chars(substring, file, append, terminator, stat, errmsg) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in) :: file logical, intent(in), optional, target :: append character(len=*), intent(in), optional, target :: terminator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg private impure recursive module subroutine echo_string(substring, file, append, terminator, stat, errmsg) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file logical, intent(in), optional, target :: append character(len=*), intent(in), optional, target :: terminator integer, intent(out), optional, target :: stat character(len=*), intent(out), optional, target :: errmsg public        interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r128), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=r32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i64), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i32), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i16), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=i8), intent(in) :: x (:,:) character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:) private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x (:,:) private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x (:) private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x (:,:) Derived Types type, public :: String A growable string type for advanced character handling and text I/O. Read more… Constructor Function for returning a String representation of numbers. Read more… private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c128 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c64 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c32 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r128 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r64 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r32 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i64 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i32 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i16 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i8 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_string (x) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_char (x) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_empty () Finalizations Procedures final :: scrub Type-Bound Procedures generic, public :: cast => cast_string_to_c128, cast_string_to_c64, cast_string_to_c32, cast_string_to_r128, cast_string_to_r64, cast_string_to_r32, cast_string_to_i64, cast_string_to_i32, cast_string_to_i16, cast_string_to_i8 generic, public :: count => count_substring_chars, count_substring_string generic, public :: echo => echo_string generic, public :: push => push_chars, push_string generic, public :: replace => replace_ch_copy, replace_st_copy, replace_chst_copy, replace_stch_copy generic, public :: replace_inplace => replace_ch_inplace, replace_st_inplace, replace_chst_inplace, replace_stch_inplace generic, public :: split => split_string generic, public :: write(formatted) => write_string procedure, public, pass(self) :: as_str procedure, public, pass(self) :: empty procedure, public, pass(self) :: join => join_into_self procedure, public, pass(self) :: len => length procedure, public, pass(self) :: len64 => length64 procedure, public, pass(self) :: read_file procedure, public, pass(self) :: trim => trim_copy procedure, public, pass(self) :: trim_inplace procedure, public, pass(self) :: write_file","tags":"","loc":"module/io_fortran_lib.html"},{"title":"randoms – IO-Fortran-Library","text":"This module provides Gaussian sampling utility routines for use in unit testing. Uses iso_fortran_env Used by Descendants: gaussian_sampling Interfaces public        interface random_gauss Applies gauss to whole arrays and scalars. private impure elemental module subroutine random_gauss_r128(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r128), intent(inout) :: x real(kind=r128), intent(in) :: mu real(kind=r128), intent(in) :: sig private impure elemental module subroutine random_gauss_r64(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r64), intent(inout) :: x real(kind=r64), intent(in) :: mu real(kind=r64), intent(in) :: sig private impure elemental module subroutine random_gauss_r32(x, mu, sig) Arguments Type Intent Optional Attributes Name real(kind=r32), intent(inout) :: x real(kind=r32), intent(in) :: mu real(kind=r32), intent(in) :: sig","tags":"","loc":"module/randoms.html"},{"title":"array_printing – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface aprint . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/array_printing.html"},{"title":"binary_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the private interfaces to_binary and from_binary . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/binary_io.html"},{"title":"file_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces to_file and from_file . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/file_io.html"},{"title":"internal_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces String , str , and cast . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/internal_io.html"},{"title":"join_split – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces join and split . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/join_split.html"},{"title":"operators – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces operator(//) , operator(+) , operator(-) , operator(**) , operator(==) , and operator(/=) . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/operators.html"},{"title":"string_methods – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the type-bound procedures of type String . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/string_methods.html"},{"title":"text_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface echo and the private\ninterfaces to_text and from_text . Uses Ancestors: io_fortran_lib","tags":"","loc":"module/text_io.html"},{"title":"gaussian_sampling – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface random_gauss and the private interface gauss . Uses Ancestors: randoms","tags":"","loc":"module/gaussian_sampling.html"},{"title":"array_printing_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) array_printing !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interface** `aprint`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< module procedure aprint_1dc128 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , decimals_ l = 0 ; i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc128 module procedure aprint_1dc64 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , decimals_ l = 0 ; i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc64 module procedure aprint_1dc32 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , decimals_ l = 0 ; i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc32 module procedure aprint_2dc128 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , j , decimals_ l = 0 ; i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do end do call aprint ( x_str ) end procedure aprint_2dc128 module procedure aprint_2dc64 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , j , decimals_ l = 0 ; i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do end do call aprint ( x_str ) end procedure aprint_2dc64 module procedure aprint_2dc32 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: l , i , j , decimals_ l = 0 ; i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = \"j\" else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do end do call aprint ( x_str ) end procedure aprint_2dc32 module procedure aprint_1dr128 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr128 module procedure aprint_1dr64 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr64 module procedure aprint_1dr32 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ i = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr32 module procedure aprint_2dr128 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do end do call aprint ( x_str ) end procedure aprint_2dr128 module procedure aprint_2dr64 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do end do call aprint ( x_str ) end procedure aprint_2dr64 module procedure aprint_2dr32 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ i = 0 ; j = 0 ; decimals_ = 0 if ( . not . present ( fmt ) ) then fmt_ = \"f\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"f\" end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do end do call aprint ( x_str ) end procedure aprint_2dr32 module procedure aprint_1di64 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di64 module procedure aprint_1di32 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di32 module procedure aprint_1di16 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di16 module procedure aprint_1di8 character ( len = :), allocatable :: x_str (:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di8 module procedure aprint_2di64 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j i = 0 ; j = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do end do call aprint ( x_str ) end procedure aprint_2di64 module procedure aprint_2di32 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j i = 0 ; j = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do end do call aprint ( x_str ) end procedure aprint_2di32 module procedure aprint_2di16 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j i = 0 ; j = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do end do call aprint ( x_str ) end procedure aprint_2di16 module procedure aprint_2di8 character ( len = :), allocatable :: x_str (:,:) character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j i = 0 ; j = 0 if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = \"i\" end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do end do call aprint ( x_str ) end procedure aprint_2di8 module procedure aprint_1dchar type ( String ), allocatable :: rows (:) integer :: i i = 0 allocate ( rows ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( i == lbound ( x , dim = 1 ) ) then if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = LF // '    ' // adjustl ( x ( i ) ) // LF else rows ( i )% s = LF // '    ' // adjustl ( x ( i ) ) end if else if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = '    ' // adjustl ( x ( i ) ) // LF else rows ( i )% s = '    ' // adjustl ( x ( i ) ) end if end do do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) write ( * , \"(a)\" ) rows ( i )% s end do end procedure aprint_1dchar module procedure aprint_2dchar type ( String ), allocatable :: rows (:) integer :: i i = 0 allocate ( rows ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( i == lbound ( x , dim = 1 ) ) then if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = LF // '    ' // accum ( x ( i ,:) ) // LF else rows ( i )% s = LF // '    ' // accum ( x ( i ,:) ) end if else if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = '    ' // accum ( x ( i ,:) ) // LF else rows ( i )% s = '    ' // accum ( x ( i ,:) ) end if end do do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) write ( * , \"(a)\" ) rows ( i )% s end do contains pure recursive function accum ( x ) result ( x_str ) character ( len =* ), intent ( in ) :: x (:) character ( len = :), allocatable :: x_str integer :: x_len , x_size , i , pos x_len = 0 ; x_size = 0 ; i = 0 ; pos = 0 x_len = len ( x ) x_size = size ( x ) if ( x_size == 1 ) then x_str = x ( 1 ); return end if if ( x_len == 0 ) then x_str = EMPTY_STR ; return end if allocate ( character ( len = x_len * x_size + x_size - 1 ) :: x_str ) positional_transfer : do i = 1 , x_size pos = ( i - 1 ) * ( x_len + 1 ) + 1 x_str ( pos : pos + x_len - 1 ) = adjustl ( x ( i )) if ( i < x_size ) x_str ( pos + x_len : pos + x_len ) = SPACE end do positional_transfer end function accum end procedure aprint_2dchar module procedure aprint_1dString character ( len = :), allocatable :: char_arr (:) integer , allocatable :: lengths (:) integer :: i , max_length i = 0 ; max_length = 0 lengths = x % len () max_length = maxval ( lengths ) allocate ( character ( len = max_length ) :: char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( lengths ( i ) < 1 ) then char_arr ( i ) = EMPTY_STR else char_arr ( i ) = x ( i )% s end if end do call aprint ( char_arr ) end procedure aprint_1dString module procedure aprint_2dString character ( len = :), allocatable :: char_arr (:,:) integer , allocatable :: lengths (:,:) integer :: i , j , max_length i = 0 ; j = 0 ; max_length = 0 lengths = x % len () max_length = maxval ( lengths ) allocate ( character ( len = max_length ) :: & char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do j = lbound ( x , dim = 2 ), ubound ( x , dim = 2 ) do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) if ( lengths ( i , j ) < 1 ) then char_arr ( i , j ) = EMPTY_STR else char_arr ( i , j ) = x ( i , j )% s end if end do end do call aprint ( char_arr ) end procedure aprint_2dString end submodule array_printing","tags":"","loc":"sourcefile/array_printing_impl.f90.html"},{"title":"binary_io_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) binary_io !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **private interfaces** `to_binary` and !! `from_binary`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_binary_c128 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_c128 module procedure to_binary_c64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_c64 module procedure to_binary_c32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_c32 module procedure to_binary_r128 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_r128 module procedure to_binary_r64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_r64 module procedure to_binary_r32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_r32 module procedure to_binary_i64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_i64 module procedure to_binary_i32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_i32 module procedure to_binary_i16 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_i16 module procedure to_binary_i8 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) else open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat , iomsg = errmsg ) end if if ( stat /= 0 ) then stat = WRITE_ERR ; return end if select rank ( x ) rank ( 1 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 2 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 3 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 4 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 5 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 6 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 7 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 8 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 9 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 10 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 11 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 12 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 13 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 14 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x rank ( 15 ); write ( unit = file_unit , iostat = stat , iomsg = errmsg ) x end select if ( stat /= 0 ) then stat = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = WRITE_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure to_binary_i8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_binary_c128 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_c128 module procedure from_binary_c64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_c64 module procedure from_binary_c32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_c32 module procedure from_binary_r128 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_r128 module procedure from_binary_r64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_r64 module procedure from_binary_r32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_r32 module procedure from_binary_i64 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_i64 module procedure from_binary_i32 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_i32 module procedure from_binary_i16 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_i16 module procedure from_binary_i8 logical :: exists integer :: file_unit exists = . false . file_unit = 0 inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if select rank ( into ) rank ( 1 ) allocate ( into ( data_shape ( 1 )), stat = stat , errmsg = errmsg ) rank ( 2 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 )), stat = stat , errmsg = errmsg ) rank ( 3 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )), stat = stat , errmsg = errmsg ) rank ( 4 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )), stat = stat , errmsg = errmsg ) rank ( 5 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )), stat = stat , & errmsg = errmsg ) rank ( 6 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 )), stat = stat , errmsg = errmsg ) rank ( 7 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 )), stat = stat , errmsg = errmsg ) rank ( 8 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 )), stat = stat , errmsg = errmsg ) rank ( 9 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )), stat = stat , errmsg = errmsg ) rank ( 10 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )), stat = stat , & errmsg = errmsg ) rank ( 11 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 )), stat = stat , errmsg = errmsg ) rank ( 12 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 )), stat = stat , errmsg = errmsg ) rank ( 13 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 )), stat = stat , errmsg = errmsg ) rank ( 14 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 )), stat = stat , & errmsg = errmsg ) rank ( 15 ) allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), & data_shape ( 6 ), data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), & data_shape ( 11 ), data_shape ( 12 ), data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )), & stat = stat , errmsg = errmsg ) end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 2 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 3 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 4 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 5 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 6 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 7 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 8 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 9 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 10 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 11 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 12 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 13 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 14 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into rank ( 15 ); read ( unit = file_unit , iostat = stat , iomsg = errmsg ) into end select if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if stat = 0 ; errmsg = EMPTY_STR end procedure from_binary_i8 end submodule binary_io","tags":"","loc":"sourcefile/binary_io_impl.f90.html"},{"title":"file_io_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) file_io !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interfaces** `to_file` and !! `from_file`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) ! Definitions and interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 0 ), target :: EMPTY_STRING = EMPTY_STR character ( len = 0 ), target :: EMPTY_HEADER ( 1 ) = [ EMPTY_STR ] character ( len = 1 ), target :: EXP_FMT = REAL_FMTS ( 1 ) character ( len = 1 ), target :: INT_FMT = INT_FMTS ( 1 ) character ( len = 1 ), target :: COMMA_DELIMITER = COMMA character ( len = 1 ), target :: SEMICOLON_DELIM = SEMICOLON character ( len = 2 ), target :: US_LOCALE = LOCALES ( 1 ) integer , target :: MAX_DECIMALS = 150 logical , target :: ABSENT_HEADER = . false . contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< module procedure ext_of integer :: i , l i = 0 ; l = 0 l = len_trim ( file ) do i = l , 1 , - 1 if ( file ( i : i ) == POINT ) exit end do if ( i > 0 ) then ext = trim ( adjustl ( file ( i + 1 : l ))) else ext = EMPTY_STR end if end procedure ext_of ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_file_c128 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , \"(a)\" ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_c128 module procedure to_file_c64 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , \"(a)\" ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_c64 module procedure to_file_c32 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , im_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , \"(a)\" ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_c32 module procedure to_file_r128 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_r128 module procedure to_file_r64 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_r64 module procedure to_file_r32 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ integer , pointer :: decimals_ , stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( REAL_FMTS ) return end if end if if ( . not . present ( decimals ) ) then decimals_ => MAX_DECIMALS else decimals_ => decimals end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , locale_ , delim_ , fmt_ , decimals_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , \"(a)\" ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , \"(a)\" ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_r32 module procedure to_file_i64 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: delim_ , fmt_ , errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( INT_FMTS ) return end if end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_i64 module procedure to_file_i32 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: delim_ , fmt_ , errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( INT_FMTS ) return end if end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_i32 module procedure to_file_i16 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: delim_ , fmt_ , errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( INT_FMTS ) return end if end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_i16 module procedure to_file_i8 character ( len = :), allocatable :: ext character ( len = :), pointer :: header_ (:) character ( len = :), pointer :: delim_ , fmt_ , errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then select rank ( x ) rank ( 1 ); continue rank ( 2 ); continue rank default stat_ = ARG_ERR errmsg_ = \"Cannot write an array of rank \" // str ( rank ( x )) // \" to text file.\" return end select if ( . not . present ( header ) ) then header_ => EMPTY_HEADER else if ( size ( header ) /= 1 ) then select rank ( x ) rank ( 1 ) stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1.' return rank ( 2 ) if ( size ( header ) /= size ( x , dim = 2 ) ) then stat_ = ARG_ERR errmsg_ = 'Invalid header for file \"' // file // '\". Header for this data must have size 1 or size ' // & str ( size ( x , dim = 2 )) // \".\" return end if end select end if header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for file \"' // file // '\". Format must be one of: ' // join ( INT_FMTS ) return end if end if select rank ( x ) rank ( 1 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ); call to_text ( x , file , header_ , delim_ , fmt_ , stat_ , errmsg_ ) end select else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , \"(a)\" ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , \"(a)\" ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , \"(a)\" ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' select rank ( x ) rank ( 1 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 2 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 3 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 4 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 5 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 6 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 7 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 8 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 9 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 10 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 11 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 12 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 13 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 14 ); call to_binary ( x , file , stat_ , errmsg_ ) rank ( 15 ); call to_binary ( x , file , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) // SPACE // join ( BINARY_EXT ) end if end procedure to_file_i8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_textfile_c128 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into complex array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_c128 module procedure from_textfile_c64 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into complex array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_c64 module procedure from_textfile_c32 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , im_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into complex array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if if ( . not . present ( im ) ) then im_ => EMPTY_STRING else im_ => im end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , im_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_c32 module procedure from_binaryfile_c128 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_c128 module procedure from_binaryfile_c64 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_c64 module procedure from_binaryfile_c32 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_c32 module procedure from_textfile_r128 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into real array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_r128 module procedure from_textfile_r64 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into real array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_r64 module procedure from_textfile_r32 character ( len = :), allocatable :: ext character ( len = :), pointer :: locale_ , delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( locale ) ) then locale_ => US_LOCALE else if ( any ( LOCALES == locale ) ) then locale_ => locale else stat_ = ARG_ERR errmsg_ = 'Invalid locale \"' // locale // '\" for file \"' // file // '\". Locale must be one of: ' // join ( LOCALES ) return end if end if if ( . not . present ( delim ) ) then if ( locale_ == US_LOCALE ) then delim_ => COMMA_DELIMITER else delim_ => SEMICOLON_DELIM end if else delim_ => delim if ( locale_ == US_LOCALE ) then if ( delim_ == POINT ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having US style decimal.\" return end if else if ( delim_ == COMMA ) then stat_ = ARG_ERR errmsg_ = \"Invalid delimiter for numbers having EU style decimal.\" return end if end if end if if ( . not . present ( fmt ) ) then fmt_ => EXP_FMT else if ( any ( REAL_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into real array. Format must be one of: \" // join ( REAL_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , locale_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_r32 module procedure from_binaryfile_r128 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_r128 module procedure from_binaryfile_r64 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_r64 module procedure from_binaryfile_r32 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_r32 module procedure from_textfile_i64 character ( len = :), allocatable :: ext character ( len = :), pointer :: delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into integer array. Format must be one of: \" // join ( INT_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_i64 module procedure from_textfile_i32 character ( len = :), allocatable :: ext character ( len = :), pointer :: delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into integer array. Format must be one of: \" // join ( INT_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_i32 module procedure from_textfile_i16 character ( len = :), allocatable :: ext character ( len = :), pointer :: delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into integer array. Format must be one of: \" // join ( INT_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_i16 module procedure from_textfile_i8 character ( len = :), allocatable :: ext character ( len = :), pointer :: delim_ , fmt_ , errmsg_ logical , pointer :: header_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ => ABSENT_HEADER else header_ => header end if if ( . not . present ( delim ) ) then delim_ => COMMA_DELIMITER else delim_ => delim end if if ( . not . present ( fmt ) ) then fmt_ => INT_FMT else if ( any ( INT_FMTS == fmt ) ) then fmt_ => fmt else stat_ = ARG_ERR errmsg_ = 'Invalid format \"' // fmt // '\" for read of file \"' // file // '\" ' // & \"into integer array. Format must be one of: \" // join ( INT_FMTS ) return end if end if select rank ( into ) rank ( 1 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank ( 2 ) call from_text ( file , into , header_ , delim_ , fmt_ , stat_ , errmsg_ ) rank default stat_ = ARG_ERR errmsg_ = \"Array has invalid rank. Supported ranks: 1-2.\" return end select else stat_ = ARG_ERR errmsg_ = 'Unsupported file extension \"' // ext // '\" for file \"' // file // '\". Extension must be one of: ' // & join ( TEXT_EXT ) end if end procedure from_textfile_i8 module procedure from_binaryfile_i64 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_i64 module procedure from_binaryfile_i32 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_i32 module procedure from_binaryfile_i16 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_i16 module procedure from_binaryfile_i8 character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( size ( data_shape ) /= rank ( into ) ) then stat_ = ARG_ERR errmsg_ = \"RANK/SHAPE mismatch: size of data_shape must match rank of output array.\" return end if if ( any ( BINARY_EXT == ext ) ) then select rank ( into ) rank ( 1 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 2 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 3 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 4 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 5 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 6 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 7 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 8 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 9 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 10 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 11 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 12 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 13 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 14 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank ( 15 ) call from_binary ( file , into , data_shape , stat_ , errmsg_ ) rank default stat = ARG_ERR errmsg = \"Array has invalid rank. Supported ranks: 1-15.\" return end select else stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". ' // & \"If attempting to read a text file, the data_shape argument must not be specified.\" // & \"If attempting to read a binary file, the supported file extensions are: \" // join ( BINARY_EXT ) return end if end procedure from_binaryfile_i8 end submodule file_io","tags":"","loc":"sourcefile/file_io_impl.f90.html"},{"title":"internal_io_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) internal_io !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interfaces** `String`, `str`, and !! `cast`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) ! Definitions and interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ integer ( i64 ), parameter :: largest_i64 = huge ( 1_i64 ) ! Largest 64-bit signed integer integer ( i32 ), parameter :: largest_i32 = huge ( 1_i32 ) ! Largest 32-bit signed integer integer ( i16 ), parameter :: largest_i16 = huge ( 1_i16 ) ! Largest 16-bit signed integer integer ( i8 ), parameter :: largest_i8 = huge ( 1_i8 ) ! Largest 8-bit signed integer integer ( i64 ), parameter :: smallest_i64 = - huge ( 1_i64 ) - 1_i64 ! Smallest 64-bit signed integer integer ( i32 ), parameter :: smallest_i32 = - huge ( 1_i32 ) - 1_i32 ! Smallest 32-bit signed integer integer ( i16 ), parameter :: smallest_i16 = - huge ( 1_i16 ) - 1_i16 ! Smallest 16-bit signed integer integer ( i8 ), parameter :: smallest_i8 = - huge ( 1_i8 ) - 1_i8 ! Smallest 8-bit signed integer ! Define powers of 10 for each storage size: integer ( i64 ), parameter :: TENS_i64 ( 0 : 18 ) = int ([ 1e0_r64 , 1e1_r64 , 1e2_r64 , 1e3_r64 , & 1e4_r64 , 1e5_r64 , 1e6_r64 , 1e7_r64 , & 1e8_r64 , 1e9_r64 , 1e10_r64 , 1e11_r64 , & 1e12_r64 , 1e13_r64 , 1e14_r64 , 1e15_r64 , & 1e16_r64 , 1e17_r64 , 1e18_r64 ], & kind = i64 ) integer ( i32 ), parameter :: TENS_i32 ( 0 : 9 ) = int ([ 1e0_r32 , 1e1_r32 , 1e2_r32 , 1e3_r32 , & 1e4_r32 , 1e5_r32 , 1e6_r32 , 1e7_r32 , & 1e8_r32 , 1e9_r32 ], & kind = i32 ) integer ( i16 ), parameter :: TENS_i16 ( 0 : 4 ) = int ([ 1e0_r32 , 1e1_r32 , 1e2_r32 , 1e3_r32 , & 1e4_r32 ], & kind = i16 ) integer ( i8 ), parameter :: TENS_i8 ( 0 : 2 ) = int ([ 1e0_r32 , 1e1_r32 , 1e2_r32 ], & kind = i8 ) ! Define powers of 16 for each storage size: integer ( i64 ), parameter :: SIXTEENS_i64 ( 0 : 15 ) = [ 16_i64 ** 0 , 16_i64 ** 1 , 16_i64 ** 2 , 16_i64 ** 3 , & 16_i64 ** 4 , 16_i64 ** 5 , 16_i64 ** 6 , 16_i64 ** 7 , & 16_i64 ** 8 , 16_i64 ** 9 , 16_i64 ** 10 , 16_i64 ** 11 , & 16_i64 ** 12 , 16_i64 ** 13 , 16_i64 ** 14 , 16_i64 ** 15 ] integer ( i32 ), parameter :: SIXTEENS_i32 ( 0 : 7 ) = [ 16_i32 ** 0 , 16_i32 ** 1 , 16_i32 ** 2 , 16_i32 ** 3 , & 16_i32 ** 4 , 16_i32 ** 5 , 16_i32 ** 6 , 16_i32 ** 7 ] integer ( i16 ), parameter :: SIXTEENS_i16 ( 0 : 3 ) = [ 16_i16 ** 0 , 16_i16 ** 1 , 16_i16 ** 2 , 16_i16 ** 3 ] integer ( i8 ), parameter :: SIXTEENS_i8 ( 0 : 1 ) = [ 16_i8 ** 0 , 16_i8 ** 1 ] ! Define hex string digits: character ( len = 1 ), parameter :: DIGITS_A ( 0 : 15 ) = [ \"0\" , \"1\" , \"2\" , \"3\" , \"4\" , \"5\" , \"6\" , \"7\" , \"8\" , \"9\" , \"a\" , \"b\" , \"c\" , \"d\" , \"e\" , \"f\" ] contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< ! String ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure new_string_from_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re /= 0e0_r128 ) then xre_str = \"0x00000000000000000000000000000000\" else xre_str = \"0.0\" ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = \"(z32)\" ) x % re do i = 3 , 34 if ( ( xre_str ( i : i ) >= \"A\" ) . and . ( xre_str ( i : i ) <= \"F\" ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im /= 0e0_r128 ) then xim_str = \"0x00000000000000000000000000000000\" else xim_str = \"0.0\" ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = \"(z32)\" ) x % im do i = 3 , 34 if ( ( xim_str ( i : i ) >= \"A\" ) . and . ( xim_str ( i : i ) <= \"F\" ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r128 ) then xre_str = \"0.0e+0000\" ; exit if_eorf_re end if if ( x % re < 0e0_r128 ) then xre_str = \"00000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % re xre_str ( 39 : 39 ) = \"e\" else xre_str = \"0000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % re xre_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.36)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.100)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r128 ) then xim_str = \"0.0e+0000\" ; exit if_eorf_im end if if ( x % im < 0e0_r128 ) then xim_str = \"00000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % im xim_str ( 39 : 39 ) = \"e\" else xim_str = \"0000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % im xim_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.36)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.100)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then new % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else new % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then new % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r128 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // \"+\" // xim_str // im_ end if end procedure new_string_from_c128 module procedure new_string_from_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i64 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i64 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0e+000\" ; exit if_eorf_re end if if ( x % re < 0e0_r64 ) then xre_str = \"0000000000000000000000000\" write ( unit = xre_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % re xre_str ( 21 : 21 ) = \"e\" else xre_str = \"000000000000000000000000\" write ( unit = xre_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % re xre_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.18)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.80)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0e+000\" ; exit if_eorf_im end if if ( x % im < 0e0_r64 ) then xim_str = \"0000000000000000000000000\" write ( unit = xim_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % im xim_str ( 21 : 21 ) = \"e\" else xim_str = \"000000000000000000000000\" write ( unit = xim_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % im xim_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.18)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.80)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then new % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else new % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then new % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r64 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // \"+\" // xim_str // im_ end if end procedure new_string_from_c64 module procedure new_string_from_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i32 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i32 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0e+00\" ; exit if_eorf_re end if if ( x % re < 0e0_r32 ) then xre_str = \"000000000000000\" write ( unit = xre_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % re xre_str ( 12 : 12 ) = \"e\" else xre_str = \"00000000000000\" write ( unit = xre_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % re xre_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.9)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.70)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0e+00\" ; exit if_eorf_im end if if ( x % im < 0e0_r32 ) then xim_str = \"000000000000000\" write ( unit = xim_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % im xim_str ( 12 : 12 ) = \"e\" else xim_str = \"00000000000000\" write ( unit = xim_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % im xim_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.9)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.70)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then new % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else new % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then new % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r32 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // \"+\" // xim_str // im_ end if end procedure new_string_from_c32 module procedure new_string_from_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x /= 0e0_r128 ) then new % s = \"0x00000000000000000000000000000000\" else new % s = \"0.0\" ; return end if write ( unit = new % s ( 3 :), fmt = \"(z32)\" ) x do i = 3 , 34 if ( ( new % s ( i : i ) >= \"A\" ) . and . ( new % s ( i : i ) <= \"F\" ) ) new % s ( i : i ) = achar ( iachar ( new % s ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r128 ) then new % s = \"0.0e+0000\" ; return end if if ( x < 0e0_r128 ) then new % s = \"00000000000000000000000000000000000000000000\" write ( unit = new % s , fmt = \"(es44.35e4)\" , decimal = decimal ) x new % s ( 39 : 39 ) = \"e\" else new % s = \"0000000000000000000000000000000000000000000\" write ( unit = new % s , fmt = \"(es43.35e4)\" , decimal = decimal ) x new % s ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x ))) else new % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = \"(f0.36)\" , decimal = decimal ) x else write ( unit = new % s , fmt = \"(f0.100)\" , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == \"-\" ) ) ) then new % s ( i + 1 : 125 ) = new % s ( i : 124 ); new % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 36 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 36 - e ) then new % s = new % s (: i + 36 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r128 module procedure new_string_from_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r64 ) then new % s = \"0.0\" ; return end if inline_cast : block integer ( i64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_i64 ) then num = ( x_int + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 1 :) = \"0x0000000000000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r64 ) then new % s = \"0.0e+000\" ; return end if if ( x < 0e0_r64 ) then new % s = \"0000000000000000000000000\" write ( unit = new % s , fmt = \"(es25.17e3)\" , decimal = decimal ) x new % s ( 21 : 21 ) = \"e\" else new % s = \"000000000000000000000000\" write ( unit = new % s , fmt = \"(es24.17e3)\" , decimal = decimal ) x new % s ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x ))) else new % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = \"(f0.18)\" , decimal = decimal ) x else write ( unit = new % s , fmt = \"(f0.80)\" , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == \"-\" ) ) ) then new % s ( i + 1 : 100 ) = new % s ( i : 99 ); new % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 18 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 18 - e ) then new % s = new % s (: i + 18 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r64 module procedure new_string_from_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r32 ) then new % s = \"0.0\" ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_i32 ; negative = . true .; buffer ( 1 :) = \"0x00000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r32 ) then new % s = \"0.0e+00\" ; return end if if ( x < 0e0_r32 ) then new % s = \"000000000000000\" write ( unit = new % s , fmt = \"(es15.8e2)\" , decimal = decimal ) x new % s ( 12 : 12 ) = \"e\" else new % s = \"00000000000000\" write ( unit = new % s , fmt = \"(es14.8e2)\" , decimal = decimal ) x new % s ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x ))) else new % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = \"(f0.9)\" , decimal = decimal ) x else write ( unit = new % s , fmt = \"(f0.70)\" , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == \"-\" ) ) ) then new % s ( i + 1 : 75 ) = new % s ( i : 74 ); new % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 9 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 9 - e ) then new % s = new % s (: i + 9 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r32 module procedure new_string_from_i64 character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( i64 ) :: num , next integer :: ascii_code , i logical :: negative num = 0_i64 ; next = 0_i64 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i64 ) then if ( x == smallest_i64 ) then new % s = \"-9223372036854775808\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_i64 ; buffer ( i : i ) = achar ( num - 10_i64 * next + 48_i64 ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_i64 ) then num = ( x + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 3 :) = \"0x0000000000000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i64 module procedure new_string_from_i32 character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0 ) then if ( x == smallest_i32 ) then new % s = \"-2147483648\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_i32 ; negative = . true .; buffer ( 2 :) = \"0x00000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i32 module procedure new_string_from_i16 character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i16 ) then if ( x == smallest_i16 ) then new % s = \"-32768\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_i16 ) then num = int (( x + 1_i16 ) + largest_i16 ); negative = . true .; buffer ( 1 :) = \"0x0000\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i16 module procedure new_string_from_i8 character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i8 ) then if ( x == smallest_i8 ) then new % s = \"-128\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_i8 ) then num = int (( x + 1_i8 ) + largest_i8 ); negative = . true .; buffer ( 1 :) = \"0x00\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i8 module procedure new_string_from_string if ( x % len () < 1 ) then new % s = EMPTY_STR else new % s = x % s end if end procedure new_string_from_string module procedure new_string_from_char new % s = x end procedure new_string_from_char module procedure new_string_from_empty new % s = EMPTY_STR end procedure new_string_from_empty ! str ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure str_from_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re /= 0e0_r128 ) then xre_str = \"0x00000000000000000000000000000000\" else xre_str = \"0.0\" ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = \"(z32)\" ) x % re do i = 3 , 34 if ( ( xre_str ( i : i ) >= \"A\" ) . and . ( xre_str ( i : i ) <= \"F\" ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im /= 0e0_r128 ) then xim_str = \"0x00000000000000000000000000000000\" else xim_str = \"0.0\" ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = \"(z32)\" ) x % im do i = 3 , 34 if ( ( xim_str ( i : i ) >= \"A\" ) . and . ( xim_str ( i : i ) <= \"F\" ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r128 ) then xre_str = \"0.0e+0000\" ; exit if_eorf_re end if if ( x % re < 0e0_r128 ) then xre_str = \"00000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % re xre_str ( 39 : 39 ) = \"e\" else xre_str = \"0000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % re xre_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.36)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.100)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r128 ) then xim_str = \"0.0e+0000\" ; exit if_eorf_im end if if ( x % im < 0e0_r128 ) then xim_str = \"00000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % im xim_str ( 39 : 39 ) = \"e\" else xim_str = \"0000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % im xim_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.36)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.100)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then x_str = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else x_str = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then x_str = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r128 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // \"+\" // xim_str // im_ end if end procedure str_from_c128 module procedure str_from_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i64 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i64 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0e+000\" ; exit if_eorf_re end if if ( x % re < 0e0_r64 ) then xre_str = \"0000000000000000000000000\" write ( unit = xre_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % re xre_str ( 21 : 21 ) = \"e\" else xre_str = \"000000000000000000000000\" write ( unit = xre_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % re xre_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.18)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.80)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0e+000\" ; exit if_eorf_im end if if ( x % im < 0e0_r64 ) then xim_str = \"0000000000000000000000000\" write ( unit = xim_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % im xim_str ( 21 : 21 ) = \"e\" else xim_str = \"000000000000000000000000\" write ( unit = xim_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % im xim_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.18)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.80)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then x_str = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else x_str = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then x_str = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r64 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // \"+\" // xim_str // im_ end if end procedure str_from_c64 module procedure str_from_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i32 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i32 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0e+00\" ; exit if_eorf_re end if if ( x % re < 0e0_r32 ) then xre_str = \"000000000000000\" write ( unit = xre_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % re xre_str ( 12 : 12 ) = \"e\" else xre_str = \"00000000000000\" write ( unit = xre_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % re xre_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.9)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.70)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0e+00\" ; exit if_eorf_im end if if ( x % im < 0e0_r32 ) then xim_str = \"000000000000000\" write ( unit = xim_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % im xim_str ( 12 : 12 ) = \"e\" else xim_str = \"00000000000000\" write ( unit = xim_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % im xim_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.9)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.70)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then x_str = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else x_str = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then x_str = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r32 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // \"+\" // xim_str // im_ end if end procedure str_from_c32 module procedure str_from_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x /= 0e0_r128 ) then x_str = \"0x00000000000000000000000000000000\" else x_str = \"0.0\" ; return end if write ( unit = x_str ( 3 :), fmt = \"(z32)\" ) x do i = 3 , 34 if ( ( x_str ( i : i ) >= \"A\" ) . and . ( x_str ( i : i ) <= \"F\" ) ) x_str ( i : i ) = achar ( iachar ( x_str ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r128 ) then x_str = \"0.0e+0000\" ; return end if if ( x < 0e0_r128 ) then x_str = \"00000000000000000000000000000000000000000000\" write ( unit = x_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x x_str ( 39 : 39 ) = \"e\" else x_str = \"0000000000000000000000000000000000000000000\" write ( unit = x_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x x_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x ))) else x_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = \"(f0.36)\" , decimal = decimal ) x else write ( unit = x_str , fmt = \"(f0.100)\" , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == \"-\" ) ) ) then x_str ( i + 1 : 125 ) = x_str ( i : 124 ); x_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 36 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 36 - e ) then x_str = x_str (: i + 36 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r128 module procedure str_from_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r64 ) then x_str = \"0.0\" ; return end if call cast ( transfer ( source = x , mold = 1_i64 ), into = x_str , fmt = \"z\" ); return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r64 ) then x_str = \"0.0e+000\" ; return end if if ( x < 0e0_r64 ) then x_str = \"0000000000000000000000000\" write ( unit = x_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x x_str ( 21 : 21 ) = \"e\" else x_str = \"000000000000000000000000\" write ( unit = x_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x x_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x ))) else x_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = \"(f0.18)\" , decimal = decimal ) x else write ( unit = x_str , fmt = \"(f0.80)\" , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == \"-\" ) ) ) then x_str ( i + 1 : 100 ) = x_str ( i : 99 ); x_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 18 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 18 - e ) then x_str = x_str (: i + 18 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r64 module procedure str_from_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r32 ) then x_str = \"0.0\" ; return end if call cast ( transfer ( source = x , mold = 1_i32 ), into = x_str , fmt = \"z\" ); return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r32 ) then x_str = \"0.0e+00\" ; return end if if ( x < 0e0_r32 ) then x_str = \"000000000000000\" write ( unit = x_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x x_str ( 12 : 12 ) = \"e\" else x_str = \"00000000000000\" write ( unit = x_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x x_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x ))) else x_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = \"(f0.9)\" , decimal = decimal ) x else write ( unit = x_str , fmt = \"(f0.70)\" , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == \"-\" ) ) ) then x_str ( i + 1 : 75 ) = x_str ( i : 74 ); x_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 9 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 9 - e ) then x_str = x_str (: i + 9 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r32 module procedure str_from_i64 character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( i64 ) :: num , next integer :: ascii_code , i logical :: negative num = 0_i64 ; next = 0_i64 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i64 ) then if ( x == smallest_i64 ) then x_str = \"-9223372036854775808\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_i64 ; buffer ( i : i ) = achar ( num - 10_i64 * next + 48_i64 ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_i64 ) then num = ( x + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 3 :) = \"0x0000000000000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i64 module procedure str_from_i32 character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( ( any ( INT_FMTS == fmt )) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0 ) then if ( x == smallest_i32 ) then x_str = \"-2147483648\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_i32 ; negative = . true .; buffer ( 2 :) = \"0x00000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i32 module procedure str_from_i16 character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i16 ) then if ( x == smallest_i16 ) then x_str = \"-32768\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_i16 ) then num = int (( x + 1_i16 ) + largest_i16 ); negative = . true .; buffer ( 1 :) = \"0x0000\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i16 module procedure str_from_i8 character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i8 ) then if ( x == smallest_i8 ) then x_str = \"-128\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_i8 ) then num = int (( x + 1_i8 ) + largest_i8 ); negative = . true .; buffer ( 1 :) = \"0x00\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i8 module procedure str_from_string if ( x % len () < 1 ) then x_str = EMPTY_STR else x_str = x % s end if end procedure str_from_string module procedure str_from_char x_str = x end procedure str_from_char module procedure str_from_empty x_str = EMPTY_STR end procedure str_from_empty ! cast ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure cast_c128_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re /= 0e0_r128 ) then xre_str = \"0x00000000000000000000000000000000\" else xre_str = \"0.0\" ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = \"(z32)\" ) x % re do i = 3 , 34 if ( ( xre_str ( i : i ) >= \"A\" ) . and . ( xre_str ( i : i ) <= \"F\" ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im /= 0e0_r128 ) then xim_str = \"0x00000000000000000000000000000000\" else xim_str = \"0.0\" ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = \"(z32)\" ) x % im do i = 3 , 34 if ( ( xim_str ( i : i ) >= \"A\" ) . and . ( xim_str ( i : i ) <= \"F\" ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r128 ) then xre_str = \"0.0e+0000\" ; exit if_eorf_re end if if ( x % re < 0e0_r128 ) then xre_str = \"00000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % re xre_str ( 39 : 39 ) = \"e\" else xre_str = \"0000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % re xre_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.36)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.100)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r128 ) then xim_str = \"0.0e+0000\" ; exit if_eorf_im end if if ( x % im < 0e0_r128 ) then xim_str = \"00000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % im xim_str ( 39 : 39 ) = \"e\" else xim_str = \"0000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % im xim_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.36)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.100)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r128 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c128_to_string module procedure cast_c64_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i64 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i64 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0e+000\" ; exit if_eorf_re end if if ( x % re < 0e0_r64 ) then xre_str = \"0000000000000000000000000\" write ( unit = xre_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % re xre_str ( 21 : 21 ) = \"e\" else xre_str = \"000000000000000000000000\" write ( unit = xre_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % re xre_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.18)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.80)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0e+000\" ; exit if_eorf_im end if if ( x % im < 0e0_r64 ) then xim_str = \"0000000000000000000000000\" write ( unit = xim_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % im xim_str ( 21 : 21 ) = \"e\" else xim_str = \"000000000000000000000000\" write ( unit = xim_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % im xim_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.18)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.80)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r64 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c64_to_string module procedure cast_c32_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i32 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i32 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0e+00\" ; exit if_eorf_re end if if ( x % re < 0e0_r32 ) then xre_str = \"000000000000000\" write ( unit = xre_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % re xre_str ( 12 : 12 ) = \"e\" else xre_str = \"00000000000000\" write ( unit = xre_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % re xre_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.9)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.70)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0e+00\" ; exit if_eorf_im end if if ( x % im < 0e0_r32 ) then xim_str = \"000000000000000\" write ( unit = xim_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % im xim_str ( 12 : 12 ) = \"e\" else xim_str = \"00000000000000\" write ( unit = xim_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % im xim_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.9)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.70)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into % s = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into % s = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into % s = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r32 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c32_to_string module procedure cast_r128_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x /= 0e0_r128 ) then into % s = \"0x00000000000000000000000000000000\" else into % s = \"0.0\" ; return end if write ( unit = into % s ( 3 :), fmt = \"(z32)\" ) x do i = 3 , 34 if ( ( into % s ( i : i ) >= \"A\" ) . and . ( into % s ( i : i ) <= \"F\" ) ) into % s ( i : i ) = achar ( iachar ( into % s ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r128 ) then into % s = \"0.0e+0000\" ; return end if if ( x < 0e0_r128 ) then into % s = \"00000000000000000000000000000000000000000000\" write ( unit = into % s , fmt = \"(es44.35e4)\" , decimal = decimal ) x into % s ( 39 : 39 ) = \"e\" else into % s = \"0000000000000000000000000000000000000000000\" write ( unit = into % s , fmt = \"(es43.35e4)\" , decimal = decimal ) x into % s ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x ))) else into % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 125 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = \"(f0.36)\" , decimal = decimal ) x else write ( unit = into % s , fmt = \"(f0.100)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == \"-\" ) ) ) then into % s ( i + 1 : 125 ) = into % s ( i : 124 ); into % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 36 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 36 - e ) then into % s = into % s (: i + 36 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r128_to_string module procedure cast_r64_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r64 ) then into % s = \"0.0\" ; return end if inline_cast : block integer ( i64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_i64 ) then num = ( x_int + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 1 :) = \"0x0000000000000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r64 ) then into % s = \"0.0e+000\" ; return end if if ( x < 0e0_r64 ) then into % s = \"0000000000000000000000000\" write ( unit = into % s , fmt = \"(es25.17e3)\" , decimal = decimal ) x into % s ( 21 : 21 ) = \"e\" else into % s = \"000000000000000000000000\" write ( unit = into % s , fmt = \"(es24.17e3)\" , decimal = decimal ) x into % s ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x ))) else into % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 100 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = \"(f0.18)\" , decimal = decimal ) x else write ( unit = into % s , fmt = \"(f0.80)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == \"-\" ) ) ) then into % s ( i + 1 : 100 ) = into % s ( i : 99 ); into % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 18 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 18 - e ) then into % s = into % s (: i + 18 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r64_to_string module procedure cast_r32_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r32 ) then into % s = \"0.0\" ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_i32 ; negative = . true .; buffer ( 1 :) = \"0x00000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r32 ) then into % s = \"0.0e+00\" ; return end if if ( x < 0e0_r32 ) then into % s = \"000000000000000\" write ( unit = into % s , fmt = \"(es15.8e2)\" , decimal = decimal ) x into % s ( 12 : 12 ) = \"e\" else into % s = \"00000000000000\" write ( unit = into % s , fmt = \"(es14.8e2)\" , decimal = decimal ) x into % s ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x ))) else into % s = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 75 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = \"(f0.9)\" , decimal = decimal ) x else write ( unit = into % s , fmt = \"(f0.70)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == \"-\" ) ) ) then into % s ( i + 1 : 75 ) = into % s ( i : 74 ); into % s ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 9 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 9 - e ) then into % s = into % s (: i + 9 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r32_to_string module procedure cast_i64_to_string character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( i64 ) :: num , next integer :: ascii_code , i logical :: negative num = 0_i64 ; next = 0_i64 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i64 ) then if ( x == smallest_i64 ) then into % s = \"-9223372036854775808\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_i64 ; buffer ( i : i ) = achar ( num - 10_i64 * next + 48_i64 ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_i64 ) then num = ( x + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 3 :) = \"0x0000000000000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i64_to_string module procedure cast_i32_to_string character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i32 ) then if ( x == smallest_i32 ) then into % s = \"-2147483648\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_i32 ) then num = ( x + 1 ) + largest_i32 ; negative = . true .; buffer ( 2 :) = \"0x00000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i32_to_string module procedure cast_i16_to_string character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i16 ) then if ( x == smallest_i16 ) then into % s = \"-32768\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_i16 ) then num = int (( x + 1_i16 ) + largest_i16 ); negative = . true .; buffer ( 1 :) = \"0x0000\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i16_to_string module procedure cast_i8_to_string character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i8 ) then if ( x == smallest_i8 ) then into % s = \"-128\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_i8 ) then num = int (( x + 1_i8 ) + largest_i8 ); negative = . true .; buffer ( 1 :) = \"0x00\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i8_to_string module procedure cast_c128_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re /= 0e0_r128 ) then xre_str = \"0x00000000000000000000000000000000\" else xre_str = \"0.0\" ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = \"(z32)\" ) x % re do i = 3 , 34 if ( ( xre_str ( i : i ) >= \"A\" ) . and . ( xre_str ( i : i ) <= \"F\" ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im /= 0e0_r128 ) then xim_str = \"0x00000000000000000000000000000000\" else xim_str = \"0.0\" ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = \"(z32)\" ) x % im do i = 3 , 34 if ( ( xim_str ( i : i ) >= \"A\" ) . and . ( xim_str ( i : i ) <= \"F\" ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r128 ) then xre_str = \"0.0e+0000\" ; exit if_eorf_re end if if ( x % re < 0e0_r128 ) then xre_str = \"00000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % re xre_str ( 39 : 39 ) = \"e\" else xre_str = \"0000000000000000000000000000000000000000000\" write ( unit = xre_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % re xre_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.36)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.100)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r128 ) then xim_str = \"0.0e+0000\" ; exit if_eorf_im end if if ( x % im < 0e0_r128 ) then xim_str = \"00000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es44.35e4)\" , decimal = decimal ) x % im xim_str ( 39 : 39 ) = \"e\" else xim_str = \"0000000000000000000000000000000000000000000\" write ( unit = xim_str , fmt = \"(es43.35e4)\" , decimal = decimal ) x % im xim_str ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.36)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.100)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r128 ) then into = xre_str // xim_str // im_ else into = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c128_to_char module procedure cast_c64_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i64 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i64 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r64 ) then xre_str = \"0.0e+000\" ; exit if_eorf_re end if if ( x % re < 0e0_r64 ) then xre_str = \"0000000000000000000000000\" write ( unit = xre_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % re xre_str ( 21 : 21 ) = \"e\" else xre_str = \"000000000000000000000000\" write ( unit = xre_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % re xre_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.18)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.80)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r64 ) then xim_str = \"0.0e+000\" ; exit if_eorf_im end if if ( x % im < 0e0_r64 ) then xim_str = \"0000000000000000000000000\" write ( unit = xim_str , fmt = \"(es25.17e3)\" , decimal = decimal ) x % im xim_str ( 21 : 21 ) = \"e\" else xim_str = \"000000000000000000000000\" write ( unit = xim_str , fmt = \"(es24.17e3)\" , decimal = decimal ) x % im xim_str ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.18)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.80)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r64 ) then into = xre_str // xim_str // im_ else into = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c64_to_char module procedure cast_c32_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == \"z\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0\" ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_i32 ), into = xre_str , fmt = \"z\" ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == \"z\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0\" ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_i32 ), into = xim_str , fmt = \"z\" ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == \"e\" ) then if ( x % re == 0e0_r32 ) then xre_str = \"0.0e+00\" ; exit if_eorf_re end if if ( x % re < 0e0_r32 ) then xre_str = \"000000000000000\" write ( unit = xre_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % re xre_str ( 12 : 12 ) = \"e\" else xre_str = \"00000000000000\" write ( unit = xre_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % re xre_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % re ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = \"0.0\" ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = \"(f0.9)\" , decimal = decimal ) x % re else write ( unit = xre_str , fmt = \"(f0.70)\" , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == \"-\" ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == \"e\" ) then if ( x % im == 0e0_r32 ) then xim_str = \"0.0e+00\" ; exit if_eorf_im end if if ( x % im < 0e0_r32 ) then xim_str = \"000000000000000\" write ( unit = xim_str , fmt = \"(es15.8e2)\" , decimal = decimal ) x % im xim_str ( 12 : 12 ) = \"e\" else xim_str = \"00000000000000\" write ( unit = xim_str , fmt = \"(es14.8e2)\" , decimal = decimal ) x % im xim_str ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x % im ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = \"0.0\" ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = \"(f0.9)\" , decimal = decimal ) x % im else write ( unit = xim_str , fmt = \"(f0.70)\" , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == \"-\" ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == \"POINT\" ) then into = \"(\" // xre_str // COMMA // xim_str // \")\" ; return else into = \"(\" // xre_str // SEMICOLON // xim_str // \")\" ; return end if end if if ( fmt_ == \"z\" ) then into = xre_str // \"+\" // xim_str // im_ ; return end if if ( x % im < 0e0_r32 ) then into = xre_str // xim_str // im_ else into = xre_str // \"+\" // xim_str // im_ end if end procedure cast_c32_to_char module procedure cast_r128_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x /= 0e0_r128 ) then into = \"0x00000000000000000000000000000000\" else into = \"0x0\" ; return end if write ( unit = into ( 3 :), fmt = \"(z32)\" ) x do i = 3 , 34 if ( ( into ( i : i ) >= \"A\" ) . and . ( into ( i : i ) <= \"F\" ) ) into ( i : i ) = achar ( iachar ( into ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r128 ) then into = \"0.0e+0000\" ; return end if if ( x < 0e0_r128 ) then into = \"00000000000000000000000000000000000000000000\" write ( unit = into , fmt = \"(es44.35e4)\" , decimal = decimal ) x into ( 39 : 39 ) = \"e\" else into = \"0000000000000000000000000000000000000000000\" write ( unit = into , fmt = \"(es43.35e4)\" , decimal = decimal ) x into ( 38 : 38 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r128 ) then e = int ( log10 ( abs ( x ))) else into = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 125 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = \"(f0.36)\" , decimal = decimal ) x else write ( unit = into , fmt = \"(f0.100)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == \"-\" ) ) ) then into ( i + 1 : 125 ) = into ( i : 124 ); into ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 36 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 36 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 36 - e ) then into = into (: i + 36 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r128_to_char module procedure cast_r64_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r64 ) then into = \"0x0\" ; return end if inline_cast : block integer ( i64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_i64 ) then num = ( x_int + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 1 :) = \"0x0000000000000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r64 ) then into = \"0.0e+000\" ; return end if if ( x < 0e0_r64 ) then into = \"0000000000000000000000000\" write ( unit = into , fmt = \"(es25.17e3)\" , decimal = decimal ) x into ( 21 : 21 ) = \"e\" else into = \"000000000000000000000000\" write ( unit = into , fmt = \"(es24.17e3)\" , decimal = decimal ) x into ( 20 : 20 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r64 ) then e = int ( log10 ( abs ( x ))) else into = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 100 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = \"(f0.18)\" , decimal = decimal ) x else write ( unit = into , fmt = \"(f0.80)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == \"-\" ) ) ) then into ( i + 1 : 100 ) = into ( i : 99 ); into ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 18 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 18 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 18 - e ) then into = into (: i + 18 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r64_to_char module procedure cast_r32_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i e = 0 ; decimals_ = 0 ; i = 0 if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"z\" ) then if ( x == 0e0_r32 ) then into = \"0x0\" ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_i32 ; negative = . true .; buffer ( 1 :) = \"0x00000000\" else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = EMPTY_STR ; return end if end if if ( fmt_ == \"e\" ) then if ( x == 0e0_r32 ) then into = \"0.0e+00\" ; return end if if ( x < 0e0_r32 ) then into = \"000000000000000\" write ( unit = into , fmt = \"(es15.8e2)\" , decimal = decimal ) x into ( 12 : 12 ) = \"e\" else into = \"00000000000000\" write ( unit = into , fmt = \"(es14.8e2)\" , decimal = decimal ) x into ( 11 : 11 ) = \"e\" end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == \"f\" ) then if ( abs ( x ) /= 0e0_r32 ) then e = int ( log10 ( abs ( x ))) else into = \"0.0\" ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 75 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = \"(f0.9)\" , decimal = decimal ) x else write ( unit = into , fmt = \"(f0.70)\" , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == \"-\" ) ) ) then into ( i + 1 : 75 ) = into ( i : 74 ); into ( i : i ) = \"0\" ; i = i + 1 end if if ( i > 9 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 9 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 9 - e ) then into = into (: i + 9 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r32_to_char module procedure cast_i64_to_char character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( i64 ) :: num , next integer :: ascii_code , i logical :: negative num = 0_i64 ; next = 0_i64 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i64 ) then if ( x == smallest_i64 ) then into = \"-9223372036854775808\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_i64 ; buffer ( i : i ) = achar ( num - 10_i64 * next + 48_i64 ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_i64 ) then num = ( x + 1_i64 ) + largest_i64 ; negative = . true .; buffer ( 3 :) = \"0x0000000000000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_i64 ; buffer ( i : i ) = DIGITS_A ( num - 16_i64 * next ); if ( next == 0_i64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if into = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end if end procedure cast_i64_to_char module procedure cast_i32_to_char character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i32 ) then if ( x == smallest_i32 ) then into = \"-2147483648\" ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_i32 ) then num = ( x + 1 ) + largest_i32 ; negative = . true .; buffer ( 2 :) = \"0x00000000\" else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if into = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end if end procedure cast_i32_to_char module procedure cast_i16_to_char character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i16 ) then if ( x == smallest_i16 ) then into = \"-32768\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_i16 ) then num = int (( x + 1_i16 ) + largest_i16 ); negative = . true .; buffer ( 1 :) = \"0x0000\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end if end procedure cast_i16_to_char module procedure cast_i8_to_char character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative num = 0 ; next = 0 ; ascii_code = 0 ; i = 0 ; negative = . false . if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == \"i\" ) then if ( x < 0_i8 ) then if ( x == smallest_i8 ) then into = \"-128\" ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = \"-\" ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_i8 ) then num = int (( x + 1_i8 ) + largest_i8 ); negative = . true .; buffer ( 1 :) = \"0x00\" else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = \"0x\" ; into = buffer ( i - 2 :); return end if end if end procedure cast_i8_to_char module procedure cast_string_to_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r128 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r128 ; z_im = 0e0_r128 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0e0_r128 , 0e0_r128 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r128 , 0e0_r128 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r128 , 0e0_r128 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then if ( i - l - 1 > 2 ) then if ( substring % s ( l + 1 : l + 2 ) == \"0x\" ) then read ( unit = substring % s ( l + 3 : i - 1 ), fmt = \"(z100)\" ) z_re else read ( unit = substring % s ( l + 1 : i - 1 ), fmt = \"(z100)\" ) z_re end if else read ( unit = substring % s ( l + 1 : i - 1 ), fmt = \"(z100)\" ) z_re end if if ( r - i - 1 > 2 ) then if ( substring % s ( i + 1 : i + 2 ) == \"0x\" ) then read ( unit = substring % s ( i + 3 : r - 1 ), fmt = \"(z100)\" ) z_im else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if into = cmplx ( z_re , z_im , kind = r128 ); return else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r128 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then if ( i - l > 2 ) then if ( substring % s ( l : l + 1 ) == \"0x\" ) then read ( unit = substring % s ( l + 2 : i - 1 ), fmt = \"(z100)\" ) z_re else read ( unit = substring % s ( l : i - 1 ), fmt = \"(z100)\" ) z_re end if else read ( unit = substring % s ( l : i - 1 ), fmt = \"(z100)\" ) z_re end if if ( r - i - 1 > 2 ) then if ( substring % s ( i + 1 : i + 2 ) == \"0x\" ) then read ( unit = substring % s ( i + 3 : r - 1 ), fmt = \"(z100)\" ) z_im else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if into = cmplx ( z_re , z_im , kind = r128 ); return else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r128 ); return end if end procedure cast_string_to_c128 module procedure cast_string_to_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r64 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r64 ; z_im = 0e0_r64 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0e0_r64 , 0e0_r64 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r64 , 0e0_r64 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r64 , 0e0_r64 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then block ; integer ( i64 ) :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l + 1 : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r64 ); return end block else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r64 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then block ; integer ( i64 ) :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r64 ); return end block else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r64 ); return end if end procedure cast_string_to_c64 module procedure cast_string_to_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r32 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r32 ; z_im = 0e0_r32 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0e0_r32 , 0e0_r32 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r32 , 0e0_r32 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r32 , 0e0_r32 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then block ; integer :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l + 1 : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r32 ); return end block else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r32 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then block ; integer :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r32 ); return end block else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r32 ); return end if end procedure cast_string_to_c32 module procedure cast_string_to_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0e0_r128 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r128 ; return end if end if if ( fmt_ == \"z\" ) then if ( substring % len () > 2 ) then if ( substring % s ( 1 : 2 ) == \"0x\" ) then read ( unit = substring % s ( 3 :), fmt = \"(z100)\" ) into ; return else read ( unit = substring % s , fmt = \"(z100)\" ) into ; return end if else read ( unit = substring % s , fmt = \"(z100)\" ) into ; return end if end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r128 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r128 module procedure cast_string_to_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0e0_r64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r64 ; return end if end if if ( fmt_ == \"z\" ) then inline_cast : block ; integer ( i64 ) :: num ; integer :: substring_len , r , l , i , digit ; logical :: negative substring_len = substring % len () r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if num = 0_i64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then num = num + int ( digit , i64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; num = num + int ( digit , i64 ) * SIXTEENS_i64 ( i ) num = ( num - 1_i64 ) - largest_i64 into = transfer ( source = num , mold = into ); return else num = num + int ( digit , i64 ) * SIXTEENS_i64 ( i ) into = transfer ( source = num , mold = into ); return end if end if end do end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r64 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r64 module procedure cast_string_to_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0e0_r32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r32 ; return end if end if if ( fmt_ == \"z\" ) then inline_cast : block ; integer :: num , substring_len , r , l , i , digit ; logical :: negative substring_len = substring % len () r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if num = 0 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then num = num + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; num = num + digit * SIXTEENS_i32 ( i ) num = ( num - 1 ) - largest_i32 into = transfer ( source = num , mold = into ); return else num = num + digit * SIXTEENS_i32 ( i ) into = transfer ( source = num , mold = into ); return end if end if end do end block inline_cast end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r32 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r32 module procedure cast_string_to_i64 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = substring % len () if ( substring_len < 1 ) then into = 0_i64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i64 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i64 do i = 0 , ubound ( TENS_i64 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , i64 ) * TENS_i64 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ) into = ( into - 1_i64 ) - largest_i64 ; return else into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ); return end if end if end do end if end procedure cast_string_to_i64 module procedure cast_string_to_i32 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = substring % len () if ( substring_len < 1 ) then into = 0_i32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i32 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i32 do i = 0 , ubound ( TENS_i32 , dim = 1 ) into = into + ( iachar ( substring % s ( r : r )) - 48 ) * TENS_i32 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i32 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + digit * SIXTEENS_i32 ( i ) into = ( into - 1 ) - largest_i32 ; return else into = into + digit * SIXTEENS_i32 ( i ); return end if end if end do end if end procedure cast_string_to_i32 module procedure cast_string_to_i16 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = substring % len () if ( substring_len < 1 ) then into = 0_i16 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i16 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i16 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , i16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 4 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i16 do i = 0 , ubound ( SIXTEENS_i16 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ) into = ( into - 1_i16 ) - largest_i16 ; return else into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ); return end if end if end do end if end procedure cast_string_to_i16 module procedure cast_string_to_i8 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = substring % len () if ( substring_len < 1 ) then into = 0_i8 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i8 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i8 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , i16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 2 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i8 do i = 0 , ubound ( SIXTEENS_i8 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ) into = ( into - 1_i8 ) - largest_i8 ; return else into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ); return end if end if end do end if end procedure cast_string_to_i8 module procedure cast_char_to_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r128 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r128 ; z_im = 0e0_r128 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0e0_r128 , 0e0_r128 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r128 , 0e0_r128 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r128 , 0e0_r128 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then if ( i - l - 1 > 2 ) then if ( substring ( l + 1 : l + 2 ) == \"0x\" ) then read ( unit = substring ( l + 3 : i - 1 ), fmt = \"(z100)\" ) z_re else read ( unit = substring ( l + 1 : i - 1 ), fmt = \"(z100)\" ) z_re end if else read ( unit = substring ( l + 1 : i - 1 ), fmt = \"(z100)\" ) z_re end if if ( r - i - 1 > 2 ) then if ( substring ( i + 1 : i + 2 ) == \"0x\" ) then read ( unit = substring ( i + 3 : r - 1 ), fmt = \"(z100)\" ) z_im else read ( unit = substring ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if else read ( unit = substring ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if into = cmplx ( z_re , z_im , kind = r128 ); return else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r128 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then if ( i - l > 2 ) then if ( substring ( l : l + 1 ) == \"0x\" ) then read ( unit = substring ( l + 2 : i - 1 ), fmt = \"(z100)\" ) z_re else read ( unit = substring ( l : i - 1 ), fmt = \"(z100)\" ) z_re end if else read ( unit = substring ( l : i - 1 ), fmt = \"(z100)\" ) z_re end if if ( r - i - 1 > 2 ) then if ( substring ( i + 1 : i + 2 ) == \"0x\" ) then read ( unit = substring ( i + 3 : r - 1 ), fmt = \"(z100)\" ) z_im else read ( unit = substring ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if else read ( unit = substring ( i + 1 : r - 1 ), fmt = \"(z100)\" ) z_im end if into = cmplx ( z_re , z_im , kind = r128 ); return else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r128 ); return end if end procedure cast_char_to_c128 module procedure cast_char_to_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r64 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r64 ; z_im = 0e0_r64 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0e0_r64 , 0e0_r64 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r64 , 0e0_r64 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r64 , 0e0_r64 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then block ; integer ( i64 ) :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l + 1 : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r64 ); return end block else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r64 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then block ; integer ( i64 ) :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r64 ); return end block else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r64 ); return end if end procedure cast_char_to_c64 module procedure cast_char_to_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( r32 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len z_re = 0e0_r32 ; z_im = 0e0_r32 ; substring_len = 0 ; l = 0 ; r = 0 ; i = 0 ; sep_code = 0 ; e_code = 0 ; im_len = 0 substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0e0_r32 , 0e0_r32 ); return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0e0_r32 , 0e0_r32 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = ( 0e0_r32 , 0e0_r32 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == \"POINT\" ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == \"z\" ) then block ; integer :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l + 1 : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r32 ); return end block else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r32 ); return end if end if sep_code = iachar ( \"+\" ); e_code = iachar ( \"e\" ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == \"z\" ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == \"z\" ) then block ; integer :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = \"z\" ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = \"z\" ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = r32 ); return end block else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = r32 ); return end if end procedure cast_char_to_c32 module procedure cast_char_to_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( len ( substring ) < 1 ) then into = 0e0_r128 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r128 ; return end if end if if ( fmt_ == \"z\" ) then if ( len ( substring ) > 2 ) then if ( substring ( 1 : 2 ) == \"0x\" ) then read ( unit = substring ( 3 :), fmt = \"(z100)\" ) into ; return else read ( unit = substring , fmt = \"(z100)\" ) into ; return end if else read ( unit = substring , fmt = \"(z100)\" ) into ; return end if end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r128 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r128 module procedure cast_char_to_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer ( i64 ) :: num if ( len ( substring ) < 1 ) then into = 0e0_r64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r64 ; return end if end if if ( fmt_ == \"z\" ) then call cast ( substring , into = num , fmt = \"z\" ) into = transfer ( source = num , mold = into ) return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r64 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r64 module procedure cast_char_to_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer ( i32 ) :: num if ( len ( substring ) < 1 ) then into = 0e0_r32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"e\" else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0e0_r32 ; return end if end if if ( fmt_ == \"z\" ) then call cast ( substring , into = num , fmt = \"z\" ) into = transfer ( source = num , mold = into ) return end if if ( . not . present ( locale ) ) then decimal = \"POINT\" else if ( locale == \"US\" ) then decimal = \"POINT\" else if ( locale == \"EU\" ) then decimal = \"COMMA\" else into = 0e0_r32 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r32 module procedure cast_char_to_i64 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_i64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i64 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i64 do i = 0 , ubound ( TENS_i64 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , i64 ) * TENS_i64 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ) into = ( into - 1_i64 ) - largest_i64 ; return else into = into + int ( digit , i64 ) * SIXTEENS_i64 ( i ); return end if end if end do end if end procedure cast_char_to_i64 module procedure cast_char_to_i32 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_i32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i32 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i32 do i = 0 , ubound ( TENS_i32 , dim = 1 ) into = into + ( iachar ( substring ( r : r )) - 48 ) * TENS_i32 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i32 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + digit * SIXTEENS_i32 ( i ) into = ( into - 1 ) - largest_i32 ; return else into = into + digit * SIXTEENS_i32 ( i ); return end if end if end do end if end procedure cast_char_to_i32 module procedure cast_char_to_i16 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_i16 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i16 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i16 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , i16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 4 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i16 do i = 0 , ubound ( SIXTEENS_i16 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ) into = ( into - 1_i16 ) - largest_i16 ; return else into = into + int ( digit , i16 ) * SIXTEENS_i16 ( i ); return end if end if end do end if end procedure cast_char_to_i16 module procedure cast_char_to_i8 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = 0 ; r = 0 ; l = 0 ; i = 0 ; digit = 0 ; negative = . false . substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_i8 ; return end if if ( . not . present ( fmt ) ) then fmt_ = \"i\" else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_i8 ; return end if end if if ( fmt_ == \"i\" ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_i8 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , i16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 2 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_i8 do i = 0 , ubound ( SIXTEENS_i8 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ) into = ( into - 1_i8 ) - largest_i8 ; return else into = into + int ( digit , i8 ) * SIXTEENS_i8 ( i ); return end if end if end do end if end procedure cast_char_to_i8 end submodule internal_io","tags":"","loc":"sourcefile/internal_io_impl.f90.html"},{"title":"join_split_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) join_split !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interfaces** `join` and `split`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< module procedure join_char type ( String ) :: temp_String character ( len = :), allocatable :: separator_ if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if temp_String = join ( String ( tokens ), separator = separator_ ) if ( temp_String % len () < 1 ) then new = EMPTY_STR else new = temp_String % s end if end procedure join_char module procedure join_string type ( String ) :: token_pair ( 2 ) character ( len = :), allocatable :: separator_ integer ( i64 ) :: num_tokens num_tokens = size ( tokens , kind = i64 ) if ( num_tokens == 1_i64 ) then if ( tokens ( 1_i64 )% len64 () < 1_i64 ) then new % s = EMPTY_STR ; return else new % s = tokens ( 1_i64 )% s ; return end if end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if if ( num_tokens > 500_i64 ) then new = join ( tokens = [ join ( tokens (: num_tokens / 2_i64 ), separator_ ), & join ( tokens ( 1_i64 + num_tokens / 2_i64 :), separator_ ) ], separator = separator_ ) else call new % join_base ( tokens = tokens , separator = separator_ ) end if end procedure join_string module procedure split_char character ( len = :), allocatable :: separator_ if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if tokens = split ( String ( substring ), separator = separator_ ) end procedure split_char module procedure split_string character ( len = :), allocatable :: separator_ integer ( i64 ) :: substring_len , l , i integer :: sep_len , num_seps , sep , token , current substring_len = 0_i64 ; l = 0_i64 ; i = 0_i64 ; sep_len = 0 ; num_seps = 0 ; sep = 0 ; token = 0 ; current = 0 substring_len = substring % len64 () if ( substring_len < 1_i64 ) then allocate ( tokens ( 1 ) ); tokens ( 1 )% s = EMPTY_STR ; return end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if sep_len = len ( separator_ ) if ( sep_len == 0 ) then allocate ( tokens ( substring_len ) ) do i = 1_i64 , substring_len tokens ( i )% s = substring % s ( i : i ) end do return end if num_seps = substring % count ( match = separator_ ) if ( num_seps == 0 ) then allocate ( tokens ( 1 ) ); tokens ( 1 )% s = substring % s ; return end if allocate ( tokens ( num_seps + 1 ) ) sep = iachar ( separator_ ( 1 : 1 )) i = 1_i64 ; l = 1_i64 ; token = 1 ; positional_transfers : do current = iachar ( substring % s ( i : i )) if ( current /= sep ) then i = i + 1_i64 ; cycle end if if ( sep_len == 1 ) then tokens ( token )% s = substring % s ( l : i - 1 ) if ( token == num_seps ) then tokens ( num_seps + 1 )% s = substring % s ( i + 1 :); return end if token = token + 1 ; i = i + 1_i64 ; l = i ; cycle else if ( substring % s ( i : i + sep_len - 1 ) == separator_ ) then tokens ( token )% s = substring % s ( l : i - 1 ) if ( token == num_seps ) then tokens ( num_seps + 1 )% s = substring % s ( i + sep_len :); return end if token = token + 1 ; i = i + sep_len ; l = i ; cycle else i = i + 1_i64 ; cycle end if end if end do positional_transfers end procedure split_string end submodule join_split","tags":"","loc":"sourcefile/join_split_impl.f90.html"},{"title":"operators_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) operators !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interfaces** `operator(//)`, !! `operator(+)`, `operator(-)`, `operator(**)`, `operator(==)`, and `operator(/=)`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< module procedure string_concatenation if ( Stringl % len () < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // Stringr % s end procedure string_concatenation module procedure string_char_concatenation if ( Stringl % len () < 1 ) then if ( len ( charsr ) < 1 ) then new % s = EMPTY_STR ; return else new % s = charsr ; return end if end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // charsr end procedure string_char_concatenation module procedure char_string_concatenation if ( len ( charsl ) < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = charsl ; return end if new % s = charsl // Stringr % s end procedure char_string_concatenation module procedure char_concat_plus new = charsl // charsr end procedure char_concat_plus module procedure string_concat_plus if ( Stringl % len () < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // Stringr % s end procedure string_concat_plus module procedure string_char_concat_plus if ( Stringl % len () < 1 ) then if ( len ( charsr ) < 1 ) then new % s = EMPTY_STR ; return else new % s = charsr ; return end if end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // charsr end procedure string_char_concat_plus module procedure char_string_concat_plus if ( len ( charsl ) < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = charsl ; return end if new % s = charsl // Stringr % s end procedure char_string_concat_plus module procedure char_excision type ( String ) :: Stringl Stringl % s = charsl if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = charsr , substring = EMPTY_STR ) end procedure char_excision module procedure string_excision if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = Stringr % s , substring = EMPTY_STR ) end procedure string_excision module procedure string_char_excision if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = charsr , substring = EMPTY_STR ) end procedure string_char_excision module procedure char_string_excision type ( String ) :: Stringl Stringl % s = charsl if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = Stringr % s , substring = EMPTY_STR ) end procedure char_string_excision module procedure repeat_chars new = repeat ( char_base , ncopies = ncopies ) end procedure repeat_chars module procedure repeat_String if ( String_base % len () < 1 ) then new % s = EMPTY_STR ; return end if new % s = repeat ( String_base % s , ncopies = ncopies ) end procedure repeat_String module procedure string_equivalence integer :: Stringl_len , Stringr_len Stringl_len = Stringl % len () Stringr_len = Stringr % len () if ( Stringl_len /= Stringr_len ) then equal = . false .; return end if if ( Stringl_len < 1 ) then equal = . true .; return end if equal = ( Stringl % s == Stringr % s ) end procedure string_equivalence module procedure string_char_equivalence integer :: Stringl_len , charsr_len Stringl_len = Stringl % len () charsr_len = len ( charsr ) if ( Stringl_len /= charsr_len ) then equal = . false .; return end if if ( Stringl_len < 1 ) then equal = . true .; return end if equal = ( Stringl % s == charsr ) end procedure string_char_equivalence module procedure char_string_equivalence integer :: charsl_len , Stringr_len charsl_len = len ( charsl ) Stringr_len = Stringr % len () if ( charsl_len /= Stringr_len ) then equal = . false .; return end if if ( charsl_len < 1 ) then equal = . true .; return end if equal = ( charsl == Stringr % s ) end procedure char_string_equivalence module procedure string_nonequivalence integer :: Stringl_len , Stringr_len Stringl_len = Stringl % len () Stringr_len = Stringr % len () if ( Stringl_len /= Stringr_len ) then unequal = . true .; return end if if ( Stringl_len < 1 ) then unequal = . false .; return end if unequal = ( Stringl % s /= Stringr % s ) end procedure string_nonequivalence module procedure string_char_nonequivalence integer :: Stringl_len , charsr_len Stringl_len = Stringl % len () charsr_len = len ( charsr ) if ( Stringl_len /= charsr_len ) then unequal = . true .; return end if if ( Stringl_len < 1 ) then unequal = . false .; return end if unequal = ( Stringl % s /= charsr ) end procedure string_char_nonequivalence module procedure char_string_nonequivalence integer :: charsl_len , Stringr_len charsl_len = len ( charsl ) Stringr_len = Stringr % len () if ( charsl_len /= Stringr_len ) then unequal = . true .; return end if if ( charsl_len < 1 ) then unequal = . false .; return end if unequal = ( charsl /= Stringr % s ) end procedure char_string_nonequivalence end submodule operators","tags":"","loc":"sourcefile/operators_impl.f90.html"},{"title":"string_methods_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) string_methods !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **type-bound procedures** of type `String`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) ! Definitions and interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 1 ), target :: LINE_FEED = LF , COMMA_DELIMITER = COMMA logical , target :: NO_APPEND = . false . contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< module procedure as_str if ( self % len () < 1 ) then string_slice = EMPTY_STR else string_slice = self % s end if end procedure as_str module procedure count_substring_chars integer ( i64 ) :: self_len , match_len , max_pos , upper_ind , i , j integer :: first_char , last_char self_len = 0_i64 ; match_len = 0_i64 ; max_pos = 0_i64 ; upper_ind = 0_i64 ; i = 0_i64 ; j = 0_i64 ; first_char = 0 ; last_char = 0 self_len = self % len64 () match_len = len ( match , kind = i64 ) if ( self_len < 1_i64 ) then if ( self_len == match_len ) then occurrences = 1 ; return else occurrences = 0 ; return end if end if if ( ( match_len == 0_i64 ) . or . ( match_len > self_len ) ) then occurrences = 0 ; return end if occurrences = 0 ; max_pos = self_len - match_len + 1_i64 first_char = iachar ( match ( 1 : 1 )); last_char = iachar ( match ( match_len : match_len )) if ( match_len == 1_i64 ) then i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle else occurrences = occurrences + 1 ; i = i + 1_i64 ; cycle end if end do end if if ( match_len == 2_i64 ) then i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle end if if ( iachar ( self % s ( i + 1_i64 : i + 1_i64 )) /= last_char ) then i = i + 1_i64 ; cycle else occurrences = occurrences + 1 ; i = i + 2_i64 ; cycle end if end do end if i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle end if upper_ind = i + match_len - 1_i64 if ( iachar ( self % s ( upper_ind : upper_ind )) /= last_char ) then i = i + 1_i64 ; cycle end if if ( self % s ( i : upper_ind ) == match ) then occurrences = occurrences + 1 ; i = i + match_len ; cycle else i = i + 1_i64 ; cycle end if end do end procedure count_substring_chars module procedure count_substring_string integer ( i64 ) :: self_len , match_len , max_pos , upper_ind , i , j integer :: first_char , last_char self_len = 0_i64 ; match_len = 0_i64 ; max_pos = 0_i64 ; upper_ind = 0_i64 ; i = 0_i64 ; j = 0_i64 ; first_char = 0 ; last_char = 0 self_len = self % len64 () match_len = match % len64 () if ( self_len < 1_i64 ) then if ( self_len == match_len ) then occurrences = 1 ; return else occurrences = 0 ; return end if end if if ( ( match_len == 0_i64 ) . or . ( match_len > self_len ) ) then occurrences = 0 ; return end if occurrences = 0 ; max_pos = self_len - match_len + 1_i64 first_char = iachar ( match % s ( 1 : 1 )); last_char = iachar ( match % s ( match_len : match_len )) if ( match_len == 1_i64 ) then i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle else occurrences = occurrences + 1 ; i = i + 1_i64 ; cycle end if end do end if if ( match_len == 2_i64 ) then i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle end if if ( iachar ( self % s ( i + 1_i64 : i + 1_i64 )) /= last_char ) then i = i + 1_i64 ; cycle else occurrences = occurrences + 1 ; i = i + 2_i64 ; cycle end if end do end if i = 1_i64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_i64 ; cycle end if upper_ind = i + match_len - 1_i64 if ( iachar ( self % s ( upper_ind : upper_ind )) /= last_char ) then i = i + 1_i64 ; cycle end if if ( self % s ( i : upper_ind ) == match % s ) then occurrences = occurrences + 1 ; i = i + match_len ; cycle else i = i + 1_i64 ; cycle end if end do end procedure count_substring_string module procedure empty self % s = EMPTY_STR end procedure empty module procedure join_into_self type ( String ) :: token_pair ( 2 ) character ( len = :), allocatable :: separator_ integer ( i64 ) :: num_tokens type ( String ) :: comp logical :: GCC num_tokens = size ( tokens , kind = i64 ); GCC = . false . if ( num_tokens == 1_i64 ) then if ( tokens ( 1_i64 )% len64 () < 1_i64 ) then self % s = EMPTY_STR ; return else self % s = tokens ( 1_i64 )% s ; return end if end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if comp % s = COMPILER ; GCC = ( comp % count ( match = \"GCC\" ) > 0 ); deallocate ( comp % s ) if ( num_tokens > 500_i64 ) then if ( GCC ) then call self % join ( tokens = [ join ( tokens (: num_tokens / 2_i64 ), separator_ ), & join ( tokens ( 1_i64 + num_tokens / 2_i64 :), separator_ ) ], separator = separator_ ) else call token_pair ( 1 )% join ( tokens (: num_tokens / 2_i64 ), separator_ ) call token_pair ( 2 )% join ( tokens ( 1_i64 + num_tokens / 2_i64 :), separator_ ) call self % join ( tokens = token_pair , separator = separator_ ) end if else call self % join_base ( tokens = tokens , separator = separator_ ) end if end procedure join_into_self module procedure join_base integer ( i64 ), dimension ( size ( tokens , kind = i64 )) :: lengths , cumm_lengths integer ( i64 ) :: num_tokens , sep_len , total_length , pos , i lengths = 0_i64 ; cumm_lengths = 0_i64 ; num_tokens = 0_i64 ; sep_len = 0_i64 ; total_length = 0_i64 ; pos = 0_i64 ; i = 0_i64 num_tokens = size ( tokens , kind = i64 ) lengths = tokens % len64 () sep_len = len ( separator , kind = i64 ) where ( lengths == - 1_i64 ) lengths = 0_i64 total_length = sum ( lengths ) if ( total_length == 0_i64 ) then self % s = EMPTY_STR ; return end if cumm_lengths ( 1_i64 ) = 1_i64 do i = 2_i64 , num_tokens cumm_lengths ( i ) = sum ( lengths (: i - 1_i64 ) ) + 1_i64 end do if ( allocated ( self % s ) ) deallocate ( self % s ) total_length = total_length + ( num_tokens - 1_i64 ) * sep_len allocate ( character ( len = total_length ) :: self % s ) positional_transfer : do i = 1_i64 , num_tokens pos = cumm_lengths ( i ) + ( i - 1_i64 ) * sep_len if ( lengths ( i ) > 0_i64 ) then self % s ( pos : pos + lengths ( i ) - 1_i64 ) = tokens ( i )% s if ( sep_len > 0_i64 ) then if ( i < num_tokens ) self % s ( pos + lengths ( i ): pos + lengths ( i ) + sep_len - 1_i64 ) = separator end if else if ( sep_len > 0_i64 ) then if ( i < num_tokens ) self % s ( pos : pos + sep_len - 1_i64 ) = separator end if end if end do positional_transfer end procedure join_base module procedure length if ( . not . allocated ( self % s ) ) then self_len = - 1 else self_len = len ( self % s ) end if end procedure length module procedure length64 if ( . not . allocated ( self % s ) ) then self_len = - 1_i64 else self_len = len ( self % s , kind = i64 ) end if end procedure length64 module procedure push_chars if ( self % len () < 1 ) then self % s = substring else self % s = self % s // substring end if end procedure push_chars module procedure push_string if ( self % len () < 1 ) then if ( substring % len () < 1 ) then self % s = EMPTY_STR else self % s = substring % s end if else if ( substring % len () < 1 ) then return else self % s = self % s // substring % s end if end if end procedure push_string module procedure read_file character ( len = :), allocatable :: ext character ( len = :), pointer :: errmsg_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat integer ( i64 ) :: file_length integer :: file_unit logical :: exists ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( . not . any ( TEXT_EXT == ext ) ) then stat_ = ARG_ERR errmsg_ = 'Error reading file \"' // file // '\" with extension \"' // ext // '\". To use read_file, the data to ' // & \"be read into a String must be formatted as text with one of the following file extensions: \" // & join ( TEXT_EXT ) return end if inquire ( file = file , exist = exists , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat_ , iomsg = errmsg_ ) else stat_ = READ_ERR errmsg_ = 'Error reading file \"' // file // '\". No such file exists.' return end if if ( stat_ /= 0 ) then stat_ = READ_ERR ; return end if inquire ( file = file , size = file_length , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = READ_ERR ; return end if if ( file_length == 0_i64 ) then stat_ = READ_ERR errmsg_ = 'Error reading file \"' // file // '\". File is empty.' return end if if ( allocated ( self % s ) ) deallocate ( self % s , stat = stat_ , errmsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = ALLOC_ERR ; return end if allocate ( character ( len = file_length ) :: self % s , stat = stat_ , errmsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = ALLOC_ERR ; return end if read ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) self % s if ( stat_ /= 0 ) then stat_ = READ_ERR ; return end if close ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = READ_ERR ; return end if if ( . not . present ( cell_array ) ) then if ( present ( row_separator ) ) write ( * , \"(a)\" ) LF // 'WARNING: Row separator was provided for read of file \"' // & file // '\" without a cell array output. Ingoring argument...' if ( present ( column_separator ) ) write ( * , \"(a)\" ) LF // 'WARNING: Column separator was provided for read of file \"' // & file // '\" without a cell array output. Ingoring argument...' return end if if ( present ( row_separator ) ) then if ( len ( row_separator ) == 0 ) then stat_ = ARG_ERR errmsg_ = 'Error: Cannot populate a cell array with the contents of file \"' // file // '\" ' // & \"using an empty row separator.\" return end if end if if ( present ( column_separator ) ) then if ( len ( column_separator ) == 0 ) then stat_ = ARG_ERR errmsg_ = 'Error: Cannot populate a cell array with the contents of file \"' // file // '\" ' // & \"using an empty column separator.\" return end if end if cell_block : block character ( len = :), pointer :: row_separator_ , column_separator_ integer ( i64 ) :: l , i integer :: nrows , ncols , row , col , row_sep , row_sep_len , col_sep , col_sep_len , quote , current logical :: in_quote l = 0_i64 ; i = 0_i64 nrows = 0 ; ncols = 0 ; row = 0 ; col = 0 ; row_sep = 0 ; row_sep_len = 0 ; col_sep = 0 ; col_sep_len = 0 ; quote = 0 ; current = 0 in_quote = . false . if ( . not . present ( row_separator ) ) then row_separator_ => LINE_FEED else row_separator_ => row_separator end if if ( . not . present ( column_separator ) ) then column_separator_ => COMMA_DELIMITER else column_separator_ => column_separator end if row_sep_len = len ( row_separator_ ); col_sep_len = len ( column_separator_ ) row_sep = iachar ( row_separator_ ( 1 : 1 )); col_sep = iachar ( column_separator_ ( 1 : 1 )) quote = iachar ( QQUOTE ) nrows = self % count ( match = row_separator_ ) ncols = 1 ; i = 1_i64 ; get_ncols : do current = iachar ( self % s ( i : i )) if ( ( current /= quote ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_i64 ; cycle end if if ( current == quote ) then in_quote = (. not . in_quote ); i = i + 1_i64 ; cycle end if if ( current == col_sep ) then if ( in_quote ) then i = i + 1_i64 ; cycle end if if ( col_sep_len == 1 ) then ncols = ncols + 1_i64 ; i = i + 1_i64 ; cycle else if ( self % s ( i : i + col_sep_len - 1_i64 ) == column_separator_ ) then ncols = ncols + 1_i64 ; i = i + col_sep_len ; cycle else i = i + 1_i64 ; cycle end if end if end if if ( current == row_sep ) then if ( row_sep_len == 1 ) then exit get_ncols else if ( self % s ( i : i + row_sep_len - 1_i64 ) == row_separator_ ) then exit get_ncols else i = i + 1_i64 ; cycle end if end if end if end do get_ncols allocate ( cell_array ( nrows , ncols ), stat = stat_ , errmsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = ALLOC_ERR ; return end if row = 1 ; col = 1 ; l = 1_i64 ; i = 1_i64 ; positional_transfers : do current = iachar ( self % s ( i : i )) if ( ( current /= quote ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_i64 ; cycle end if if ( current == quote ) then in_quote = (. not . in_quote ); i = i + 1_i64 ; cycle end if if ( current == col_sep ) then if ( in_quote ) then i = i + 1_i64 ; cycle end if if ( col_sep_len == 1 ) then cell_array ( row , col )% s = self % s ( l : i - 1 ); i = i + 1_i64 ; l = i ; col = col + 1 ; cycle else if ( self % s ( i : i + col_sep_len - 1_i64 ) == column_separator_ ) then cell_array ( row , col )% s = self % s ( l : i - 1 ); i = i + col_sep_len ; l = i ; col = col + 1 ; cycle else i = i + 1_i64 ; cycle end if end if end if if ( current == row_sep ) then if ( row_sep_len == 1 ) then cell_array ( row , col )% s = self % s ( l : i - 1 ) if ( row == nrows ) return i = i + 1_i64 ; l = i ; col = 1 ; row = row + 1 ; cycle else if ( self % s ( i : i + row_sep_len - 1_i64 ) == row_separator_ ) then cell_array ( row , col )% s = self % s ( l : i - 1 ) if ( row == nrows ) return i = i + row_sep_len ; l = i ; col = 1 ; row = row + 1 ; cycle else i = i + 1_i64 ; cycle end if end if end if end do positional_transfers end block cell_block end procedure read_file module procedure replace_ch_copy integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = len ( match ) substring_len = len ( substring ) if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_ch_copy module procedure replace_st_copy character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = match % len () substring_len = substring % len () if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_st_copy module procedure replace_chst_copy character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = len ( match ) substring_len = substring % len () if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_chst_copy module procedure replace_stch_copy integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = match % len () substring_len = len ( substring ) if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_stch_copy module procedure replace_ch_inplace type ( String ) :: new integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = len ( match ) substring_len = len ( substring ) if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_ch_inplace module procedure replace_st_inplace type ( String ) :: new character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = match % len () substring_len = substring % len () if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_st_inplace module procedure replace_chst_inplace type ( String ) :: new character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = len ( match ) substring_len = substring % len () if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_chst_inplace module procedure replace_stch_inplace type ( String ) :: new integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ i = 0 ; self_len = 0 ; match_len = 0 ; substring_len = 0 ; diff_len = 0 ; back_ = . false . self_len = self % len () match_len = match % len () substring_len = len ( substring ) if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_stch_inplace module procedure trim_copy if ( self % len () < 1 ) then new % s = EMPTY_STR else new % s = trim ( adjustl ( self % s )) end if end procedure trim_copy module procedure trim_inplace if ( self % len () < 1 ) then self % s = EMPTY_STR else self % s = trim ( adjustl ( self % s )) end if end procedure trim_inplace module procedure write_file character ( len = :), allocatable :: ext character ( len = :), pointer :: row_separator_ , column_separator_ , errmsg_ logical , pointer :: append_ integer , pointer :: stat_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat integer ( i64 ), allocatable :: lengths (:,:) integer ( i64 ) :: total_len , pos integer :: file_unit , nrows , ncols , row_sep_len , col_sep_len , row , col logical :: exists dummy_msg = EMPTY_STR ; dummy_stat = 0 total_len = 0_i64 ; pos = 0_i64 file_unit = 0 ; nrows = 0 ; ncols = 0 ; row_sep_len = 0 ; col_sep_len = 0 ; row = 0 ; col = 0 exists = . false . ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( . not . any ( TEXT_EXT == ext ) ) then stat_ = ARG_ERR errmsg_ = 'Cannot write to file \"' // file // '\" due to unsupported file extension \"' // ext // '\". ' // & 'Supported file extensions: ' // join ( TEXT_EXT ) return end if if ( . not . present ( row_separator ) ) then row_separator_ => LINE_FEED else row_separator_ => row_separator end if if ( . not . present ( column_separator ) ) then column_separator_ => COMMA_DELIMITER else column_separator_ => column_separator end if if ( . not . present ( append ) ) then append_ => NO_APPEND else append_ => append end if nrows = size ( cell_array , dim = 1 ) ncols = size ( cell_array , dim = 2 ) row_sep_len = len ( row_separator_ ) col_sep_len = len ( column_separator_ ) if ( allocated ( self % s ) ) deallocate ( self % s , stat = stat_ , errmsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = ALLOC_ERR ; return end if lengths = cell_array % len64 () total_len = sum ( lengths ) + int ( nrows * row_sep_len , kind = i64 ) + int ( nrows * ( ncols - 1 ) * col_sep_len , kind = i64 ) allocate ( character ( len = total_len ) :: self % s , stat = stat_ , errmsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = ALLOC_ERR ; return end if row = 1 ; col = 1 ; pos = 1_i64 ; positional_transfers : do if ( lengths ( row , col ) > 0_i64 ) then self % s ( pos : pos + lengths ( row , col ) - 1_i64 ) = cell_array ( row , col )% s pos = pos + lengths ( row , col ) end if if ( col < ncols ) then if ( col_sep_len > 0 ) self % s ( pos : pos + col_sep_len - 1_i64 ) = column_separator_ pos = pos + col_sep_len ; col = col + 1 ; cycle else if ( row_sep_len > 0 ) self % s ( pos : pos + row_sep_len - 1_i64 ) = row_separator_ if ( row < nrows ) then pos = pos + row_sep_len ; row = row + 1 ; col = 1 ; cycle else exit end if end if end do positional_transfers inquire ( file = file , exist = exists , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , position = \"append\" , iostat = stat_ , iomsg = errmsg_ ) end if end if if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if write ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) self % s if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if end procedure write_file module procedure write_string if ( substring % len () < 1 ) then write ( unit = unit , fmt = \"(a)\" , iostat = iostat , iomsg = iomsg ) EMPTY_STR else write ( unit = unit , fmt = \"(a)\" , iostat = iostat , iomsg = iomsg ) substring % s end if end procedure write_string module procedure scrub if ( allocated ( self % s ) ) deallocate ( self % s ) end procedure scrub end submodule string_methods","tags":"","loc":"sourcefile/string_methods_impl.f90.html"},{"title":"text_io_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( io_fortran_lib ) text_io !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interface** `echo` and the **private !! interfaces** `to_text` and `from_text`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) ! Definitions and interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 1 ), target :: LINE_FEED = LF logical , target :: APPEND_TO_FILE = . true . contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure echo_chars character ( len = :), allocatable :: ext character ( len = :), pointer :: terminator_ , errmsg_ integer , pointer :: stat_ logical , pointer :: append_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat logical :: exists integer :: file_unit exists = . false .; file_unit = 0 ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( . not . any ( TEXT_EXT == ext ) ) then stat_ = ARG_ERR errmsg_ = 'Error writing to file \"' // file // '\" due to unsupported file extension \"' // ext // '\". ' // & \"Supported file extensions: \" // join ( TEXT_EXT ) return end if if ( len ( substring , kind = i64 ) == 0_i64 ) then stat_ = ARG_ERR errmsg_ = 'Error writing to file \"' // file // '\". String to write is empty.' return end if if ( . not . present ( append ) ) then append_ => APPEND_TO_FILE else append_ => append end if if ( . not . present ( terminator ) ) then terminator_ => LINE_FEED else terminator_ => terminator end if inquire ( file = file , exist = exists , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , position = \"append\" , iostat = stat_ , iomsg = errmsg_ ) end if end if if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if write ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) substring if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if write ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) terminator_ if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if end procedure echo_chars module procedure echo_string character ( len = :), allocatable :: ext character ( len = :), pointer :: terminator_ , errmsg_ integer , pointer :: stat_ logical , pointer :: append_ character ( len = 0 ), target :: dummy_msg integer , target :: dummy_stat logical :: exists integer :: file_unit exists = . false .; file_unit = 0 ext = ext_of ( file ) if ( . not . present ( stat ) ) then stat_ => dummy_stat else stat_ => stat end if if ( . not . present ( errmsg ) ) then errmsg_ => dummy_msg else errmsg_ => errmsg end if stat_ = 0 ; errmsg_ = EMPTY_STR if ( . not . any ( TEXT_EXT == ext ) ) then stat_ = ARG_ERR errmsg_ = 'Error writing to file \"' // file // '\" due to unsupported file extension \"' // ext // '\". ' // & \"Supported file extensions: \" // join ( TEXT_EXT ) return end if if ( substring % len64 () == 0_i64 ) then stat_ = ARG_ERR errmsg_ = 'Error writing to file \"' // file // '\". String to write is empty.' return end if if ( . not . present ( append ) ) then append_ => APPEND_TO_FILE else append_ => append end if if ( . not . present ( terminator ) ) then terminator_ => LINE_FEED else terminator_ => terminator end if inquire ( file = file , exist = exists , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file , status = \"new\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file , status = \"replace\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , iostat = stat_ , iomsg = errmsg_ ) else open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"write\" , access = \"stream\" , position = \"append\" , iostat = stat_ , iomsg = errmsg_ ) end if end if if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if write ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) substring % s if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if write ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) terminator_ if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if close ( unit = file_unit , iostat = stat_ , iomsg = errmsg_ ) if ( stat_ /= 0 ) then stat_ = WRITE_ERR ; return end if end procedure echo_string module procedure to_text_c128 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals , im ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals , im ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_c128 module procedure to_text_c64 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals , im ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals , im ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_c64 module procedure to_text_c32 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals , im ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals , im ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_c32 module procedure to_text_r128 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_r128 module procedure to_text_r64 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_r64 module procedure to_text_r32 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), locale , fmt , decimals ) rank ( 2 ); call cast ( x , numerical_data , locale , fmt , decimals ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_r32 module procedure to_text_i64 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), fmt ) rank ( 2 ); call cast ( x , numerical_data , fmt ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_i64 module procedure to_text_i32 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), fmt ) rank ( 2 ); call cast ( x , numerical_data , fmt ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_i32 module procedure to_text_i16 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), fmt ) rank ( 2 ); call cast ( x , numerical_data , fmt ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_i16 module procedure to_text_i8 type ( String ) :: text_file type ( String ), allocatable , target :: cells (:,:) type ( String ), pointer :: numerical_data (:,:) integer :: nrows , ncols , j logical :: header_present j = 0 ; header_present = . false . select rank ( x ) rank ( 1 ); nrows = size ( x ); ncols = 1 rank ( 2 ); nrows = size ( x , dim = 1 ); ncols = size ( x , dim = 2 ) end select if ( len ( header ) /= 0 ) header_present = . true . if ( header_present ) nrows = nrows + 1 allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if if ( header_present ) then select rank ( x ) rank ( 1 ) cells ( 1 , 1 )% s = header ( 1 ) rank ( 2 ) if ( size ( header ) == 1 ) then do j = 1 , ncols cells ( 1 , j )% s = header ( 1 ) // str ( j ) end do else do j = 1 , ncols cells ( 1 , j )% s = header ( j ) end do end if end select end if numerical_data => cells if ( header_present ) numerical_data => cells ( 2 :,:) select rank ( x ) rank ( 1 ); call cast ( x , numerical_data (:, 1 ), fmt ) rank ( 2 ); call cast ( x , numerical_data , fmt ) end select call text_file % write_file ( cells , file , NL , delim , . false ., stat , errmsg ) end procedure to_text_i8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_text_c128 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 if ( len ( im ) > 0 ) then call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) else call custom_read ( text_file , file , cells , NL , delim , stat , errmsg ) end if if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt , im = im ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells , into , locale = locale , fmt = fmt , im = im ) end if end select end procedure from_text_c128 module procedure from_text_c64 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 if ( len ( im ) > 0 ) then call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) else call custom_read ( text_file , file , cells , NL , delim , stat , errmsg ) end if if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt , im = im ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells , into , locale = locale , fmt = fmt , im = im ) end if end select end procedure from_text_c64 module procedure from_text_c32 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 if ( len ( im ) > 0 ) then call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) else call custom_read ( text_file , file , cells , NL , delim , stat , errmsg ) end if if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt , im = im ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt , im = im ) else call cast ( cells , into , locale = locale , fmt = fmt , im = im ) end if end select end procedure from_text_c32 impure recursive subroutine custom_read ( text_file , file , cells , row_separator , column_separator , stat , errmsg ) type ( String ), intent ( inout ) :: text_file character ( len =* ), intent ( in ) :: file type ( String ), intent ( out ), allocatable :: cells (:,:) character ( len =* ), intent ( in ) :: row_separator , column_separator integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg integer ( i64 ) :: file_length , l , i integer :: nrows , ncols , row , col , row_sep , col_sep , col_sep_len , open_paren , close_paren , current , file_unit logical :: exists , in_paren stat = 0 ; errmsg = EMPTY_STR file_length = 0_i64 ; l = 0_i64 ; i = 0_i64 nrows = 0 ; ncols = 0 ; row = 0 ; col = 0 ; row_sep = 0 ; col_sep = 0 ; col_sep_len = 0 ; open_paren = 0 ; close_paren = 0 ; current = 0 ; file_unit = 0 exists = . false .; in_paren = . false . inquire ( file = file , exist = exists , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file , status = \"old\" , form = \"unformatted\" , & action = \"read\" , access = \"stream\" , position = \"rewind\" , iostat = stat , iomsg = errmsg ) else stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". No such file exists.' return end if if ( stat /= 0 ) then stat = READ_ERR ; return end if inquire ( file = file , size = file_length , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if if ( file_length == 0_i64 ) then stat = READ_ERR errmsg = 'Error reading file \"' // file // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s , stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if read ( unit = file_unit , iostat = stat , iomsg = errmsg ) text_file % s if ( stat /= 0 ) then stat = READ_ERR ; return end if close ( unit = file_unit , iostat = stat , iomsg = errmsg ) if ( stat /= 0 ) then stat = READ_ERR ; return end if col_sep_len = len ( column_separator ) row_sep = iachar ( NL ); col_sep = iachar ( column_separator ( 1 : 1 )) open_paren = iachar ( \"(\" ); close_paren = iachar ( \")\" ) nrows = text_file % count ( match = NL ) ncols = 1 ; i = 1_i64 ; get_ncols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_i64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_i64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_i64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_i64 ; cycle end if if ( col_sep_len == 1 ) then ncols = ncols + 1 ; i = i + 1_i64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_i64 ) == column_separator ) then ncols = ncols + 1 ; i = i + col_sep_len ; cycle else i = i + 1_i64 ; cycle end if end if end if if ( current == row_sep ) exit get_ncols end do get_ncols allocate ( cells ( nrows , ncols ), stat = stat , errmsg = errmsg ) if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if row = 1 ; col = 1 ; l = 1_i64 ; i = 1_i64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_i64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_i64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_i64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_i64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_i64 ; l = i col = col + 1 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_i64 ) == column_separator ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1 ; cycle else i = i + 1_i64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == nrows ) exit positional_transfers i = i + 1_i64 ; l = i ; col = 1 ; row = row + 1 ; cycle end if end do positional_transfers end subroutine custom_read module procedure from_text_r128 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt ) else call cast ( cells , into , locale = locale , fmt = fmt ) end if end select end procedure from_text_r128 module procedure from_text_r64 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt ) else call cast ( cells , into , locale = locale , fmt = fmt ) end if end select end procedure from_text_r64 module procedure from_text_r32 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , locale = locale , fmt = fmt ) else call cast ( cells (:, 1 ), into , locale = locale , fmt = fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , locale = locale , fmt = fmt ) else call cast ( cells , into , locale = locale , fmt = fmt ) end if end select end procedure from_text_r32 module procedure from_text_i64 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , fmt ) else call cast ( cells (:, 1 ), into , fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , fmt ) else call cast ( cells , into , fmt ) end if end select end procedure from_text_i64 module procedure from_text_i32 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , fmt ) else call cast ( cells (:, 1 ), into , fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , fmt ) else call cast ( cells , into , fmt ) end if end select end procedure from_text_i32 module procedure from_text_i16 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , fmt ) else call cast ( cells (:, 1 ), into , fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , fmt ) else call cast ( cells , into , fmt ) end if end select end procedure from_text_i16 module procedure from_text_i8 type ( String ) :: text_file type ( String ), allocatable :: cells (:,:) integer :: nrows , ncols nrows = 0 ; ncols = 0 call text_file % read_file ( file , cells , NL , delim , stat , errmsg ) if ( stat /= 0 ) return call text_file % empty () nrows = size ( cells , dim = 1 ); ncols = size ( cells , dim = 2 ) if ( ( nrows == 1 ) . and . header ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". File read with one line, but header was specified as present.' return end if select rank ( into ) rank ( 1 ) if ( ncols > 1 ) then stat = ARG_ERR errmsg = 'Error reading file \"' // file // '\". Data has more than one column but actual argument is a ' // & \"one-dimensional array. Try reading into a two-dimensional array instead.\" return end if rank ( 2 ) continue end select select rank ( into ) rank ( 1 ) if ( header ) then allocate ( into ( nrows - 1 ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows ), stat = stat , errmsg = errmsg ) end if rank ( 2 ) if ( header ) then allocate ( into ( nrows - 1 , ncols ), stat = stat , errmsg = errmsg ) else allocate ( into ( nrows , ncols ), stat = stat , errmsg = errmsg ) end if end select if ( stat /= 0 ) then stat = ALLOC_ERR ; return end if select rank ( into ) rank ( 1 ) if ( header ) then call cast ( cells ( 2 :, 1 ), into , fmt ) else call cast ( cells (:, 1 ), into , fmt ) end if rank ( 2 ) if ( header ) then call cast ( cells ( 2 :,:), into , fmt ) else call cast ( cells , into , fmt ) end if end select end procedure from_text_i8 end submodule text_io","tags":"","loc":"sourcefile/text_io_impl.f90.html"},{"title":"io_fortran_lib_mod.f90 – IO-Fortran-Library","text":"Source Code module io_fortran_lib !--------------------------------------------------------------------------------------------------------------------- !! This module provides common I/O routines for data of `integer`, `real`, `complex`, and `character` type, and !! a derived type `String` for advanced character handling and text file I/O. This module is F2018 compliant, has !! no external dependencies, and has a max line length of 120. !--------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : r128 => real128 , r64 => real64 , r32 => real32 , & ! ISO standard real kinds i64 => int64 , i32 => int32 , i16 => int16 , i8 => int8 , & ! ISO standard int kinds input_unit , output_unit , & ! I/O units compiler_version ! Compiler inquiry function use , intrinsic :: iso_c_binding , only : c_null_char ! C null character implicit none ( type , external ) ! Nothing implicit private ! Default private access ! Public API list ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ public :: aprint , to_file , from_file ! Array I/O public :: String , str , cast , join , split , echo ! String I/O public :: NL , SPACE , CR , FF , VT , LF , TAB , HT , BELL , NUL , CNUL ! Constants public :: operator ( // ), operator ( + ), operator ( - ), operator ( ** ), operator ( == ), operator ( /= ) ! Operators ! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 1 ), parameter :: NL = new_line ( \"a\" ) !! The newline character (system agnostic) character ( len = 1 ), parameter :: SPACE = achar ( 32 ) !! The space character character ( len = 1 ), parameter :: CR = achar ( 13 ) !! The carriage return character character ( len = 1 ), parameter :: FF = achar ( 12 ) !! The form feed character character ( len = 1 ), parameter :: VT = achar ( 11 ) !! The vertical tab character character ( len = 1 ), parameter :: LF = achar ( 10 ) !! The line feed character character ( len = 1 ), parameter :: TAB = achar ( 9 ) !! The horizontal tab character character ( len = 1 ), parameter :: HT = achar ( 9 ) !! The horizontal tab character (alternate name) character ( len = 1 ), parameter :: BELL = achar ( 7 ) !! The bell/alert character character ( len = 1 ), parameter :: NUL = achar ( 0 ) !! The null character character ( len = 1 ), parameter :: CNUL = c_null_char !! The C null character re-exported from iso_c_binding character ( len =* ), parameter :: COMPILER = compiler_version () ! Compiler version character ( len = 0 ), parameter :: EMPTY_STR = \"\" ! The empty string character ( len = 1 ), parameter :: SEMICOLON = achar ( 59 ) ! Semicolon character ( len = 1 ), parameter :: POINT = achar ( 46 ) ! Full stop character ( len = 1 ), parameter :: COMMA = achar ( 44 ) ! Comma character ( len = 1 ), parameter :: QQUOTE = achar ( 34 ) ! Double quote character ( len = 1 ), parameter :: INT_FMTS ( * ) = [ \"i\" , \"z\" ] ! Allowed formats for integers character ( len = 1 ), parameter :: REAL_FMTS ( * ) = [ \"e\" , \"f\" , \"z\" ] ! Allowed formats for floats character ( len = 2 ), parameter :: LOCALES ( * ) = [ \"US\" , \"EU\" ] ! Allowed locale specifiers character ( len = 3 ), parameter :: BINARY_EXT ( * ) = [ \"dat\" , \"bin\" ] ! Allowed binary extensions character ( len = 3 ), parameter :: TEXT_EXT ( * ) = [ \"csv\" , \"txt\" , & ! Allowed text extensions \"log\" , \"rtf\" , & \"odm\" , \"odt\" , & \"ods\" , \"odf\" , & \"xls\" , \"doc\" , & \"org\" , \"dbf\" , & \"bed\" , \"gff\" , & \"gtf\" ] integer , parameter :: READ_ERR = 1 ! Read error code integer , parameter :: WRITE_ERR = 2 ! Write error code integer , parameter :: ALLOC_ERR = 3 ! Allocation error code integer , parameter :: ARG_ERR = 4 ! Argument error code type String !------------------------------------------------------------------------------------------------------------------- !! A growable string type for advanced character handling and text I/O. !! !! For a user reference, see [String](../page/Ref/String.html), !! [String methods](../page/Ref/String-methods.html), and [Operators](../page/Ref/operators.html). !! !! @note TECHNICAL NOTE: The `String` type is memory safe. The user will never need to be concerned about !! accessing invalid memory when using the `String` type. Any operation defined in this documentation for the !! `String` type which may involve a `String` with an unallocated component, or arrays of `String`s in which !! some of the elements may have unallocated components, is well-defined. In all such cases, the component is !! treated as the [empty string](../module/io_fortran_lib.html#variable-empty_str). !------------------------------------------------------------------------------------------------------------------- private character ( len = :), allocatable :: s !! Component is an allocatable string contains private ! Generics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ generic , public :: cast => cast_string_to_c128 , cast_string_to_c64 , cast_string_to_c32 , & cast_string_to_r128 , cast_string_to_r64 , cast_string_to_r32 , & cast_string_to_i64 , cast_string_to_i32 , cast_string_to_i16 , & cast_string_to_i8 generic , public :: count => count_substring_chars , count_substring_string generic , public :: echo => echo_string generic , public :: push => push_chars , push_string generic , public :: replace => replace_ch_copy , replace_st_copy , replace_chst_copy , & replace_stch_copy generic , public :: replace_inplace => replace_ch_inplace , replace_st_inplace , replace_chst_inplace , & replace_stch_inplace generic , public :: split => split_string generic , public :: write ( formatted ) => write_string ! Specifics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ procedure , pass ( self ), public :: as_str procedure , pass ( substring ) :: cast_string_to_c128 , cast_string_to_c64 , cast_string_to_c32 , & cast_string_to_r128 , cast_string_to_r64 , cast_string_to_r32 , & cast_string_to_i64 , cast_string_to_i32 , cast_string_to_i16 , & cast_string_to_i8 procedure , pass ( self ) :: count_substring_chars , count_substring_string procedure , pass ( substring ) :: echo_string procedure , pass ( self ), public :: empty procedure , pass ( self ), public :: join => join_into_self procedure , pass ( self ) :: join_base procedure , pass ( self ), public :: len => length procedure , pass ( self ), public :: len64 => length64 procedure , pass ( self ) :: push_chars , push_string procedure , pass ( self ), public :: read_file procedure , pass ( self ) :: replace_ch_copy , replace_st_copy , replace_chst_copy , & replace_stch_copy , replace_ch_inplace , replace_st_inplace , & replace_chst_inplace , replace_stch_inplace procedure , pass ( substring ) :: split_string procedure , pass ( self ), public :: trim => trim_copy procedure , pass ( self ), public :: trim_inplace procedure , pass ( self ), public :: write_file procedure , pass ( substring ) :: write_string final :: scrub end type String interface ! Submodule string_methods !------------------------------------------------------------------------------------------------------------------- !! Methods for the `String` type. !------------------------------------------------------------------------------------------------------------------- pure recursive module function as_str ( self ) result ( string_slice ) !----------------------------------------------------------------------------------------------------------------- !! Returns a copy of the string slice component of a scalar `String`. !! !! For a user reference, see [as_str](../page/Ref/String-methods.html#as_str). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len = :), allocatable :: string_slice end function as_str pure elemental recursive integer module function count_substring_chars ( self , match ) result ( occurrences ) !----------------------------------------------------------------------------------------------------------------- !! Returns number of non-overlapping occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match end function count_substring_chars pure elemental recursive integer module function count_substring_string ( self , match ) result ( occurrences ) !----------------------------------------------------------------------------------------------------------------- !! Returns number of non-overlapping occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match end function count_substring_string pure elemental recursive module subroutine empty ( self ) !----------------------------------------------------------------------------------------------------------------- !! Sets the string slice component to the empty string elementally. This procedure is identical in function !! to the assignment `self = String()`. !! !! For a user reference, see [empty](../page/Ref/String-methods.html#empty). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self end subroutine empty pure recursive module subroutine join_into_self ( self , tokens , separator ) !----------------------------------------------------------------------------------------------------------------- !! Joins a `String` vector `tokens` into `self` with given separator. Default separator is SPACE. The !! string slice component will be replaced if already allocated. !! !! For a user reference, see [join](../page/Ref/String-methods.html#join). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: tokens (:) character ( len =* ), intent ( in ), optional :: separator end subroutine join_into_self pure recursive module subroutine join_base ( self , tokens , separator ) !----------------------------------------------------------------------------------------------------------------- !! Tail recursion routine for `join_string` and `join_into_self`. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: tokens (:) character ( len =* ), intent ( in ) :: separator end subroutine join_base pure elemental recursive integer module function length ( self ) result ( self_len ) !----------------------------------------------------------------------------------------------------------------- !! Returns the length of the string slice component elementally. Unallocated components return `-1`. !! !! For a user reference, see [len](../page/Ref/String-methods.html#len). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function length pure elemental recursive integer ( i64 ) module function length64 ( self ) result ( self_len ) !----------------------------------------------------------------------------------------------------------------- !! Returns the length of the string slice component elementally. Unallocated components return `-1`. This !! function is identical to `len` for strings of 2,147,483,647 bytes or smaller. !! !! For a user reference, see [len](../page/Ref/String-methods.html#len). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function length64 pure elemental recursive module subroutine push_chars ( self , substring ) !----------------------------------------------------------------------------------------------------------------- !! Appends characters to the string slice component elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: substring end subroutine push_chars pure elemental recursive module subroutine push_string ( self , substring ) !----------------------------------------------------------------------------------------------------------------- !! Appends string to the string slice component elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: substring end subroutine push_string impure recursive module subroutine read_file ( self , file , cell_array , row_separator , column_separator , stat , errmsg ) !----------------------------------------------------------------------------------------------------------------- !! Reads raw text file contents into `self` and optionally populates a cell array using the designated !! `row_separator` and `column_separator` whose default values are `LF` and `COMMA` respectively. !! !! For a user reference, see [read_file](../page/Ref/String-methods.html#read_file). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: file type ( String ), intent ( out ), optional , allocatable :: cell_array (:,:) character ( len =* ), intent ( in ), optional , target :: row_separator , column_separator integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine read_file pure elemental recursive type ( String ) module function replace_ch_copy ( self , match , substring , back ) result ( new ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end function replace_ch_copy pure elemental recursive type ( String ) module function replace_st_copy ( self , match , substring , back ) result ( new ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end function replace_st_copy pure elemental recursive type ( String ) module function replace_chst_copy ( self , match , substring , back ) result ( new ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match type ( String ), intent ( in ) :: substring logical , intent ( in ), optional :: back end function replace_chst_copy pure elemental recursive type ( String ) module function replace_stch_copy ( self , match , substring , back ) result ( new ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back end function replace_stch_copy pure elemental recursive module subroutine replace_ch_inplace ( self , match , substring , back ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end subroutine replace_ch_inplace pure elemental recursive module subroutine replace_st_inplace ( self , match , substring , back ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end subroutine replace_st_inplace pure elemental recursive module subroutine replace_chst_inplace ( self , match , substring , back ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: match type ( String ), intent ( in ) :: substring logical , intent ( in ), optional :: back end subroutine replace_chst_inplace pure elemental recursive module subroutine replace_stch_inplace ( self , match , substring , back ) !----------------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: match character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back end subroutine replace_stch_inplace pure elemental recursive type ( String ) module function trim_copy ( self ) result ( new ) !----------------------------------------------------------------------------------------------------------------- !! Returns a copy of a `String` elementally in which each string slice component has been trimmed of any !! leading or trailing whitespace. !! !! For a user reference, see [trim](../page/Ref/String-methods.html#trim). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function trim_copy pure elemental recursive module subroutine trim_inplace ( self ) !----------------------------------------------------------------------------------------------------------------- !! Removes any leading or trailing whitespace of the string slice component of a `String` elementally and !! in place. !! !! For a user reference, see [trim_inplace](../page/Ref/String-methods.html#trim_inplace). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self end subroutine trim_inplace impure recursive module subroutine write_file ( self , cell_array , file , row_separator , column_separator , append , & stat , errmsg ) !----------------------------------------------------------------------------------------------------------------- !! Writes the content of a cell array to a text file. The cell array's entire contents are populated into !! `self` and then streamed to an external text file using the designated `row_separator` and !! `column_separator` whose default values are `LF` and `COMMA` respectively. !! !! For a user reference, see [write_file](../page/Ref/String-methods.html#write_file). !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: cell_array (:,:) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: row_separator , column_separator logical , intent ( in ), optional , target :: append integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine write_file impure recursive module subroutine write_string ( substring , unit , iotype , v_list , iostat , iomsg ) !----------------------------------------------------------------------------------------------------------------- !! Formatted write DTIO procedure for type `String`. !----------------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: substring integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg end subroutine write_string pure elemental recursive module subroutine scrub ( self ) !----------------------------------------------------------------------------------------------------------------- !! Finalization procedure for type `String`. !----------------------------------------------------------------------------------------------------------------- type ( String ), intent ( inout ) :: self end subroutine scrub end interface interface operator ( // ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Concatenation operator for `character` and `String`, lifted from `character`. Mixed type concatenation of !! `character` and `String` is explicitly defined. !! !! For a user reference, see [Concatenation](../page/Ref/operators.html#concatenation). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function string_concatenation ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_concatenation pure elemental recursive type ( String ) module function string_char_concatenation ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_concatenation pure elemental recursive type ( String ) module function char_string_concatenation ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_concatenation end interface operator ( // ) interface operator ( + ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Concatenation operator for `character` and `String` (as addition). Mixed type concatenation of !! `character` and `String` is explicitly defined. !! !! For a user reference, see [Concatenation](../page/Ref/operators.html#concatenation). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive module function char_concat_plus ( charsl , charsr ) result ( new ) character ( len =* ), intent ( in ) :: charsl , charsr character ( len = len ( charsl ) + len ( charsr )) :: new end function char_concat_plus pure elemental recursive type ( String ) module function string_concat_plus ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_concat_plus pure elemental recursive type ( String ) module function string_char_concat_plus ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_concat_plus pure elemental recursive type ( String ) module function char_string_concat_plus ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_concat_plus end interface operator ( + ) interface operator ( - ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Excision operator for `character` and `String` (as subtraction). Mixed type excision of `character` and !! `String` is explicitly defined. !! !! For a user reference, see [Excision](../page/Ref/operators.html#excision). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function char_excision ( charsl , charsr ) result ( new ) character ( len =* ), intent ( in ) :: charsl , charsr end function char_excision pure elemental recursive type ( String ) module function string_excision ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_excision pure elemental recursive type ( String ) module function string_char_excision ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_excision pure elemental recursive type ( String ) module function char_string_excision ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_excision end interface operator ( - ) interface operator ( ** ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Repetition operator for `character` and `String` (as exponentiation). !! !! For a user reference, see [Repetition](../page/Ref/operators.html#repetition). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive module function repeat_chars ( char_base , ncopies ) result ( new ) character ( len =* ), intent ( in ) :: char_base integer , intent ( in ) :: ncopies character ( len = len ( char_base ) * ncopies ) :: new end function repeat_chars pure elemental recursive type ( String ) module function repeat_String ( String_base , ncopies ) result ( new ) class ( String ), intent ( in ) :: String_base integer , intent ( in ) :: ncopies end function repeat_String end interface operator ( ** ) interface operator ( == ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Equivalence operator for `character` and `String`. Mixed type equivalence of `character` and `String` is !! explicitly defined. !! !! For a user reference, see [Equivalence](../page/Ref/operators.html#equivalence). !! !! @note The equivalence operator `==` is interchangeable with `.eq.`. !------------------------------------------------------------------------------------------------------------------- pure elemental recursive logical module function string_equivalence ( Stringl , Stringr ) result ( equal ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_equivalence pure elemental recursive logical module function string_char_equivalence ( Stringl , charsr ) result ( equal ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_equivalence pure elemental recursive logical module function char_string_equivalence ( charsl , Stringr ) result ( equal ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_equivalence end interface operator ( == ) interface operator ( /= ) ! Submodule operators !------------------------------------------------------------------------------------------------------------------- !! Non-equivalence operator for `character` and `String`. Mixed type non-equivalence of `character` and !! `String` is explicitly defined. !! !! For a user reference, see [Non-equivalence](../page/Ref/operators.html#non-equivalence). !! !! @note The non-equivalence operator `/=` is interchangeable with `.ne.`. !------------------------------------------------------------------------------------------------------------------- pure elemental recursive logical module function string_nonequivalence ( Stringl , Stringr ) result ( unequal ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_nonequivalence pure elemental recursive logical module function string_char_nonequivalence ( Stringl , charsr ) result ( unequal ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_nonequivalence pure elemental recursive logical module function char_string_nonequivalence ( charsl , Stringr ) result ( unequal ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_nonequivalence end interface operator ( /= ) interface String ! Submodule internal_io !------------------------------------------------------------------------------------------------------------------- !! Function for returning a [String](../type/string.html) representation of numbers. !! !! For a user reference, see [String](../page/Ref/String.html), !! [String methods](../page/Ref/String-methods.html), and [Operators](../page/Ref/operators.html). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function new_string_from_c128 ( x , locale , fmt , decimals , im ) result ( new ) complex ( r128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c128 pure elemental recursive type ( String ) module function new_string_from_c64 ( x , locale , fmt , decimals , im ) result ( new ) complex ( r64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c64 pure elemental recursive type ( String ) module function new_string_from_c32 ( x , locale , fmt , decimals , im ) result ( new ) complex ( r32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c32 pure elemental recursive type ( String ) module function new_string_from_r128 ( x , locale , fmt , decimals ) result ( new ) real ( r128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r128 pure elemental recursive type ( String ) module function new_string_from_r64 ( x , locale , fmt , decimals ) result ( new ) real ( r64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r64 pure elemental recursive type ( String ) module function new_string_from_r32 ( x , locale , fmt , decimals ) result ( new ) real ( r32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r32 pure elemental recursive type ( String ) module function new_string_from_i64 ( x , fmt ) result ( new ) integer ( i64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i64 pure elemental recursive type ( String ) module function new_string_from_i32 ( x , fmt ) result ( new ) integer ( i32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i32 pure elemental recursive type ( String ) module function new_string_from_i16 ( x , fmt ) result ( new ) integer ( i16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i16 pure elemental recursive type ( String ) module function new_string_from_i8 ( x , fmt ) result ( new ) integer ( i8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i8 pure elemental recursive type ( String ) module function new_string_from_string ( x ) result ( new ) class ( String ), intent ( in ) :: x end function new_string_from_string pure elemental recursive type ( String ) module function new_string_from_char ( x ) result ( new ) character ( len =* ), intent ( in ) :: x end function new_string_from_char pure elemental recursive type ( String ) module function new_string_from_empty () result ( new ) ! No arguments end function new_string_from_empty end interface String interface str ! Submodule internal_io !------------------------------------------------------------------------------------------------------------------- !! Function for returning a `character` representation of a number. !! !! For a user reference, see [str](../page/Ref/str.html). !------------------------------------------------------------------------------------------------------------------- pure recursive module function str_from_c128 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( r128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c128 pure recursive module function str_from_c64 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( r64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c64 pure recursive module function str_from_c32 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( r32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c32 pure recursive module function str_from_r128 ( x , locale , fmt , decimals ) result ( x_str ) real ( r128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r128 pure recursive module function str_from_r64 ( x , locale , fmt , decimals ) result ( x_str ) real ( r64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r64 pure recursive module function str_from_r32 ( x , locale , fmt , decimals ) result ( x_str ) real ( r32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r32 pure recursive module function str_from_i64 ( x , fmt ) result ( x_str ) integer ( i64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i64 pure recursive module function str_from_i32 ( x , fmt ) result ( x_str ) integer ( i32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i32 pure recursive module function str_from_i16 ( x , fmt ) result ( x_str ) integer ( i16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i16 pure recursive module function str_from_i8 ( x , fmt ) result ( x_str ) integer ( i8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i8 pure recursive module function str_from_string ( x ) result ( x_str ) class ( String ), intent ( in ) :: x character ( len = :), allocatable :: x_str end function str_from_string pure recursive module function str_from_char ( x ) result ( x_str ) character ( len =* ), intent ( in ) :: x character ( len = :), allocatable :: x_str end function str_from_char pure recursive module function str_from_empty () result ( x_str ) character ( len = :), allocatable :: x_str end function str_from_empty end interface str interface cast ! Submodule internal_io !------------------------------------------------------------------------------------------------------------------- !! Subroutine for casting between numeric and string data. !! !! For a user reference, see [cast](../page/Ref/cast.html). !------------------------------------------------------------------------------------------------------------------- pure elemental recursive module subroutine cast_c128_to_string ( x , into , locale , fmt , decimals , im ) complex ( r128 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c128_to_string pure elemental recursive module subroutine cast_c64_to_string ( x , into , locale , fmt , decimals , im ) complex ( r64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c64_to_string pure elemental recursive module subroutine cast_c32_to_string ( x , into , locale , fmt , decimals , im ) complex ( r32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c32_to_string pure elemental recursive module subroutine cast_r128_to_string ( x , into , locale , fmt , decimals ) real ( r128 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r128_to_string pure elemental recursive module subroutine cast_r64_to_string ( x , into , locale , fmt , decimals ) real ( r64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r64_to_string pure elemental recursive module subroutine cast_r32_to_string ( x , into , locale , fmt , decimals ) real ( r32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r32_to_string pure elemental recursive module subroutine cast_i64_to_string ( x , into , fmt ) integer ( i64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i64_to_string pure elemental recursive module subroutine cast_i32_to_string ( x , into , fmt ) integer ( i32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i32_to_string pure elemental recursive module subroutine cast_i16_to_string ( x , into , fmt ) integer ( i16 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i16_to_string pure elemental recursive module subroutine cast_i8_to_string ( x , into , fmt ) integer ( i8 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i8_to_string pure recursive module subroutine cast_c128_to_char ( x , into , locale , fmt , decimals , im ) complex ( r128 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c128_to_char pure recursive module subroutine cast_c64_to_char ( x , into , locale , fmt , decimals , im ) complex ( r64 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c64_to_char pure recursive module subroutine cast_c32_to_char ( x , into , locale , fmt , decimals , im ) complex ( r32 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c32_to_char pure recursive module subroutine cast_r128_to_char ( x , into , locale , fmt , decimals ) real ( r128 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r128_to_char pure recursive module subroutine cast_r64_to_char ( x , into , locale , fmt , decimals ) real ( r64 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r64_to_char pure recursive module subroutine cast_r32_to_char ( x , into , locale , fmt , decimals ) real ( r32 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r32_to_char pure recursive module subroutine cast_i64_to_char ( x , into , fmt ) integer ( i64 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i64_to_char pure recursive module subroutine cast_i32_to_char ( x , into , fmt ) integer ( i32 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i32_to_char pure recursive module subroutine cast_i16_to_char ( x , into , fmt ) integer ( i16 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i16_to_char pure recursive module subroutine cast_i8_to_char ( x , into , fmt ) integer ( i8 ), intent ( in ) :: x character ( len = :), intent ( inout ), allocatable :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i8_to_char pure elemental recursive module subroutine cast_string_to_c128 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( r128 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c128 pure elemental recursive module subroutine cast_string_to_c64 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( r64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c64 pure elemental recursive module subroutine cast_string_to_c32 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( r32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c32 pure elemental recursive module subroutine cast_string_to_r128 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( r128 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r128 pure elemental recursive module subroutine cast_string_to_r64 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( r64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r64 pure elemental recursive module subroutine cast_string_to_r32 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( r32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r32 pure elemental recursive module subroutine cast_string_to_i64 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( i64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i64 pure elemental recursive module subroutine cast_string_to_i32 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( i32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i32 pure elemental recursive module subroutine cast_string_to_i16 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( i16 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i16 pure elemental recursive module subroutine cast_string_to_i8 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( i8 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i8 pure recursive module subroutine cast_char_to_c128 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( r128 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c128 pure recursive module subroutine cast_char_to_c64 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( r64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c64 pure recursive module subroutine cast_char_to_c32 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( r32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c32 pure recursive module subroutine cast_char_to_r128 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( r128 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r128 pure recursive module subroutine cast_char_to_r64 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( r64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r64 pure recursive module subroutine cast_char_to_r32 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( r32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r32 pure recursive module subroutine cast_char_to_i64 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( i64 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i64 pure recursive module subroutine cast_char_to_i32 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( i32 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i32 pure recursive module subroutine cast_char_to_i16 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( i16 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i16 pure recursive module subroutine cast_char_to_i8 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( i8 ), intent ( out ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i8 end interface cast interface join ! Submodule join_split !------------------------------------------------------------------------------------------------------------------- !! Function for joining a vector of `tokens` into a scalar `character` or `String`. !! !! For a user reference, see [join](../page/Ref/join-split.html). !------------------------------------------------------------------------------------------------------------------- pure recursive module function join_char ( tokens , separator ) result ( new ) character ( len =* ), intent ( in ) :: tokens (:) character ( len =* ), intent ( in ), optional :: separator character ( len = :), allocatable :: new end function join_char pure recursive type ( String ) module function join_string ( tokens , separator ) result ( new ) type ( String ), intent ( in ) :: tokens (:) character ( len =* ), intent ( in ), optional :: separator end function join_string end interface join interface split ! Submodule join_split !------------------------------------------------------------------------------------------------------------------- !! Function for splitting a scalar `character` or `String` into a vector of `tokens`. !! !! For a user reference, see [split](../page/Ref/join-split.html). !------------------------------------------------------------------------------------------------------------------- pure recursive module function split_char ( substring , separator ) result ( tokens ) character ( len =* ), intent ( in ) :: substring character ( len =* ), intent ( in ), optional :: separator type ( String ), allocatable :: tokens (:) end function split_char pure recursive module function split_string ( substring , separator ) result ( tokens ) class ( String ), intent ( in ) :: substring character ( len =* ), intent ( in ), optional :: separator type ( String ), allocatable :: tokens (:) end function split_string end interface split interface ! Submodule file_io !------------------------------------------------------------------------------------------------------------------- ! Function for parsing a file name for an extension !------------------------------------------------------------------------------------------------------------------- pure recursive module function ext_of ( file ) result ( ext ) character ( len =* ), intent ( in ) :: file character ( len = :), allocatable :: ext end function ext_of end interface interface to_file ! Submodule file_io !------------------------------------------------------------------------------------------------------------------- !! Subroutine for writing an array of uniform numeric data type to an external file. !! !! For a user reference, see [to_file](../page/Ref/to_file.html). !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_file_c128 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_c128 impure recursive module subroutine to_file_c64 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_c64 impure recursive module subroutine to_file_c32 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_c32 impure recursive module subroutine to_file_r128 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_r128 impure recursive module subroutine to_file_r64 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_r64 impure recursive module subroutine to_file_r32 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( in ), optional , target :: decimals integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_r32 impure recursive module subroutine to_file_i64 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_i64 impure recursive module subroutine to_file_i32 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_i32 impure recursive module subroutine to_file_i16 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i16 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_i16 impure recursive module subroutine to_file_i8 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i8 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ), optional , target :: header (:) character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine to_file_i8 end interface to_file interface from_file ! Submodule file_io !------------------------------------------------------------------------------------------------------------------- !! Subroutine for reading an external file of uniform numeric data type and format into an array. !! !! For a user reference, see [from_file](../page/Ref/from_file.html). !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_textfile_c128 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r128 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_c128 impure recursive module subroutine from_textfile_c64 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_c64 impure recursive module subroutine from_textfile_c32 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt character ( len =* ), intent ( in ), optional , target :: im integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_c32 impure recursive module subroutine from_binaryfile_c128 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r128 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_c128 impure recursive module subroutine from_binaryfile_c64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_c64 impure recursive module subroutine from_binaryfile_c32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_c32 impure recursive module subroutine from_textfile_r128 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r128 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_r128 impure recursive module subroutine from_textfile_r64 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_r64 impure recursive module subroutine from_textfile_r32 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: locale character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_r32 impure recursive module subroutine from_binaryfile_r128 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r128 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_r128 impure recursive module subroutine from_binaryfile_r64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_r64 impure recursive module subroutine from_binaryfile_r32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_r32 impure recursive module subroutine from_textfile_i64 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_i64 impure recursive module subroutine from_textfile_i32 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_i32 impure recursive module subroutine from_textfile_i16 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i16 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_i16 impure recursive module subroutine from_textfile_i8 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i8 ), intent ( out ), allocatable :: into (..) logical , intent ( in ), optional , target :: header character ( len =* ), intent ( in ), optional , target :: delim character ( len =* ), intent ( in ), optional , target :: fmt integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_textfile_i8 impure recursive module subroutine from_binaryfile_i64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_i64 impure recursive module subroutine from_binaryfile_i32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_i32 impure recursive module subroutine from_binaryfile_i16 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i16 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_i16 impure recursive module subroutine from_binaryfile_i8 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i8 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine from_binaryfile_i8 end interface from_file interface echo ! Submodule text_io !------------------------------------------------------------------------------------------------------------------- !! Subroutine for writing a scalar `character` or `String` to an external text file. !! !! For a user reference, see [echo](../page/Ref/echo.html). !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine echo_chars ( substring , file , append , terminator , stat , errmsg ) character ( len =* ), intent ( in ) :: substring character ( len =* ), intent ( in ) :: file logical , intent ( in ), optional , target :: append character ( len =* ), intent ( in ), optional , target :: terminator integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine echo_chars impure recursive module subroutine echo_string ( substring , file , append , terminator , stat , errmsg ) class ( String ), intent ( in ) :: substring character ( len =* ), intent ( in ) :: file logical , intent ( in ), optional , target :: append character ( len =* ), intent ( in ), optional , target :: terminator integer , intent ( out ), optional , target :: stat character ( len =* ), intent ( out ), optional , target :: errmsg end subroutine echo_string end interface echo interface to_text ! Submodule text_io !------------------------------------------------------------------------------------------------------------------- !! Private interface for writing an array to an external text file. !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_text_c128 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_c128 impure recursive module subroutine to_text_c64 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_c64 impure recursive module subroutine to_text_c32 ( x , file , header , locale , delim , fmt , decimals , im , stat , errmsg ) complex ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_c32 impure recursive module subroutine to_text_r128 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_r128 impure recursive module subroutine to_text_r64 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_r64 impure recursive module subroutine to_text_r32 ( x , file , header , locale , delim , fmt , decimals , stat , errmsg ) real ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_r32 impure recursive module subroutine to_text_i64 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_i64 impure recursive module subroutine to_text_i32 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_i32 impure recursive module subroutine to_text_i16 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i16 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_i16 impure recursive module subroutine to_text_i8 ( x , file , header , delim , fmt , stat , errmsg ) integer ( i8 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file character ( len =* ), intent ( in ) :: header (:) character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_text_i8 end interface to_text interface from_text ! Submodule text_io !------------------------------------------------------------------------------------------------------------------- !! Private interface for reading an external text file into an array. !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_text_c128 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r128 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_c128 impure recursive module subroutine from_text_c64 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_c64 impure recursive module subroutine from_text_c32 ( file , into , header , locale , delim , fmt , im , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_c32 impure recursive module subroutine from_text_r128 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r128 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_r128 impure recursive module subroutine from_text_r64 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_r64 impure recursive module subroutine from_text_r32 ( file , into , header , locale , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_r32 impure recursive module subroutine from_text_i64 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i64 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_i64 impure recursive module subroutine from_text_i32 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i32 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_i32 impure recursive module subroutine from_text_i16 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i16 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_i16 impure recursive module subroutine from_text_i8 ( file , into , header , delim , fmt , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i8 ), intent ( out ), allocatable :: into (..) logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_text_i8 end interface from_text interface to_binary ! Submodule binary_io !------------------------------------------------------------------------------------------------------------------- !! Private interface for writing an array to an external binary file. !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_binary_c128 ( x , file , stat , errmsg ) complex ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_c128 impure recursive module subroutine to_binary_c64 ( x , file , stat , errmsg ) complex ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_c64 impure recursive module subroutine to_binary_c32 ( x , file , stat , errmsg ) complex ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_c32 impure recursive module subroutine to_binary_r128 ( x , file , stat , errmsg ) real ( r128 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_r128 impure recursive module subroutine to_binary_r64 ( x , file , stat , errmsg ) real ( r64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_r64 impure recursive module subroutine to_binary_r32 ( x , file , stat , errmsg ) real ( r32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_r32 impure recursive module subroutine to_binary_i64 ( x , file , stat , errmsg ) integer ( i64 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_i64 impure recursive module subroutine to_binary_i32 ( x , file , stat , errmsg ) integer ( i32 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_i32 impure recursive module subroutine to_binary_i16 ( x , file , stat , errmsg ) integer ( i16 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_i16 impure recursive module subroutine to_binary_i8 ( x , file , stat , errmsg ) integer ( i8 ), intent ( in ) :: x (..) character ( len =* ), intent ( in ) :: file integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine to_binary_i8 end interface to_binary interface from_binary ! Submodule binary_io !------------------------------------------------------------------------------------------------------------------- !! Private interface for reading an external binary file into an array. !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_binary_c128 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r128 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_c128 impure recursive module subroutine from_binary_c64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_c64 impure recursive module subroutine from_binary_c32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file complex ( r32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_c32 impure recursive module subroutine from_binary_r128 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r128 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_r128 impure recursive module subroutine from_binary_r64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_r64 impure recursive module subroutine from_binary_r32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file real ( r32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_r32 impure recursive module subroutine from_binary_i64 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i64 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_i64 impure recursive module subroutine from_binary_i32 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i32 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_i32 impure recursive module subroutine from_binary_i16 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i16 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_i16 impure recursive module subroutine from_binary_i8 ( file , into , data_shape , stat , errmsg ) character ( len =* ), intent ( in ) :: file integer ( i8 ), intent ( out ), allocatable :: into (..) integer , intent ( in ) :: data_shape (:) integer , intent ( out ) :: stat character ( len =* ), intent ( out ) :: errmsg end subroutine from_binary_i8 end interface from_binary interface aprint ! Submodule array_printing !------------------------------------------------------------------------------------------------------------------- !! Subroutine for printing arrays and array sections to stdout. !! !! For a user reference, see [aprint](../page/Ref/aprint.html). !------------------------------------------------------------------------------------------------------------------- impure recursive module subroutine aprint_1dc128 ( x , fmt , decimals , im ) complex ( r128 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc128 impure recursive module subroutine aprint_1dc64 ( x , fmt , decimals , im ) complex ( r64 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc64 impure recursive module subroutine aprint_1dc32 ( x , fmt , decimals , im ) complex ( r32 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc32 impure recursive module subroutine aprint_2dc128 ( x , fmt , decimals , im ) complex ( r128 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc128 impure recursive module subroutine aprint_2dc64 ( x , fmt , decimals , im ) complex ( r64 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc64 impure recursive module subroutine aprint_2dc32 ( x , fmt , decimals , im ) complex ( r32 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc32 impure recursive module subroutine aprint_1dr128 ( x , fmt , decimals ) real ( r128 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr128 impure recursive module subroutine aprint_1dr64 ( x , fmt , decimals ) real ( r64 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr64 impure recursive module subroutine aprint_1dr32 ( x , fmt , decimals ) real ( r32 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr32 impure recursive module subroutine aprint_2dr128 ( x , fmt , decimals ) real ( r128 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr128 impure recursive module subroutine aprint_2dr64 ( x , fmt , decimals ) real ( r64 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr64 impure recursive module subroutine aprint_2dr32 ( x , fmt , decimals ) real ( r32 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr32 impure recursive module subroutine aprint_1di64 ( x , fmt ) integer ( i64 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di64 impure recursive module subroutine aprint_1di32 ( x , fmt ) integer ( i32 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di32 impure recursive module subroutine aprint_1di16 ( x , fmt ) integer ( i16 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di16 impure recursive module subroutine aprint_1di8 ( x , fmt ) integer ( i8 ), intent ( in ) :: x (:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di8 impure recursive module subroutine aprint_2di64 ( x , fmt ) integer ( i64 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di64 impure recursive module subroutine aprint_2di32 ( x , fmt ) integer ( i32 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di32 impure recursive module subroutine aprint_2di16 ( x , fmt ) integer ( i16 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di16 impure recursive module subroutine aprint_2di8 ( x , fmt ) integer ( i8 ), intent ( in ) :: x (:,:) character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di8 impure recursive module subroutine aprint_1dchar ( x ) character ( len =* ), intent ( in ) :: x (:) end subroutine aprint_1dchar impure recursive module subroutine aprint_2dchar ( x ) character ( len =* ), intent ( in ) :: x (:,:) end subroutine aprint_2dchar impure recursive module subroutine aprint_1dString ( x ) class ( String ), intent ( in ) :: x (:) end subroutine aprint_1dString impure recursive module subroutine aprint_2dString ( x ) class ( String ), intent ( in ) :: x (:,:) end subroutine aprint_2dString end interface aprint end module io_fortran_lib !======================================================================================================================= !  List of workarounds for compiler bugs in ifx 2023.0.0 : !  ------------------------------------------------------- !  1.  In join_into_self (line 4808), the recursive call to join_into_self at line 4836 induces a run-time !      segmentation fault in the program contained in benchmark.f90 not seen with the following compilers: ifort !      2021.8.0, gfortran 11.3.0, gfortran 11.2.0. From investigation, the segmentation fault seems due to the passing !      of the array of derived type. The fault occurs in a majority of runs, but not in every run. To avoid the fault, !      the array to be passed must be constructed element by element and passed as in the \"else\" section of the \"if\" !      block. The fault again seems to be induced only when \"-heap-arrays 0\" is specified and only with ifx 2023.0.0. !=======================================================================================================================","tags":"","loc":"sourcefile/io_fortran_lib_mod.f90.html"},{"title":"randoms_mod.f90 – IO-Fortran-Library","text":"Source Code module randoms !--------------------------------------------------------------------------------------------------------------------- !! This module provides Gaussian sampling utility routines for use in unit testing. !--------------------------------------------------------------------------------------------------------------------- use , intrinsic :: iso_fortran_env , only : r128 => real128 , r64 => real64 , r32 => real32 implicit none ( type , external ) private ! Public API list ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ public :: random_gauss ! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ interface gauss ! Submodule gaussian_sampling !------------------------------------------------------------------------------------------------------------------- !! Samples random numbers from the standard Normal (Gaussian) Distribution with the given mean and sigma. !! Uses the Acceptance-complement ratio from W. Hoermann and G. Derflinger. !! This is one of the fastest existing methods for generating normal random variables. !! !! REFERENCE: - W. Hoermann and G. Derflinger (1990): !!              The ACR Method for generating normal random variables, !!              OR Spektrum 12 (1990), 181-185. !! !! Implementation taken from <https://root.cern.ch/doc/master/TRandom_8cxx_source.html#l00274> !! UNURAN (c) 2000  W. Hoermann & J. Leydold, Institut f. Statistik, WU Wien !--------------------------------------------------------------------------------------------------------------- impure real ( r128 ) module function gauss_r128 ( mu , sig ) result ( gauss_res ) real ( r128 ), intent ( in ) :: mu , sig end function gauss_r128 impure real ( r64 ) module function gauss_r64 ( mu , sig ) result ( gauss_res ) real ( r64 ), intent ( in ) :: mu , sig end function gauss_r64 impure real ( r32 ) module function gauss_r32 ( mu , sig ) result ( gauss_res ) real ( r32 ), intent ( in ) :: mu , sig end function gauss_r32 end interface interface random_gauss ! Submodule gaussian_sampling !------------------------------------------------------------------------------------------------------------------- !! Applies `gauss` to whole arrays and scalars. !------------------------------------------------------------------------------------------------------------------- impure elemental module subroutine random_gauss_r128 ( x , mu , sig ) real ( r128 ), intent ( inout ) :: x real ( r128 ), intent ( in ) :: mu , sig end subroutine random_gauss_r128 impure elemental module subroutine random_gauss_r64 ( x , mu , sig ) real ( r64 ), intent ( inout ) :: x real ( r64 ), intent ( in ) :: mu , sig end subroutine random_gauss_r64 impure elemental module subroutine random_gauss_r32 ( x , mu , sig ) real ( r32 ), intent ( inout ) :: x real ( r32 ), intent ( in ) :: mu , sig end subroutine random_gauss_r32 end interface end module randoms","tags":"","loc":"sourcefile/randoms_mod.f90.html"},{"title":"gaussian_sampling_impl.f90 – IO-Fortran-Library","text":"Source Code submodule ( randoms ) gaussian_sampling !--------------------------------------------------------------------------------------------------------------------- !! This submodule provides module procedure implementations for the **public interface** `random_gauss` and the !! **private interface** `gauss`. !--------------------------------------------------------------------------------------------------------------------- implicit none ( type , external ) contains ! Procedure bodies for module subprograms <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>< ! Gaussian sampling procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure gauss_r128 real ( r128 ) :: rn , x , y , z , res real ( r128 ), parameter :: kC1 = 1.448242853_r128 real ( r128 ), parameter :: kC2 = 3.307147487_r128 real ( r128 ), parameter :: kC3 = 1.46754004_r128 real ( r128 ), parameter :: kD1 = 1.036467755_r128 real ( r128 ), parameter :: kD2 = 5.295844968_r128 real ( r128 ), parameter :: kD3 = 3.631288474_r128 real ( r128 ), parameter :: kHm = 0.483941449_r128 real ( r128 ), parameter :: kZm = 0.107981933_r128 real ( r128 ), parameter :: kHp = 4.132731354_r128 real ( r128 ), parameter :: kZp = 1 8.52161694_r128 real ( r128 ), parameter :: kPhln = 0.4515827053_r128 real ( r128 ), parameter :: kHm1 = 0.516058551_r128 real ( r128 ), parameter :: kHp1 = 3.132731354_r128 real ( r128 ), parameter :: kHzm = 0.375959516_r128 real ( r128 ), parameter :: kHzmp = 0.591923442_r128 real ( r128 ), parameter :: kAs = 0.8853395638_r128 real ( r128 ), parameter :: kBs = 0.2452635696_r128 real ( r128 ), parameter :: kCs = 0.2770276848_r128 real ( r128 ), parameter :: kB = 0.5029324303_r128 real ( r128 ), parameter :: kX0 = 0.4571828819_r128 real ( r128 ), parameter :: kYm = 0.187308492_r128 real ( r128 ), parameter :: kS = 0.7270572718_r128 real ( r128 ), parameter :: kT = 0.03895759111_r128 rn = 0e0_r128 ; x = 0e0_r128 ; y = 0e0_r128 ; z = 0e0_r128 ; res = 0e0_r128 ; gauss_res = 0e0_r128 outer : do call random_number ( y ) if ( y > kHm1 ) then res = kHp * y - kHp1 ; exit outer else if ( y < kZm ) then rn = kZp * y - 1.0_r128 if ( rn > 0.0_r128 ) then res = 1.0_r128 + rn ; exit outer else res = - 1.0_r128 + rn ; exit outer end if else if ( y < kHm ) then call random_number ( rn ) rn = rn - 1.0_r128 + rn if ( rn > 0.0_r128 ) then z = 2.0_r128 - rn else z = - 2.0_r128 - rn end if if ( ( kC1 - y ) * ( kC3 + abs ( z )) < kC2 ) then res = z ; exit outer else x = rn * rn if ( ( y + kD1 ) * ( kD3 + x ) < kD2 ) then res = rn ; exit outer else if ( kHzmp - y < exp ( - ( z * z + kPhln ) / 2.0_r128 ) ) then res = z ; exit outer else if ( y + kHzm < exp ( - ( x + kPhln ) / 2.0_r128 ) ) then res = rn ; exit outer end if end if end if inner : do call random_number ( x ); call random_number ( y ) y = kYm * y z = kX0 - kS * x - y if ( z > 0.0_r128 ) then rn = 2.0_r128 + y / x else x = 1.0_r128 - x y = kYm - y rn = - ( 2.0_r128 + y / x ) end if if ( ( y - kAs + x ) * ( kCs + x ) + kBs < 0.0_r128 ) then res = rn ; exit inner else if ( y < x + kT ) then if ( rn * rn < 4.0_r128 * ( kB - log ( x )) ) then res = rn ; exit inner end if end if end do inner exit outer end do outer gauss_res = res * sig + mu end procedure gauss_r128 module procedure gauss_r64 real ( r64 ) :: rn , x , y , z , res real ( r64 ), parameter :: kC1 = 1.448242853_r64 real ( r64 ), parameter :: kC2 = 3.307147487_r64 real ( r64 ), parameter :: kC3 = 1.46754004_r64 real ( r64 ), parameter :: kD1 = 1.036467755_r64 real ( r64 ), parameter :: kD2 = 5.295844968_r64 real ( r64 ), parameter :: kD3 = 3.631288474_r64 real ( r64 ), parameter :: kHm = 0.483941449_r64 real ( r64 ), parameter :: kZm = 0.107981933_r64 real ( r64 ), parameter :: kHp = 4.132731354_r64 real ( r64 ), parameter :: kZp = 1 8.52161694_r64 real ( r64 ), parameter :: kPhln = 0.4515827053_r64 real ( r64 ), parameter :: kHm1 = 0.516058551_r64 real ( r64 ), parameter :: kHp1 = 3.132731354_r64 real ( r64 ), parameter :: kHzm = 0.375959516_r64 real ( r64 ), parameter :: kHzmp = 0.591923442_r64 real ( r64 ), parameter :: kAs = 0.8853395638_r64 real ( r64 ), parameter :: kBs = 0.2452635696_r64 real ( r64 ), parameter :: kCs = 0.2770276848_r64 real ( r64 ), parameter :: kB = 0.5029324303_r64 real ( r64 ), parameter :: kX0 = 0.4571828819_r64 real ( r64 ), parameter :: kYm = 0.187308492_r64 real ( r64 ), parameter :: kS = 0.7270572718_r64 real ( r64 ), parameter :: kT = 0.03895759111_r64 rn = 0e0_r64 ; x = 0e0_r64 ; y = 0e0_r64 ; z = 0e0_r64 ; res = 0e0_r64 ; gauss_res = 0e0_r64 outer : do call random_number ( y ) if ( y > kHm1 ) then res = kHp * y - kHp1 ; exit outer else if ( y < kZm ) then rn = kZp * y - 1.0_r64 if ( rn > 0.0_r64 ) then res = 1.0_r64 + rn ; exit outer else res = - 1.0_r64 + rn ; exit outer end if else if ( y < kHm ) then call random_number ( rn ) rn = rn - 1.0_r64 + rn if ( rn > 0.0_r64 ) then z = 2.0_r64 - rn else z = - 2.0_r64 - rn end if if ( ( kC1 - y ) * ( kC3 + abs ( z )) < kC2 ) then res = z ; exit outer else x = rn * rn if ( ( y + kD1 ) * ( kD3 + x ) < kD2 ) then res = rn ; exit outer else if ( kHzmp - y < exp ( - ( z * z + kPhln ) / 2.0_r64 ) ) then res = z ; exit outer else if ( y + kHzm < exp ( - ( x + kPhln ) / 2.0_r64 ) ) then res = rn ; exit outer end if end if end if inner : do call random_number ( x ); call random_number ( y ) y = kYm * y z = kX0 - kS * x - y if ( z > 0.0_r64 ) then rn = 2.0_r64 + y / x else x = 1.0_r64 - x y = kYm - y rn = - ( 2.0_r64 + y / x ) end if if ( ( y - kAs + x ) * ( kCs + x ) + kBs < 0.0_r64 ) then res = rn ; exit inner else if ( y < x + kT ) then if ( rn * rn < 4.0_r64 * ( kB - log ( x )) ) then res = rn ; exit inner end if end if end do inner exit outer end do outer gauss_res = res * sig + mu end procedure gauss_r64 module procedure gauss_r32 real ( r32 ) :: rn , x , y , z , res real ( r32 ), parameter :: kC1 = 1.448242853_r32 real ( r32 ), parameter :: kC2 = 3.307147487_r32 real ( r32 ), parameter :: kC3 = 1.46754004_r32 real ( r32 ), parameter :: kD1 = 1.036467755_r32 real ( r32 ), parameter :: kD2 = 5.295844968_r32 real ( r32 ), parameter :: kD3 = 3.631288474_r32 real ( r32 ), parameter :: kHm = 0.483941449_r32 real ( r32 ), parameter :: kZm = 0.107981933_r32 real ( r32 ), parameter :: kHp = 4.132731354_r32 real ( r32 ), parameter :: kZp = 1 8.52161694_r32 real ( r32 ), parameter :: kPhln = 0.4515827053_r32 real ( r32 ), parameter :: kHm1 = 0.516058551_r32 real ( r32 ), parameter :: kHp1 = 3.132731354_r32 real ( r32 ), parameter :: kHzm = 0.375959516_r32 real ( r32 ), parameter :: kHzmp = 0.591923442_r32 real ( r32 ), parameter :: kAs = 0.8853395638_r32 real ( r32 ), parameter :: kBs = 0.2452635696_r32 real ( r32 ), parameter :: kCs = 0.2770276848_r32 real ( r32 ), parameter :: kB = 0.5029324303_r32 real ( r32 ), parameter :: kX0 = 0.4571828819_r32 real ( r32 ), parameter :: kYm = 0.187308492_r32 real ( r32 ), parameter :: kS = 0.7270572718_r32 real ( r32 ), parameter :: kT = 0.03895759111_r32 rn = 0e0_r32 ; x = 0e0_r32 ; y = 0e0_r32 ; z = 0e0_r32 ; res = 0e0_r32 ; gauss_res = 0e0_r32 outer : do call random_number ( y ) if ( y > kHm1 ) then res = kHp * y - kHp1 ; exit outer else if ( y < kZm ) then rn = kZp * y - 1.0_r32 if ( rn > 0.0_r32 ) then res = 1.0_r32 + rn ; exit outer else res = - 1.0_r32 + rn ; exit outer end if else if ( y < kHm ) then call random_number ( rn ) rn = rn - 1.0_r32 + rn if ( rn > 0.0_r32 ) then z = 2.0_r32 - rn else z = - 2.0_r32 - rn end if if ( ( kC1 - y ) * ( kC3 + abs ( z )) < kC2 ) then res = z ; exit outer else x = rn * rn if ( ( y + kD1 ) * ( kD3 + x ) < kD2 ) then res = rn ; exit outer else if ( kHzmp - y < exp ( - ( z * z + kPhln ) / 2.0_r32 ) ) then res = z ; exit outer else if ( y + kHzm < exp ( - ( x + kPhln ) / 2.0_r32 ) ) then res = rn ; exit outer end if end if end if inner : do call random_number ( x ); call random_number ( y ) y = kYm * y z = kX0 - kS * x - y if ( z > 0.0_r32 ) then rn = 2.0_r32 + y / x else x = 1.0_r32 - x y = kYm - y rn = - ( 2.0_r32 + y / x ) end if if ( ( y - kAs + x ) * ( kCs + x ) + kBs < 0.0_r32 ) then res = rn ; exit inner else if ( y < x + kT ) then if ( rn * rn < 4.0_r32 * ( kB - log ( x )) ) then res = rn ; exit inner end if end if end do inner exit outer end do outer gauss_res = res * sig + mu end procedure gauss_r32 ! Elemental procedures for gauss ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure random_gauss_r128 x = gauss ( mu , sig ) end procedure random_gauss_r128 module procedure random_gauss_r64 x = gauss ( mu , sig ) end procedure random_gauss_r64 module procedure random_gauss_r32 x = gauss ( mu , sig ) end procedure random_gauss_r32 end submodule gaussian_sampling","tags":"","loc":"sourcefile/gaussian_sampling_impl.f90.html"},{"title":"API Design – IO-Fortran-Library","text":"The API is made available for use through the following statement: use io_fortran_lib which may be placed at the start of any compilation unit, immediately\nfollowing the program , module , function , or subroutine statement, and before any implicit statement. The functionality provided by the API is distributed via a handful of generic interfaces and a derived type String . The corresponding routines operate on\nnumeric and string data, and take a minimal number of arguments with\noptional arguments to customize output for particular use cases. This\nensures ease of use and flexibility for the end-user, without the need\nfor any specific knowledge regarding the internal implementations. For\nadvanced character handling, the String type provides extensive\nfunctionality through type-bound procedures .\nFor convenience, a list of constants are also\nprovided. The design of io_fortran_lib is dualistic in nature. That is, for\neach operation represented by an interface, there exists a transpose\noperation with a corresponding interface, such as String ⇆ cast , str ⇆ cast , to_file ⇆ from_file , read_file ⇆ write_file , join ⇆ split , and so on. Each pair of interfaces are designed to\nmirror each other in their arguments and assumptions of optional\narguments. Note All file I/O (both text and binary) is conducted via unformatted,\nstream-access reads and writes as introduced in Fortran 2003.","tags":"","loc":"page/index.html"},{"title":"Important User Information – IO-Fortran-Library","text":"The following subsections detail important information for users: Numeric text formats Locales File extensions Error Codes Compiler-dependent behavior Character sets and kinds Thread safety","tags":"","loc":"page/UserInfo/index.html"},{"title":"Numeric text formats – IO-Fortran-Library","text":"When writing integer data as strings with String , str , or to_file , any of the following text formats may\nbe used: INT_FMTS = [ \"i\" , \"z\" ] \"i\" : integer format (default), e.g. 123456 \"z\" : hexadecimal format, e.g. 0x1e240 When writing floating point numbers of type real or complex as\nstrings with String , str , or to_file , any of the following text formats may\nbe used: REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] \"e\" : normalized exponential format (default), e.g. 1.23456789012345675e+005 \"f\" : decimal format, e.g. 123456.789012345674 \"z\" : hexadecimal format, e.g. 0x40fe240c9fcb68cd Note The \"z\" hexadecimal format is an unsigned integer format and\nmay be used for integer , real , or complex data. Floating point\nnumbers are interpreted bit-wise as unsigned integers when written with\nthe \"z\" format, preventing any loss of precision in a round-trip\nconversion. This format is preferred in data transfers for which\nprecision losses are intolerable. The \"z\" format may also be\npreferred for faster read/write times and more compact storage. When moving data in the opposite direction with the complementary\nprocedures cast or from_file , the same fmt is required to\nproperly cast the data. Specifying a fmt that is different from what\nis actually present may result in an I/O syntax error. Note By default, real and complex data will be written with a\nnumber of significant digits required for a lossless round-trip\nconversion of the form numeric -> string -> numeric . In general, one\nmay expect the f format to produce losses in round-trip conversion of\nup to a few epsilon in as many as a fifth of transfers. However, the e format is not expected to produce any losses, and the z format\nwill never produce losses as it involves direct bit transfer (no\nbase-10 ⇆ base-2 conversions are involved). Note For negative integers, the hexadecimal format \"z\" produces\nambiguities across storage sizes. For instance, the integer 0xff equates to -1 in int8 storage but equates to 255 in larger\nstorage sizes. Similarly, the integer 0xffff equates to -1 in int16 storage but equates to 65535 in larger storage sizes, and so\non. It is the responsibility of the programmer to cast hexadecimal\nstrings into variables with the proper storage size.","tags":"","loc":"page/UserInfo/text-fmts.html"},{"title":"Locales – IO-Fortran-Library","text":"When writing floating point numbers of type real or complex as\nstrings with String , str , or to_file , any of the following locales may be\nused: LOCALES = [ \"US\" , \"EU\" ] \"US\" : US decimal (default), e.g. 1.23456789 \"EU\" : EU decimal, e.g. 1,23456789 With to_file and from_file , the locale additionally determines\nthe default delimiter, e.g. 1.23456789,0.12345678 for locale=\"US\" and 1,23456789;0,12345678 for locale=\"EU\" . When moving data in the opposite direction with the complementary\nprocedures cast or from_file , the same locale is required to\nproperly read the decimals. Specifying a locale that is different\nfrom what is actually present may result in an I/O syntax error.","tags":"","loc":"page/UserInfo/locale-fmts.html"},{"title":"File extensions – IO-Fortran-Library","text":"When writing to file or reading from file, a valid file extension must\nbe present. The following are valid text file extensions: TEXT_EXT = [ \"csv\" , \"txt\" , \"log\" , & \"rtf\" , \"odm\" , \"odt\" , & \"ods\" , \"odf\" , \"xls\" , & \"doc\" , \"org\" , \"dbf\" , & \"bed\" , \"gff\" , \"gtf\" ] The following are valid binary file extensions: BINARY_EXT = [ \"dat\" , \"bin\" ] The routines to_file and from_file will detect the file extension used\nand direct whether to write/read a text file or a binary file. The\nroutines echo , write_file , and read_file accept only text\nextensions. Other file extensions may be eligible for addition.","tags":"","loc":"page/UserInfo/file-ext.html"},{"title":"Error Codes – IO-Fortran-Library","text":"When writing to file or reading from file, the optional arguments stat and errmsg may be present, which will detail any errors that\nmay occur during execution of the procedure. The error codes have the\nfollowing explanation: integer , parameter :: READ_ERR = 1 ! Read error code integer , parameter :: WRITE_ERR = 2 ! Write error code integer , parameter :: ALLOC_ERR = 3 ! Allocation error code integer , parameter :: ARG_ERR = 4 ! Argument error code A READ_ERR code indicates that an error has occured during a read statement, inquire statement, or a close statement in the execution\nof from_file or read_file . A WRITE_ERR code\nindicates that an error has occured during a write statement or a close statement in the execution of to_file , echo , or write_file . An ALLOC_ERR code indicates that an allocate or deallocate statement has failed.\nAn ARG_ERR code indicates that the user has provided an incorrect\nargument to the procedure. In all cases, the errmsg will contain more detailed information about\nthe error that occured. If no error condition occurs, the stat will\nreturn 0 and the errmsg will be empty.","tags":"","loc":"page/UserInfo/error-codes.html"},{"title":"Compiler-dependent behavior – IO-Fortran-Library","text":"When writing text files, it's important to note that some compilers\nimplement extensions to the Fortran standard by default with regards\nto character array literals. For example, the array literal header = [ \"firstcol\" , \"secondcol\" ] is not standard Fortran 2018 since the strings in the array do not have\nidentical length. Some compilers will accept this and others will not.\nIf required, simply add padding spaces to the left or right of each\nstring to match the length of the longest element. These padding\nspaces will not be present in the output file. Note Some compilers may allocate strings dynamically on the stack.\nWhen reading large text files, this may result in a stack overflow or\nsegmentation fault unless the compiler is directed to allocate\neverything on the heap. For example, one would specify -heap-arrays 0 for the Intel Fortran compiler on Linux ( /heap-arrays:0 on Windows).","tags":"","loc":"page/UserInfo/compilers.html"},{"title":"Character sets and kinds – IO-Fortran-Library","text":"The IO-Fortran-Library officially supports the standard Fortran\ncharacter set, based on the US-ASCII character set with\ndefault character kind . On most systems, the default kind will\nconsist of precisely one byte per character, equivalent to selected_char_kind(\"ascii\") . Since US-ASCII is a 7-bit character set\nand most systems use 8-bit characters, it must be noted that only the\nfirst 128 characters are system-independent, i.e. achar(0) is\nportable but achar(255) is not. To maximize portability across\nsystems and compilers, the IO-Fortran-Library does not reference any\nother character sets or kinds other than the 128-character US-ASCII\nwith default kind . However, most users should feel free to employ characters outside of\nthe US-ASCII in strings and string expressions (including many Unicode\nsymbols) and these will tend to behave as expected as long as the\ncharacters can fit comfortably into one byte and the output unit\nsupports UTF-8 encoding. For instance, inspect the output of the\nfollowing program: program main use io_fortran_lib implicit none ( type , external ) type ( String ) :: emojis emojis = \"😂🙈😊🤣\" + \"😍\" - \"😂\" + \"👌\" ** 5 call emojis % echo ( \"emojis.txt\" ) write ( * , * ) emojis end program main The expected result is 🙈😊🤣😍👌👌👌👌👌 , which will be displayed\nproperly in any terminal or text file with UTF-8 encoding. Note The Fortran standard permits compilers to support character sets\nand kinds other than US-ASCII with one-byte kind , and acknowledges\nthe extended four-byte UCS-4 character set defined by ISO 10646, but such support is highly\ninconsistent across compilers at the time of writing.","tags":"","loc":"page/UserInfo/characters.html"},{"title":"Thread safety – IO-Fortran-Library","text":"The IO-Fortran-Library promotes thread-safety by explicitly enforcing\nrecursion with the recursive keyword on all module procedures.\nHowever, performing I/O in parallel regions has the tendency to result\nin unexpected behavior. For instance, inspect the output of the\nfollowing program with multiple coarray images: program main use io_fortran_lib implicit none ( type , external ) call echo ( \"Hello from image \" // str ( this_image ()), file = \"hello.txt\" ) end program main This program will result in conflicts as multiple images attempt to\nwrite to the same file concurrently. The proper way to compose this\nprogram is by nesting echo inside a critical block to enforce\nstrict thread-safety in the region: program main use io_fortran_lib implicit none ( type , external ) critical call echo ( \"Hello from image \" // str ( this_image ()), file = \"hello.txt\" ) end critical end program main Another common scenario involves performing I/O on a single image,\nwhich is thread-safe: program main use io_fortran_lib implicit none ( type , external ) if ( this_image () == 1 ) then call echo ( \"Hello from image \" // str ( this_image ()), file = \"hello.txt\" ) end if end program main","tags":"","loc":"page/UserInfo/thread-safety.html"},{"title":"Reference Guide – IO-Fortran-Library","text":"The following subsections provide user instructions for each of the\npublicly accessible interfaces : String : Function for returning a String representation of numbers. str : Function for returning a character representation\n  of a number. cast : Subroutine for casting between numeric and string\n  data. join and split : Functions for joining and\n  splitting strings. to_file : Subroutine for writing an array of uniform\n  numeric data type to an external file. from_file : Subroutine for reading an external file\n  of uniform numeric data type and format into an array. echo : Subroutine for writing a scalar character or String to an external text file. aprint : Subroutine for printing arrays and array\n  sections to stdout. String methods : Type-bound procedures for String . Operators : Extended operators for convenient string\n  manipulations.","tags":"","loc":"page/Ref/index.html"},{"title":"CONSTANTS – IO-Fortran-Library","text":"The io_fortran_lib module provides access to a handful of parameter constants for general use: NL : The newline character (system agnostic). SPACE : The space character. CR : The carriage return character. FF : The form feed character. VT : The vertical tab character. LF : The line feed character. TAB : The horizontal tab character. HT : The horizontal tab character (alternate name). BELL : The bell/alert character. NUL : The null character. CNUL : The C null character re-exported from iso_c_binding .","tags":"","loc":"page/Ref/constants.html"},{"title":"String – IO-Fortran-Library","text":"interface String Description : Function for returning a String representation of numbers. To return the empty String , use no arguments: result = String () For x a scalar or array of any rank and of type character : result = String ( x ) This is for character to String conversion. For x a scalar or array of any rank and of type integer : result = String ( x [, fmt ]) fmt is optional , may be one of INT_FMTS For x a scalar or array of any rank and of type real : result = String ( x [, locale , fmt , decimals ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x a scalar or array of any rank and of type complex : result = String ( x [, locale , fmt , decimals , im ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note Unlike str , which takes scalar arguments only and\nreturns a character , String operates elementally and returns a String . Optional Arguments Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"e\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Locales (default is \"US\" ): LOCALES = [ \"US\" , \"EU\" ] Decimals: decimals specifies the number of digits on the rhs of the\nradix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By\ndefault, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as\na sum with the specified imaginary unit, e.g. 2.45+3.45j for im=\"j\" or 2.45+3.45*1i for im=\"*1i\" .","tags":"","loc":"page/Ref/String.html"},{"title":"str – IO-Fortran-Library","text":"interface str Description : Function for returning a character representation of a\nnumber. To return the empty string ,\nuse no arguments: result = str () For x a scalar of type String : result = str ( x ) This is for scalar String to character conversion. For x a scalar of type integer : result = str ( x [, fmt ]) fmt is optional , may be one of INT_FMTS For x a scalar of type real : result = str ( x [, locale , fmt , decimals ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x a scalar of type complex : result = str ( x [, locale , fmt , decimals , im ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note Note that str operates on scalars only. For elemental\nfunctionality, see String . Optional Arguments Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"e\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Locales (default is \"US\" ): LOCALES = [ \"US\" , \"EU\" ] Decimals: decimals specifies the number of digits on the rhs of the\nradix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By\ndefault, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as\na sum with the specified imaginary unit, e.g. 2.45+3.45j for im=\"j\" or 2.45+3.45*1i for im=\"*1i\" .","tags":"","loc":"page/Ref/str.html"},{"title":"cast – IO-Fortran-Library","text":"interface cast Description : Subroutine for casting between numeric and string data. Casting numbers to string variables For casting x of type integer into a variable into of type character (scalar only) or String (any rank): call cast ( x , into [, fmt ]) fmt is optional , may be one of INT_FMTS For casting x of type real into a variable into of type character (scalar only) or String (any rank): call cast ( x , into [, locale , fmt , decimals ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For casting x of type complex into a variable into of type character (scalar only) or String (any rank): call cast ( x , into [, locale , fmt , decimals , im ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note While str and String return values\nwhich may be used flexibly inside of string expressions, cast may be\nused as above to write directly to variables. When converting large\namounts of data to strings, cast may be up to 2x faster than the\nfunctional alternatives since the total number of string allocations is\nreduced by at least half, all else being equal. Casting strings to numeric variables For casting substring of type character (scalar only) or String (any rank) into a variable into of type integer : call cast ( substring , into [, fmt ]) call substring % cast ( into [, fmt ]) fmt is optional , may be one of INT_FMTS For casting substring of type character (scalar only) or String (any rank) into a variable into of type real : call cast ( substring , into [, locale , fmt ]) call substring % cast ( into [, locale , fmt ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS For casting substring of type character (scalar only) or String (any rank) into a variable into of type complex : call cast ( substring , into [, locale , fmt , im ]) call substring % cast ( into [, locale , fmt , im ]) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS im is optional and of type character(len=*) Warning The arguments x and substring must always be of the same\nrank and shape as into , which must be pre-allocated prior to calling cast due to the restrictions on intent(out) arguments of elemental procedures. Note The type-bound procedure access of the form call substring%cast() is valid when substring is a String variable. To cast a String -valued expression, the expression must be\npassed to cast by the form call cast() . Optional Arguments Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"e\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Locales (default is \"US\" ): LOCALES = [ \"US\" , \"EU\" ] Decimals: decimals specifies the number of digits on the rhs of the\nradix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. If not\npresent, complex numbers will be assumed to be written as ordered\npairs, e.g. (2.45,3.45) .","tags":"","loc":"page/Ref/cast.html"},{"title":"join and split – IO-Fortran-Library","text":"interface join Description : Function for joining a vector of tokens into a scalar character or String . To join a one-dimensional array tokens of type character or String : result = join ( tokens [, separator ]) separator is optional and of type character(len=*) For a subroutine version of join , see join . Note The return type of join is the same as the type of tokens . interface split Description : Function for splitting a scalar character or String into a vector of tokens . For substring a scalar character or String : result = split ( substring [, separator ]) separator is optional and of type character(len=*) For substring a scalar variable of type String : result = substring % split ([ separator ]) separator is optional and of type character(len=*) Note The type-bound procedure access of the form substring%split() is valid when substring is a String variable. To split a String -valued expression, the expression must be passed to split by\nthe form split(substring) . Note The return type of split is always String . Optional Arguments Separator (default is SPACE ): the separator to use when joining or\nsplitting.","tags":"","loc":"page/Ref/join-split.html"},{"title":"to_file – IO-Fortran-Library","text":"interface to_file Description : Subroutine for writing an array of uniform numeric data\ntype to an external file. For writing textual data from an array x of rank 1 , 2 and of type integer : call to_file ( x , file [, header , delim , fmt , stat , errmsg ]) file is of type character(len=*) header is optional and of type character(len=*), dimension(:) delim is optional and of type character(len=*) fmt is optional , may be one of INT_FMTS stat is optional and of type integer errmsg is optional and of type character(len=*) For writing textual data from an array x of rank 1 , 2 and of type real : call to_file ( x , file [, header , locale , delim , fmt , decimals , stat , errmsg ]) file is of type character(len=*) header is optional and of type character(len=*), dimension(:) locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer stat is optional and of type integer errmsg is optional and of type character(len=*) For writing textual data from an array x of rank 1 , 2 and of type complex : call to_file ( x , file [, header , locale , delim , fmt , decimals , im , stat , errmsg ]) file is of type character(len=*) header is optional and of type character(len=*), dimension(:) locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) stat is optional and of type integer errmsg is optional and of type character(len=*) For writing binary data from an array x of any rank 1 - 15 and of\ntype integer , real , complex : call to_file ( x , file [, stat , errmsg ]) file is of type character(len=*) stat is optional and of type integer errmsg is optional and of type character(len=*) Note file may be a relative path, but absolute paths are not\nguaranteed to work on every platform. Note to_file will always use the NL line ending when writing text\nfiles (which on most systems equates to LF ). Optional Arguments Header (default is none): header is a character array literal . For x of rank 1 , header may be of size 1 or size(x) . For x of rank 2 , header may be of size 1 or size(x, dim=2) . Locales (default is \"US\" ): LOCALES = [ \"US\" , \"EU\" ] Delimiter: data separator. Default is \",\" for integer data and for real / complex data with \"US\" locale, and \";\" for real / complex data with \"EU\" locale. It is always recommended to\nomit the delimiter argument for default unless a custom delimiter is\nreally necessary. If x has rank 1 and dim=1 , then the delim argument is ignored. Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"e\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Decimals: decimals specifies the number of digits on the rhs of the\nradix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By\ndefault, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as\na sum with the specified imaginary unit, e.g. 2.45+3.45j for im=\"j\" or 2.45+3.45*1i for im=\"*1i\" .","tags":"","loc":"page/Ref/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"interface from_file Description : Subroutine for reading an external file of uniform\nnumeric data type and format into an array. For reading textual data into an array into of rank 1 or 2 and of\ntype integer : call from_file ( file , into [, header , delim , fmt , stat , errmsg ]) file is of type character(len=*) header is optional and of type logical delim is optional and of type character(len=*) fmt is optional , may be one of INT_FMTS stat is optional and of type integer errmsg is optional and of type character(len=*) For reading textual data into an array into of rank 1 or 2 and of\ntype real : call from_file ( file , into [, header , locale , delim , fmt , stat , errmsg ]) file is of type character(len=*) header is optional and of type logical locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS stat is optional and of type integer errmsg is optional and of type character(len=*) For reading textual data into an array into of rank 1 or 2 and of\ntype complex : call from_file ( file , into [, header , locale , delim , fmt , im , stat , errmsg ]) file is of type character(len=*) header is optional and of type logical locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS im is optional and of type character(len=*) stat is optional and of type integer errmsg is optional and of type character(len=*) For reading binary data into an array into of any rank 1 - 15 and\nof type integer , real , complex : call from_file ( file , into , data_shape [, stat , errmsg ]) file is of type character(len=*) data_shape is of type integer, dimension(:) stat is optional and of type integer errmsg is optional and of type character(len=*) Note file may be a relative path, but absolute paths are not\nguaranteed to work on every platform. Warning In all cases, into must be allocatable , and will lose its\nallocation status upon passing into from_file if already allocated.\nAs a result, from_file does not allow reading into sections of\nalready allocated arrays. Note When reading binary data, data_shape must be present and its\nsize must equal the rank of into . Optional Arguments Header (default is .false. ): specifies whether a header line is\npresent. Locales (default is \"US\" ): LOCALES = [ \"US\" , \"EU\" ] Delimiter: data separator. Default is \",\" for integer data and for real / complex data with \"US\" locale, and \";\" for real / complex data with \"EU\" locale. It is always recommended to\nomit the delimiter argument for default unless a custom delimiter is\nreally necessary. If x has rank 1 and the data is ordered down the\nrows, then the delim argument is ignored. Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"e\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Imaginary unit: im specifies the form of a complex number. If not\npresent, complex numbers will be assumed to be written as ordered\npairs, e.g. (2.45,3.45) .","tags":"","loc":"page/Ref/from_file.html"},{"title":"echo – IO-Fortran-Library","text":"interface echo Description : Subroutine for writing a scalar character or String to an external text file. For substring a scalar of type character or String : call echo ( substring , file [, append , terminator , stat , errmsg ]) file is of type character(len=*) append is optional and of type logical terminator is optional and of type character(len=*) stat is optional and of type integer errmsg is optional and of type character(len=*) For substring a scalar variable of type String : call substring % echo ( file [, append , terminator , stat , errmsg ]) file is of type character(len=*) append is optional and of type logical terminator is optional and of type character(len=*) stat is optional and of type integer errmsg is optional and of type character(len=*) Note The type-bound procedure access of the form call substring%echo() is valid when substring is a String variable. To echo a String -valued expression, the expression must be\npassed to echo by the form call echo() . Note file may be a relative path, but absolute paths are not\nguaranteed to work on every platform. Optional Arguments Append (default is .true. ): append specifies whether to append or\nto replace the file file . Either way, the file will be created if it\ndoes not exist. Terminator (default is LF ): terminator is a string terminator\ninserted at the end of the input string.","tags":"","loc":"page/Ref/echo.html"},{"title":"aprint – IO-Fortran-Library","text":"interface aprint Description : Subroutine for printing arrays and array sections to\nstdout. For x an array of rank 1 or 2 and of type character or String : call aprint ( x ) For x an array of rank 1 or 2 and of type integer : call aprint ( x [, fmt ]) fmt is optional , may be one of INT_FMTS For x an array of rank 1 or 2 and of type real : call aprint ( x [, fmt , decimals ]) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x an array of rank 1 or 2 and of type complex : call aprint ( x [, fmt , decimals , im ]) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Optional Arguments Integer formats (default is \"i\" ): INT_FMTS = [ \"i\" , \"z\" ] Real formats (default is \"f\" ): REAL_FMTS = [ \"e\" , \"f\" , \"z\" ] Decimals (default is 2 ): decimals specifies the number of digits on\nthe rhs of the radix point. Imaginary unit (default is \"j\" ): im specifies the form of a complex\nnumber. Note The optional arguments for aprint are different than elsewhere,\nand better suited for easy viewing of array sections.","tags":"","loc":"page/Ref/aprint.html"},{"title":"String methods – IO-Fortran-Library","text":"type String Description : A growable string type for advanced character handling\nand text I/O. Note In addition to the functionality provided through type-bound\nprocedures, the String type may be useful in array contexts for which\nthe user requires arrays of strings which may have non-identical\nlengths, whose lengths may not be known, whose lengths may need to vary\nduring run time, or in any other context in which the intrinsic character type is insufficient. Type-bound procedures as_str For self a scalar variable of type String : result = self % as_str () Description : Returns a copy of the string slice component of a scalar String . This procedure is identical in function to the type\nconversion result = str(self) . cast Description : A generic binding for the interface cast . count For self a scalar or array variable of any rank and of type String : result = self % count ( match ) match is of type character(len=*) or String Description : Returns number of non-overlapping occurrences of a\nsubstring elementally. Note match may be a scalar or the same rank and shape as self . echo Description : A generic binding for the interface echo . empty For self a scalar or array variable of any rank and of type String : call self % empty () Description : Sets the string slice component to the empty string\nelementally. This procedure is identical in function to the assignment self = String() . join For self a scalar variable of type String : call self % join ( tokens [, separator ]) tokens is of type type(String), dimension(:) separator is optional and of type character(len=*) (default is SPACE ) Description : Joins a String vector tokens into self with given\nseparator. Default separator is SPACE . The string slice component\nwill be replaced if already allocated. For a functional version of join , see join . len For self a scalar or array variable of any rank and of type String : result = self % len () Description : Returns the length of the string slice component\nelementally. Unallocated components return -1 . For strings larger\nthan 2,147,483,647 bytes, use self%len64() . push For self a scalar or array variable of any rank and of type String : call self % push ( substring ) substring is of type character(len=*) or String Description : Appends to the string slice component elementally in\nplace. This procedure is identical in function to the concatenation operators with self\nassignment: self = self // substring and self = self + substring . Note substring may be a scalar or the same rank and shape as self . read_file For self a scalar variable of type String : call self % read_file ( file [, cell_array , row_separator , column_separator , stat , errmsg ]) file is of type character(len=*) cell_array is optional and of type type(String), allocatable, dimension(:,:) row_separator is optional and of type character(len=*) (default is LF ) column_separator is optional and of type character(len=*) (default is \",\" ) stat is optional and of type integer errmsg is optional and of type character(len=*) Description : Reads raw text file contents into self and optionally\npopulates a cell array using the designated row_separator and column_separator whose default values are LF and \",\" respectively. Note file may be a relative path, but absolute paths are not\nguaranteed to work on every platform. Note The cell_array must be allocatable and will be re-allocated\ninternally (if already allocated). replace For self a scalar or array variable of any rank and of type String : result = self % replace ( match , substring [, back ]) match is of type character(len=*) or String substring is of type character(len=*) or String back is optional and of type logical (default is .false. ) Description : Matches and replaces all occurrences of a substring\nelementally. If back is .true. , then self is scanned from back to\nfront, which may result in a different outcome in the case that match is overlapping itself. Note match and substring may be any combination of character and String , and may be any combination of scalars or arrays with the\nsame rank and shape as self , with the same rank/shape matching rules\napplying to back . replace_inplace For self a scalar or array variable of any rank and of type String : call self % replace_inplace ( match , substring [, back ]) match is of type character(len=*) or String substring is of type character(len=*) or String back is optional and of type logical (default is .false. ) Description : Matches and replaces all occurrences of a substring\nelementally in place. If back is .true. , then self is scanned\nfrom back to front, which may result in a different outcome in the\ncase that match is overlapping itself. Note match and substring may be any combination of character and String , and may be any combination of scalars or arrays with the same\nrank and shape as self , with the same rank/shape matching rules\napplying to back . split Description : A generic binding for the interface split . trim For self a scalar or array variable of any rank and of type String : result = self % trim () Description : Returns a copy of a String elementally in which each\nstring slice component has been trimmed of any leading or trailing\nwhitespace. trim_inplace For self a scalar or array variable of any rank and of type String : call self % trim_inplace () Description : Removes any leading or trailing whitespace of the string\nslice component of a String elementally and in place. write_file For self a scalar variable of type String : call self % write_file ( cell_array , file [, row_separator , column_separator , append , stat , errmsg ]) cell_array is of type type(String), dimension(:,:) file is of type character(len=*) row_separator is optional and of type character(len=*) (default is LF ) column_separator is optional and of type character(len=*) (default is \",\" ) append is optional and of type logical (default is .false. ) stat is optional and of type integer errmsg is optional and of type character(len=*) Description : Writes the content of a cell array to a text file. The\ncell array's entire contents are populated into self using the\ndesignated row_separator and column_separator whose default values\nare LF and \",\" respectively, and then streamed to an external text\nfile. The file will be created if it does not exist, and will be\nappended to if append is .true. . Note file may be a relative path, but absolute paths are not\nguaranteed to work on every platform. write(formatted) For substring a scalar or array of any rank and of type String : print \"(DT)\" , substring write ( unit , \"(DT)\" ) substring Description : Formatted write DTIO procedure for type String . Note When performing a formatted write to unit , use the derived-type\nedit descriptor format fmt=\"(DT)\" .","tags":"","loc":"page/Ref/String-methods.html"},{"title":"Operators – IO-Fortran-Library","text":"Operator interfaces Description : Extended operators for convenient string manipulations. Concatenation ( // and + ) For x and y scalars or arrays of any compatible rank, and of any\ncombination of type character and String : result = x // y result = x + y Note Concatenation of mixed type will return a String . Excision ( - ) For x and y scalars or arrays of any compatible rank, and of any\ncombination of type character and String : result = x - y Note Excision always returns a String value even when both arguments\nare of type character . This ensures that excision can be performed\nelementally even for character values, which would not be\nwell-defined with a return type of character . For two scalar character values, one may simply perform the conversion result = str(x - y) to return a scalar character . Note String arithmetic is not associative, commutative, or distributive in\ngeneral: (Associative) (x + y) + z == x + (y + z) and x + (y - z) /= (x +\n  y) - z are both .true. in general. (Commutative) x + y /= y + x and x + y - z /= x - z + y are both .true. in general. (Distributive) x - (y + z) /= x - y - z is .true. in general. Repetition ( ** ) For x a scalar or array of any rank, and of type character or String : result = x ** ncopies ncopies is of type integer Note The ** operator is a wrapper for the repeat intrinsic, and extended for type String . Equivalence ( == ) For x and y scalars or arrays of any compatible rank, and of any\ncombination of type character and String : result = ( x == y ) result = ( x . eq . y ) Non-equivalence ( /= ) For x and y scalars or arrays of any compatible rank, and of any\ncombination of type character and String : result = ( x /= y ) result = ( x . ne . y )","tags":"","loc":"page/Ref/operators.html"},{"title":"Tutorials – IO-Fortran-Library","text":"The following subsections provide example programs for common use cases\nof the public interfaces : Handling csv files Handling dat files Handling log files String manipulation FizzBuzz NGS Human Core Exome Panel Benchmarking","tags":"","loc":"page/Examples/index.html"},{"title":"Handling csv files – IO-Fortran-Library","text":"Basic csv file I/O The routines to_file and from_file are the preferred method for\nhandling I/O for numeric data of uniform type and format. Typical use\ncases involve writing whole arrays to file and reading files of uniform\ntype and format directly into an array of numeric type. The following program demonstrates the use of to_file and from_file for writing an array of real data to a csv file in each possible text format , reading each file back into\nthe program, and testing for exact equality to ensure that there has\nbeen no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_e , x_f , x_z call random_number ( x ) call to_file ( x , file = \"x_e.csv\" , header = [ \"x\" ], fmt = \"e\" ) call to_file ( x , file = \"x_f.csv\" , header = [ \"x\" ], fmt = \"f\" ) call to_file ( x , file = \"x_z.csv\" , header = [ \"x\" ], fmt = \"z\" ) call from_file ( \"x_e.csv\" , into = x_e , header = . true ., fmt = \"e\" ) call from_file ( \"x_f.csv\" , into = x_f , header = . true ., fmt = \"f\" ) call from_file ( \"x_z.csv\" , into = x_z , header = . true ., fmt = \"z\" ) write ( * , * ) \"x == x_e : \" , all ( x == x_e ) write ( * , * ) \"x == x_f : \" , all ( x == x_f ) write ( * , * ) \"x == x_z : \" , all ( x == x_z ) end program main Here we use the simple header header=[\"x\"] , which produces a header\nof the form: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20 Note that the default value for header when reading is .false. . If\na header is actually present, the output array will have an extra row\nwith default initialized values. Warning Default text format for writing and reading is \"e\" for data\nof type real or complex , and \"i\" for data of type integer .\nAttempting to read data with a format that does not correspond to the\nformat in the file may result in an I/O syntax error. Note Reading into arrays of a different kind than the array that was\nwritten is a type conversion, and will fail the equality test. Advanced csv file I/O The routines write_file and read_file are the preferred\nmethod for handling I/O for general text files. Typical use cases\ninvolve writing cell arrays of type String to delimited files, and\nreading delimited files into a cell array. For reading and writing\nnon-delimited text files, one would use read_file without the cell_array argument and echo . The same program as above can be recast in an object-oriented fashion\nthat is generalizable for processing data of mixed type: program main use io_fortran_lib , only : String , str , cast implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:,:) :: cells real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_e , x_f , x_z integer :: i call random_number ( x ); allocate ( cells ( 1001 , 20 ) ); cells ( 1 ,:) = [( String ( \"x\" // str ( i )), i = 1 , 20 )] call cast ( x , into = cells ( 2 :,:), fmt = \"e\" ); call csv % write_file ( cells , file = \"x_e.csv\" ) call cast ( x , into = cells ( 2 :,:), fmt = \"f\" ); call csv % write_file ( cells , file = \"x_f.csv\" ) call cast ( x , into = cells ( 2 :,:), fmt = \"z\" ); call csv % write_file ( cells , file = \"x_z.csv\" ) allocate ( x_e , x_f , x_z , mold = x ) call csv % read_file ( \"x_e.csv\" , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_e , fmt = \"e\" ) call csv % read_file ( \"x_f.csv\" , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_f , fmt = \"f\" ) call csv % read_file ( \"x_z.csv\" , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_z , fmt = \"z\" ) write ( * , * ) \"x == x_e : \" , all ( x == x_e ) write ( * , * ) \"x == x_f : \" , all ( x == x_f ) write ( * , * ) \"x == x_z : \" , all ( x == x_z ) end program main Here, we construct the same header as before with the implicit loop cells ( 1 ,:) = [( String ( \"x\" // str ( i )), i = 1 , 20 )] and then construct the remainder of the cell array cells with an\nelemental cast call cast(x, into=cells(2:,:), fmt) before writing the\narray to a csv file. We then read the files back into csv and output\nthe cells into cells (which is reallocated internally). Note that\nwhen casting the cell data into numeric arrays, we must pre-allocate\nthe output arrays due to the restrictions on intent(out) arguments\nof elemental procedures. Note One may optionally specify the arguments of row_separator and column_separator when writing and reading text files with write_file and read_file . The default row_separator is LF , and the default column_separator is \",\" . Warning When reading files with CRLF line endings, be sure to\nspecify row_separator=CR//LF or pre-process the file to LF . Trying\nto cast data with a hidden CR character may result in an I/O syntax\nerror. For a slightly more advanced example, consider the following program\nto read in and cast the data of mixed type contained in the example\ndata /data/ancestry_comp.csv : program main use , intrinsic :: iso_fortran_env , only : int8 , int64 use io_fortran_lib , only : String , cast , CR , LF , operator ( + ), operator ( - ) implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:,:) :: cells integer ( int8 ), allocatable , dimension (:) :: copy , chromosome integer ( int64 ), allocatable , dimension (:) :: start_point , end_point integer :: nrows call csv % read_file ( \"./data/ancestry_comp.csv\" , cell_array = cells , row_separator = CR + LF ) write ( * , * ) csv nrows = size ( cells , dim = 1 ) - 1 allocate ( copy ( nrows ), chromosome ( nrows ), start_point ( nrows ), end_point ( nrows ) ) call cells ( 2 :, 2 )% cast ( into = copy ) call cast ( cells ( 2 :, 3 )% replace ( \"X\" , \"0\" ) - \"chr\" , into = chromosome ) call cells ( 2 :, 4 )% cast ( into = start_point ) call cells ( 2 :, 5 )% cast ( into = end_point ) end program main Here, file is a relative path, and we use the extended operator + for concatenation in the character expression CR+LF . We then allocate data arrays and cast\neach column into respective arrays. Note that we must use cast as a standalone subroutine to accept the String -valued expression cells ( 2 :, 3 )% replace ( \"X\" , \"0\" ) - \"chr\" which first calls replace to\nreturn an elemental copy of the given cells in which all instances of X have been replaced with 0 , and then calls the excision operator - to remove all\ninstances of \"chr\" elementally. The output of the String expression\ncontains numeric characters only, which are then casted to the array chromosome . Note In general, for other text file extensions , one would specify\nthe column_separator associated with the given file. For instance,\none would specify column_separator=TAB for the file formats .bed , .gff , and .gtf .","tags":"","loc":"page/Examples/csv.html"},{"title":"Handling dat files – IO-Fortran-Library","text":"Binary file I/O The routines to_file and from_file are used for writing numeric arrays\nto binary files with the extension .dat or .bin . The following program demonstrates the use of to_file and from_file for writing real data of rank 5 to a .dat file, reading the file\nback into the program, and testing for exact equality to ensure that\nthere has been no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 20 , 20 , 20 , 20 , 20 ) :: x real , allocatable , dimension (:,:,:,:,:) :: x_dat call random_number ( x ) call to_file ( x , file = \"x.dat\" ) call from_file ( \"x.dat\" , into = x_dat , data_shape = shape ( x )) write ( * , * ) \"x == x_dat : \" , all ( x == x_dat ) end program main Warning Reading into arrays of a different kind than the array that\nwas written will invalidate the data. Always make sure the kind is\nmatching for binary I/O. TIP: The shape of an array may be written to a csv file so that the\nvalue of data_shape can be read into the program before reading in\nthe main array with the corresponding value. The following program\ndemonstrates the above tip: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 20 , 20 , 20 , 20 , 20 ) :: x real , allocatable , dimension (:,:,:,:,:) :: x_dat integer , allocatable , dimension (:) :: x_shape call random_number ( x ) call to_file ( x , file = \"x.dat\" ) call to_file ( shape ( x ), file = \"x_shape.csv\" ) call from_file ( \"x_shape.csv\" , into = x_shape ) call from_file ( \"x.dat\" , into = x_dat , data_shape = x_shape ) write ( * , * ) \"x == x_dat : \" , all ( x == x_dat ) end program main","tags":"","loc":"page/Examples/binary.html"},{"title":"Handling log files – IO-Fortran-Library","text":"Log file I/O The routine echo is the preferred method for\nwriting general text data to a log file. The following program demonstrates a simple use of echo for writing\nmessages to a log file: program main use io_fortran_lib , only : echo , str , LF implicit none ( type , external ) character ( len = :), allocatable :: logfile , logmsg character ( len = 10 ) :: date , time integer :: errstat call date_and_time ( date = date , time = time ) logfile = \"logfile_main_\" // trim ( adjustl ( date )) // \"_\" // time // \".log\" logmsg = \"PROGRAM MAIN - BEGINNING EXECUTION\" call echo ( logmsg // LF // repeat ( \"-\" , ncopies = len ( logmsg )), file = logfile ) ! ... logmsg = \"All is good so far...\" call echo ( logmsg , logfile ) read ( * , * ) errstat if ( errstat /= 0 ) then logmsg = \"Process has non-zero exit status: \" // str ( errstat ) // LF // \"Stopping...\" call echo ( logmsg , logfile ) error stop logmsg end if logmsg = \"All processes have executed successfully.\" call echo ( logmsg , logfile ) end program main Depending on style, one may wish to accumulate log messages into a String and then call the type-bound procedure echo conditionally: program main use io_fortran_lib , only : String , str , LF , operator ( + ), operator ( ** ) implicit none ( type , external ) type ( String ) :: logmsg character ( len = :), allocatable :: logfile character ( len = 10 ) :: date , time integer :: errstat call date_and_time ( date = date , time = time ) logfile = \"logfile_main_\" + trim ( adjustl ( date )) + \"_\" + time + \".log\" logmsg = String ( \"PROGRAM MAIN - BEGINNING EXECUTION\" ) call logmsg % push ( LF + \"-\" ** logmsg % len () + LF ) ! ... call logmsg % push ( \"All is good so far...\" + LF ) read ( * , * ) errstat if ( errstat /= 0 ) then call logmsg % push ( \"Process has non-zero exit status: \" + str ( errstat ) + LF + \"Stopping...\" ) call logmsg % echo ( logfile ) error stop logmsg % as_str () end if call logmsg % push ( \"All processes have executed successfully.\" ) call logmsg % echo ( logfile ) end program main Here, the error stop will dump the entire contents of logmsg to\nstdout. We also take advantage of the operators + and ** for concatenation and\nrepetition.","tags":"","loc":"page/Examples/logging.html"},{"title":"String manipulations – IO-Fortran-Library","text":"String Queries Sometimes it is useful or necessary to write execution conditions based\non compiler vendors or version, such as when a certain compiler version\nhas a known bug or when a piece of code is required for a specific\ncompiler. The following program shows how one may use the count procedure to determine a\ncompiler at runtime: program main use , intrinsic :: iso_fortran_env , only : compiler_version use io_fortran_lib , only : String implicit none ( type , external ) type ( String ) :: compiler logical :: GCC , GCC_RECENT , INTEL , INTEL_RECENT compiler = String ( compiler_version ()) GCC = compiler % count ( match = \"GCC\" ) > 0 GCC_RECENT = GCC . and . ( compiler % count ( match = \"11.3.0\" ) > 0 ) INTEL = compiler % count ( match = \"Intel\" ) > 0 INTEL_RECENT = INTEL . and . ( compiler % count ( match = \"2023.0.0\" ) > 0 ) write ( * , * ) compiler if ( GCC ) then if ( GCC_RECENT ) then write ( * , * ) \"Hello from a recent GNU Fortran Compiler.\" else write ( * , * ) \"Hello from an older GNU Fortran Compiler.\" end if else if ( INTEL ) then if ( INTEL_RECENT ) then write ( * , * ) \"Hello from a recent Intel Fortran Compiler.\" else write ( * , * ) \"Hello from an older Intel Fortran Compiler.\" end if end if end program main Dynamic string manipulation Using operator techniques and string methods , we may easily perform\ncomplex string manipulations during run time. The following program demonstrates the use of the String type and some type-bound procedures for manipulating a\ntimestamp: program main use io_fortran_lib , only : String , join , split , LF , operator ( + ), operator ( - ) implicit none ( type , external ) type ( String ) :: time_stamp , new_time_stamp type ( String ), allocatable , dimension (:) :: tokens character ( len = 10 ) :: date , time call date_and_time ( date = date , time = time ) time_stamp = String ( \"Date : \" + date + LF + \"Time : \" + time ) write ( * , \"(a)\" ) \"ORIGINAL TIME STAMP:\" + LF + time_stamp % as_str () + LF tokens = split ( time_stamp , separator = LF ) - \"Date : \" - \"Time : \" + [ \" : Date\" , \" : Time\" ] new_time_stamp = join ( tokens , separator = \" | \" ) write ( * , \"(a)\" ) \"RECONSTRUCTED TIME STAMP:\" + LF + new_time_stamp % as_str () end program main This program produces the following sample output: ORIGINAL TIME STAMP:\nDate : 20230101  \nTime : 143355.897\n\nRECONSTRUCTED TIME STAMP:\n20230101   : Date | 143355.897 : Time","tags":"","loc":"page/Examples/manipulations.html"},{"title":"FizzBuzz – IO-Fortran-Library","text":"Division game The following program demonstrates the use of aprint for printing an array of Strings containing values of the first 100 FizzBuzz numbers: program main use io_fortran_lib , only : String , aprint implicit none ( type , external ) integer , allocatable , dimension (:) :: nums integer :: i nums = [( i , i = 1 , 100 )] call aprint ( FizzBuzz ( nums ) ) contains pure elemental type ( String ) function FizzBuzz ( number ) result ( res ) integer , intent ( in ) :: number if ( mod ( number , 5 ) /= 0 ) then if ( mod ( number , 3 ) /= 0 ) then res = String ( number ) else res = String ( \"fizz\" ) end if else if ( mod ( number , 3 ) /= 0 ) then res = String ( \"buzz\" ) else res = String ( \"fizzbuzz\" ) end if end if end function FizzBuzz end program main","tags":"","loc":"page/Examples/fizzbuzz.html"},{"title":"NGS Human Core Exome Panel – IO-Fortran-Library","text":"Handling genomic data Fortran can serve as a valuable tool for heavy numerical calculations\nin Next Generation Sequencing (NGS) analysis, which may often involve\nreading and writing many large .bed files in succession. The\nIO-Fortran-Library is optimized for both performance and memory\nconsumption when reading and writing large text files, streamlining\nperformance for Fortran bioinformatics applications. To demonstrate the speed of file I/O, the following program reads the\nTwist Human Core Exome target .bed file for hg38 obtained from Twist Bioscience into a cell array and then writes the cell array to a new file in a\nround-trip, comparing the two files for an exact match and providing\nthe total time elapsed: program main use , intrinsic :: iso_fortran_env , only : int64 , real64 , compiler_version use io_fortran_lib , only : String , str , TAB , operator ( + ), operator ( == ) implicit none ( type , external ) type ( String ) :: hg38 , hg38_new type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: t1 , t2 real ( real64 ) :: wall_time , rate call system_clock ( t1 ) call hg38 % read_file ( \"./data/hg38.bed\" , cell_array = cells , column_separator = TAB ) call hg38_new % write_file ( cells , \"./data/hg38_new.bed\" , column_separator = TAB ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , real64 ) / rate write ( * , \"(a,l)\" ) \"New file and original are exact match: \" , hg38_new == hg38 write ( * , \"(a)\" ) \"Wall time: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s \" + & \"using compiler: \"\" + compiler_version() + \"\".\" end program main The file hg38.bed is provided locally in /data and contains 192262 lines of TAB -delimited data. The following sample output is observed on Linux with highest\noptimizations enabled ( -O3 ): ---\nNew file and original are exact match: T\nWall time: 0.048 s using compiler: \"GCC version 11.3.0\".\n---\nNew file and original are exact match:  T\nWall time: 0.062 s using compiler: \"Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2023.0.0 Build 20221201\".\n---\nNew file and original are exact match:  T\nWall time: 0.070 s using compiler: \"Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.8.0 Build 20221119_000000\".\n--- Note With the Intel Fortran compiler ifx / ifort , we may need to\nspecify -heap-arrays 0 to avoid a segmentation fault when reading a\nfile of this size, as noted in compiler-dependent behavior .","tags":"","loc":"page/Examples/exome.html"},{"title":"Benchmarking – IO-Fortran-Library","text":"Big data I/O The IO-Fortran-Library is capable of reading and writing very large\ntext files with efficiency, even those whose data size exceeds the\n2,147,483,647 byte upper limit of the 32-bit signed integer. A program\nis provided in /test/benchmark.f90 for benchmarking the major\ninternal and external text I/O routines of the IO-Fortran-Library: program main use , intrinsic :: iso_fortran_env , only : int64 , rk => real32 , dp => real64 , compiler_version , compiler_options use io_fortran_lib , only : String , cast , str , LF , operator ( + ) implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: t1 , t2 real ( dp ) :: wall_time , rate integer , parameter :: n = 15000 real ( rk ), allocatable , dimension (:,:) :: x , y allocate ( x ( n , n ), cells ( n , n ) ); call random_gauss ( x , 0.0_rk , 1.0_rk ) write ( * , \"(a)\" ) \"Compiler version: \" + compiler_version () write ( * , \"(a)\" ) \"Compiler options: \" + compiler_options () + LF call system_clock ( t1 ) call cast ( x , into = cells , fmt = \"z\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for cast: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Number of string conversions/second: \" + str ( nint ( size ( x ) / wall_time )) + LF call system_clock ( t1 ) call csv % write_file ( cells , file = \"bigx.csv\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for write_file: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Estimated file size: \" + str ( csv % len64 () / 1e9 , fmt = \"f\" , decimals = 6 ) + \" GB\" + LF call system_clock ( t1 ) call csv % read_file ( \"bigx.csv\" , cell_array = cells ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for read_file: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" + LF call csv % empty (); allocate ( y ( n , n ) ) call system_clock ( t1 ) call cast ( cells , into = y , fmt = \"z\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for cast: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Number of string casts/second: \" + str ( nint ( size ( x ) / wall_time )) write ( * , \"(a,l)\" ) \"Data is exact match: \" , all ( x == y ) contains ! random_gauss end program main Here, we populate an n -by- n single-precision array x with samples\nfrom the standard Gaussian distribution and convert each to a\nhexadecimal string to populate a cell array, write the cell array to a\ntext file \"bigx.csv\" , read the file back into the program to\nre-populate the cell array, then finally cast the cell data into y and compare with x to observe an exact match. For n = 15000 , the\ntotal data size is 225e6 and the resulting csv file size is 2.47 GB . With highest optimizations enabled for each compiler on Linux ( -O3 ),\nwe observe the following sample output: ---\nCompiler version: GCC version 11.3.0\nCompiler options: -I build/gfortran_93B6DA15423670F8 -mtune=generic -march=x86-64 -O3 -J build/gfortran_93B6DA15423670F8 -fpre-include=/usr/include/finclude/math-vector-fortran.h\n\nWall time for cast: 7.512 s\nNumber of string conversions/second: 29948728\n\nWall time for write_file: 15.658 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 18.444 s\n\nWall time for cast: 8.443 s\nNumber of string casts/second: 26646553\nData is exact match: T\n---\nCompiler version: Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2023.0.0 Build 20221201\nCompiler options: -Ibuild/ifx_810FD198DC3B0576 -c -O3 -heap-arrays 0 -module build/ifx_810FD198DC3B0576 -o build/ifx_810FD198DC3B0576/IO-Fortran-Library/test_benchmark.f90.o\n\nWall time for cast: 13.283 s\nNumber of string conversions/second: 16937918\n\nWall time for write_file: 15.347 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 22.252 s\n\nWall time for cast: 7.942 s\nNumber of string casts/second: 28329900\nData is exact match:  T\n---\nCompiler version: Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.8.0 Build 20221119_000000\nCompiler options: -Ibuild/ifort_810FD198DC3B0576 -c -O3 -heap-arrays 0 -module build/ifort_810FD198DC3B0576 -o build/ifort_810FD198DC3B0576/IO-Fortran-Library/test_benchmark.f90.o\n\nWall time for cast: 14.117 s\nNumber of string conversions/second: 15937621\n\nWall time for write_file: 13.125 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 23.753 s\n\nWall time for cast: 9.835 s\nNumber of string casts/second: 22875860\nData is exact match:  T\n--- Note With the Intel Fortran compiler ifx / ifort , we must specify -heap-arrays 0 to avoid a segmentation fault when reading a file of\nthis size, as noted in compiler-dependent behavior . For a more extreme example, consider the following program to write\nevery 32-bit integer as a hexadecimal string to a text file int32.txt : program main use , intrinsic :: iso_fortran_env , only : int64 , rk => real32 , dp => real64 , compiler_version , compiler_options use randoms , only : random_gauss use io_fortran_lib , only : String , cast , str , LF , operator ( + ) implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable :: cells (:,:) integer ( int64 ) :: t1 , t2 real ( dp ) :: wall_time , rate integer , parameter :: n = 15000 real ( rk ), allocatable :: x (:,:), y (:,:) allocate ( x ( n , n ), cells ( n , n ) ); call random_gauss ( x , 0e0_rk , 1.0_rk ) write ( * , \"(a)\" ) \"Compiler version: \" + compiler_version () write ( * , \"(a)\" ) \"Compiler options: \" + compiler_options () + LF call system_clock ( t1 ) call cast ( x , into = cells , fmt = \"z\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for cast: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Number of string conversions/second: \" + str ( nint ( size ( x ) / wall_time )) + LF call system_clock ( t1 ) call csv % write_file ( cells , file = \"bigx.csv\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for write_file: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Estimated file size: \" + str ( csv % len64 () / 1e9 , fmt = \"f\" , decimals = 6 ) + \" GB\" + LF call system_clock ( t1 ) call csv % read_file ( \"bigx.csv\" , cell_array = cells ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for read_file: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" + LF call csv % empty (); allocate ( y ( n , n ) ) call system_clock ( t1 ) call cast ( cells , into = y , fmt = \"z\" ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , \"(a)\" ) \"Wall time for cast: \" + str ( wall_time , fmt = \"f\" , decimals = 3 ) + \" s\" write ( * , \"(a)\" ) \"Number of string casts/second: \" + str ( nint ( size ( x ) / wall_time )) write ( * , \"(a,l)\" ) \"Data is exact match: \" , all ( x == y ) end program main On Linux, this should take around five minutes with gfortran , and\nfour minutes with ifx / ifort using highest optimizations, and the\nresulting file size is 46.96 GB .","tags":"","loc":"page/Examples/benchmark.html"}]}