var tipuesearch = {"pages":[{"title":" IO-Fortran-Library ","text":"IO-Fortran-Library API Documentation Purpose Scope How to Use License Contact API Documentation This API documentation was generated by FORD (the Fortran documentation generator). Purpose The purpose of this project is to provide a portable, standard I/O library for Modern Fortran programs supporting the Fortran 2018 standard, with the goal of enabling essential I/O functionality for Fortran programmers on any system and with any modern compiler. Scope The IO Fortran Library is a Fortran module io_fortran_lib which provides high level routines for doing internal and external I/O. In particular, the module provides a handful of generic interfaces and a simple derived type for doing string-based and array-based I/O that are useful for recording program data, reading data into programs, writing formatted logs and output, and for doing advanced string manipulations. For instance, one may read and write data from/to .csv and .dat files, represent numbers as strings inside of a string expression, efficiently write text to a .log file, and dynamically manipulate strings with a String type (including casting between numeric and string data). Note The module is fully self-contained, with no external dependencies, and is written to be portable and compliant to the Fortran 2018 standard such that no special extensions or compiler options should be required. The public interfaces accept all intrinsic numeric types ( integer , real , and complex ) and all standard kinds provided by the intrinsic iso_fortran_env module ( int8 , int16 , int32 , int64 , real32 , real64 , and real128 ). All array-based routines additionally support up to rank 15. How to Use To use io_fortran_lib with your fpm project, add the following lines to your fpm.toml file and use the module in your program units to access the routines: [dependencies] IO-Fortran-Library = { git = \"https://github.com/acbbullock/IO-Fortran-Library\" , branch = \"main\" } See the important user information and reference guide for information about calling the routines , and further see the tutorials for complete example programs. License All source code referenced is distributed under the MIT license and available at Github . Contact For bug fixes or feature requests, feel free to open an issue at the project repository or contact acb.bullock@gmail.com . Developer Info Austin C Bullock","tags":"home","loc":"index.html"},{"title":"String – IO-Fortran-Library ","text":"type, public :: String A growable string type for advanced character handling and text I/O. For a user reference, see String , String methods , and Operators . Note TECHNICAL NOTE: The String type is memory safe. The user will never need to be concerned about\naccessing invalid memory when using the String type. Any operation defined in this documentation for the String type which may involve a String with an unallocated component, or arrays of String s in which\nsome of the elements may have unallocated components, is well-defined. In all such cases, the component is\ntreated as the empty string . Contents Constructor String Finalization Procedures scrub Type-Bound Procedures cast count echo push replace replace_inplace split write(formatted) as_str empty join len len64 read_file trim trim_inplace write_file Constructor public        interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String ) Finalization Procedures final :: scrub private  interface scrub() Methods for the String type. Arguments None Type-Bound Procedures generic, public :: cast => cast_string_to_c128, cast_string_to_c64, cast_string_to_c32, cast_string_to_r128, cast_string_to_r64, cast_string_to_r32, cast_string_to_i64, cast_string_to_i32, cast_string_to_i16, cast_string_to_i8 private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int64), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int32), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int16), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int8), intent(inout) :: into character(len=*), intent(in), optional :: fmt generic, public :: count => count_substring_chars, count_substring_string private  interface count_substring_chars() Methods for the String type. Arguments None private  interface count_substring_string() Methods for the String type. Arguments None generic, public :: echo => echo_string private impure recursive module subroutine echo_string(substring, file_name, append, terminator) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file_name logical, intent(in), optional :: append character(len=*), intent(in), optional :: terminator generic, public :: push => push_chars, push_string private  interface push_chars() Methods for the String type. Arguments None private  interface push_string() Methods for the String type. Arguments None generic, public :: replace => replace_ch_copy, replace_st_copy, replace_chst_copy, replace_stch_copy private  interface replace_ch_copy() Methods for the String type. Arguments None private  interface replace_st_copy() Methods for the String type. Arguments None private  interface replace_chst_copy() Methods for the String type. Arguments None private  interface replace_stch_copy() Methods for the String type. Arguments None generic, public :: replace_inplace => replace_ch_inplace, replace_st_inplace, replace_chst_inplace, replace_stch_inplace private  interface replace_ch_inplace() Methods for the String type. Arguments None private  interface replace_st_inplace() Methods for the String type. Arguments None private  interface replace_chst_inplace() Methods for the String type. Arguments None private  interface replace_stch_inplace() Methods for the String type. Arguments None generic, public :: split => split_string private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, dimension(:) generic, public :: write(formatted) => write_string private  interface write_string() Methods for the String type. Arguments None procedure, public, pass(self) :: as_str interface Methods for the String type. private pure recursive module function as_str(self) result(string_slice) Returns a copy of the string slice component of a scalar String . For a user reference, see as_str . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value character(len=:), allocatable procedure, public, pass(self) :: empty interface Methods for the String type. private pure elemental recursive module subroutine empty(self) Sets the string slice component to the empty string elementally. This procedure is identical in function\nto the assignment self = String() . For a user reference, see empty . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self procedure, public, pass(self) :: join => join_into_self interface Methods for the String type. private pure recursive module subroutine join_into_self(self, tokens, separator) Joins a String vector tokens into self with given separator. Default separator is SPACE. The\nstring slice component will be replaced if already allocated. For a user reference, see join . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self type( String ), intent(in), dimension(:) :: tokens character(len=*), intent(in), optional :: separator procedure, public, pass(self) :: len => length interface Methods for the String type. private pure elemental recursive module function length(self) result(self_len) Returns the length of the string slice component elementally. Unallocated components return -1 . For a user reference, see len . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value integer procedure, public, pass(self) :: len64 => length64 interface Methods for the String type. private pure elemental recursive module function length64(self) result(self_len) Returns the length of the string slice component elementally. Unallocated components return -1 . This\nfunction is identical to len for strings of 2,147,483,647 bytes or smaller. For a user reference, see len . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value integer(kind=int64) procedure, public, pass(self) :: read_file interface Methods for the String type. private impure recursive module subroutine read_file(self, file_name, cell_array, row_separator, column_separator) Reads raw text file contents into self and optionally populates a cell array using the designated row_separator and column_separator whose default values are LF and COMMA respectively. For a user reference, see read_file . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self character(len=*), intent(in) :: file_name type( String ), intent(out), optional, allocatable, dimension(:,:) :: cell_array character(len=*), intent(in), optional :: row_separator character(len=*), intent(in), optional :: column_separator procedure, public, pass(self) :: trim => trim_copy interface Methods for the String type. private pure elemental recursive module function trim_copy(self) result(new) Returns a copy of a String elementally in which each string slice component has been trimmed of any\nleading or trailing whitespace. For a user reference, see trim . Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: self Return Value type( String ) procedure, public, pass(self) :: trim_inplace interface Methods for the String type. private pure elemental recursive module subroutine trim_inplace(self) Removes any leading or trailing whitespace of the string slice component of a String elementally and\nin place. For a user reference, see trim_inplace . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self procedure, public, pass(self) :: write_file interface Methods for the String type. private impure recursive module subroutine write_file(self, cell_array, file_name, row_separator, column_separator, append) Writes the content of a cell array to a text file. The cell array's entire contents are populated into self and then streamed to an external text file using the designated row_separator and column_separator whose default values are LF and COMMA respectively. For a user reference, see write_file . Arguments Type Intent Optional Attributes Name class( String ), intent(inout) :: self type( String ), intent(in), dimension(:,:) :: cell_array character(len=*), intent(in) :: file_name character(len=*), intent(in), optional :: row_separator character(len=*), intent(in), optional :: column_separator logical, intent(in), optional :: append","tags":"","loc":"type/string.html"},{"title":"operator(//) – IO-Fortran-Library","text":"public interface operator(//) Concatenation operator for character and String , lifted from character . Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . Contents Functions string_concatenation string_char_concatenation char_string_concatenation Functions private pure elemental recursive module function string_concatenation(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concatenation(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concatenation(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(SLASHSLASH).html"},{"title":"operator(+) – IO-Fortran-Library","text":"public interface operator(+) Concatenation operator for character and String (as addition). Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . Contents Functions char_concat_plus string_concat_plus string_char_concat_plus char_string_concat_plus Functions private pure elemental recursive module function char_concat_plus(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value character(len=len) private pure elemental recursive module function string_concat_plus(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concat_plus(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concat_plus(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(+).html"},{"title":"operator(-) – IO-Fortran-Library","text":"public interface operator(-) Excision operator for character and String (as subtraction). Mixed type excision of character and String is explicitly defined. For a user reference, see Excision . Contents Functions char_excision string_excision string_char_excision char_string_excision Functions private pure elemental recursive module function char_excision(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function string_excision(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_excision(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_excision(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String )","tags":"","loc":"interface/operator(-).html"},{"title":"operator(**) – IO-Fortran-Library","text":"public interface operator(**) Repetition operator for character and String (as exponentiation). For a user reference, see Repetition . Contents Functions repeat_chars repeat_String Functions private pure elemental recursive module function repeat_chars(char_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char_base integer, intent(in) :: ncopies Return Value character(len=len) private pure elemental recursive module function repeat_String(String_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: String_base integer, intent(in) :: ncopies Return Value type( String )","tags":"","loc":"interface/operator(ASTERISKASTERISK).html"},{"title":"operator(==) – IO-Fortran-Library","text":"public interface operator(==) Equivalence operator for character and String . Mixed type equivalence of character and String is\nexplicitly defined. For a user reference, see Equivalence . Note The equivalence operator == is interchangeable with .eq. . Contents Functions string_equivalence string_char_equivalence char_string_equivalence Functions private pure elemental recursive module function string_equivalence(Stringl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_equivalence(Stringl, charsr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_equivalence(charsl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical","tags":"","loc":"interface/operator(==).html"},{"title":"operator(/=) – IO-Fortran-Library","text":"public interface operator(/=) Non-equivalence operator for character and String . Mixed type non-equivalence of character and String is explicitly defined. For a user reference, see Non-equivalence . Note The non-equivalence operator /= is interchangeable with .ne. . Contents Functions string_nonequivalence string_char_nonequivalence char_string_nonequivalence Functions private pure elemental recursive module function string_nonequivalence(Stringl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_nonequivalence(Stringl, charsr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_nonequivalence(charsl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical","tags":"","loc":"interface/operator(SLASH=).html"},{"title":"String – IO-Fortran-Library","text":"public interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . Contents Functions new_string_from_c128 new_string_from_c64 new_string_from_c32 new_string_from_r128 new_string_from_r64 new_string_from_r32 new_string_from_i64 new_string_from_i32 new_string_from_i16 new_string_from_i8 new_string_from_string new_string_from_char new_string_from_empty Functions private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String )","tags":"","loc":"interface/string.html"},{"title":"str – IO-Fortran-Library","text":"public interface str Function for returning a character representation of a number. For a user reference, see str . Contents Functions str_from_c128 str_from_c64 str_from_c32 str_from_r128 str_from_r64 str_from_r32 str_from_i64 str_from_i32 str_from_i16 str_from_i8 str_from_string str_from_char str_from_empty Functions private pure recursive module function str_from_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_string(x) result(x_str) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_char(x) result(x_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_empty() result(x_str) Arguments None Return Value character(len=:), allocatable","tags":"","loc":"interface/str.html"},{"title":"cast – IO-Fortran-Library","text":"public interface cast Subroutine for casting between numeric and string data. For a user reference, see cast . Contents Subroutines cast_c128_to_string cast_c64_to_string cast_c32_to_string cast_r128_to_string cast_r64_to_string cast_r32_to_string cast_i64_to_string cast_i32_to_string cast_i16_to_string cast_i8_to_string cast_c128_to_char cast_c64_to_char cast_c32_to_char cast_r128_to_char cast_r64_to_char cast_r32_to_char cast_i64_to_char cast_i32_to_char cast_i16_to_char cast_i8_to_char cast_string_to_c128 cast_string_to_c64 cast_string_to_c32 cast_string_to_r128 cast_string_to_r64 cast_string_to_r32 cast_string_to_i64 cast_string_to_i32 cast_string_to_i16 cast_string_to_i8 cast_char_to_c128 cast_char_to_c64 cast_char_to_c32 cast_char_to_r128 cast_char_to_r64 cast_char_to_r32 cast_char_to_i64 cast_char_to_i32 cast_char_to_i16 cast_char_to_i8 Subroutines private pure elemental recursive module subroutine cast_c128_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c64_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c32_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_r128_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r64_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r32_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_i64_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i32_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i16_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i8_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_c128_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c64_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c32_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_r128_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r64_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r32_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_i64_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i32_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i16_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i8_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int64), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int32), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int16), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int8), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int64), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int32), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int16), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int8), intent(inout) :: into character(len=*), intent(in), optional :: fmt","tags":"","loc":"interface/cast.html"},{"title":"join – IO-Fortran-Library","text":"public interface join Function for joining a vector of tokens into a scalar character or String . For a user reference, see join . Contents Functions join_char join_string Functions private pure recursive module function join_char(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: tokens character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable private pure recursive module function join_string(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:) :: tokens character(len=*), intent(in), optional :: separator Return Value type( String )","tags":"","loc":"interface/join.html"},{"title":"split – IO-Fortran-Library","text":"public interface split Function for splitting a scalar character or String into a vector of tokens . For a user reference, see split . Contents Functions split_char split_string Functions private pure recursive module function split_char(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, dimension(:) private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, dimension(:)","tags":"","loc":"interface/split.html"},{"title":"to_file – IO-Fortran-Library","text":"public interface to_file Subroutine for writing an array of uniform numeric data type to an external file. For a user reference, see to_file . Contents Subroutines to_file_1dc128 to_file_1dc64 to_file_1dc32 to_file_2dc128 to_file_2dc64 to_file_2dc32 to_file_3dc128 to_file_3dc64 to_file_3dc32 to_file_4dc128 to_file_4dc64 to_file_4dc32 to_file_5dc128 to_file_5dc64 to_file_5dc32 to_file_6dc128 to_file_6dc64 to_file_6dc32 to_file_7dc128 to_file_7dc64 to_file_7dc32 to_file_8dc128 to_file_8dc64 to_file_8dc32 to_file_9dc128 to_file_9dc64 to_file_9dc32 to_file_10dc128 to_file_10dc64 to_file_10dc32 to_file_11dc128 to_file_11dc64 to_file_11dc32 to_file_12dc128 to_file_12dc64 to_file_12dc32 to_file_13dc128 to_file_13dc64 to_file_13dc32 to_file_14dc128 to_file_14dc64 to_file_14dc32 to_file_15dc128 to_file_15dc64 to_file_15dc32 to_file_1dr128 to_file_1dr64 to_file_1dr32 to_file_2dr128 to_file_2dr64 to_file_2dr32 to_file_3dr128 to_file_3dr64 to_file_3dr32 to_file_4dr128 to_file_4dr64 to_file_4dr32 to_file_5dr128 to_file_5dr64 to_file_5dr32 to_file_6dr128 to_file_6dr64 to_file_6dr32 to_file_7dr128 to_file_7dr64 to_file_7dr32 to_file_8dr128 to_file_8dr64 to_file_8dr32 to_file_9dr128 to_file_9dr64 to_file_9dr32 to_file_10dr128 to_file_10dr64 to_file_10dr32 to_file_11dr128 to_file_11dr64 to_file_11dr32 to_file_12dr128 to_file_12dr64 to_file_12dr32 to_file_13dr128 to_file_13dr64 to_file_13dr32 to_file_14dr128 to_file_14dr64 to_file_14dr32 to_file_15dr128 to_file_15dr64 to_file_15dr32 to_file_1di64 to_file_1di32 to_file_1di16 to_file_1di8 to_file_2di64 to_file_2di32 to_file_2di16 to_file_2di8 to_file_3di64 to_file_3di32 to_file_3di16 to_file_3di8 to_file_4di64 to_file_4di32 to_file_4di16 to_file_4di8 to_file_5di64 to_file_5di32 to_file_5di16 to_file_5di8 to_file_6di64 to_file_6di32 to_file_6di16 to_file_6di8 to_file_7di64 to_file_7di32 to_file_7di16 to_file_7di8 to_file_8di64 to_file_8di32 to_file_8di16 to_file_8di8 to_file_9di64 to_file_9di32 to_file_9di16 to_file_9di8 to_file_10di64 to_file_10di32 to_file_10di16 to_file_10di8 to_file_11di64 to_file_11di32 to_file_11di16 to_file_11di8 to_file_12di64 to_file_12di32 to_file_12di16 to_file_12di8 to_file_13di64 to_file_13di32 to_file_13di16 to_file_13di8 to_file_14di64 to_file_14di32 to_file_14di16 to_file_14di8 to_file_15di64 to_file_15di32 to_file_15di16 to_file_15di8 Subroutines private impure recursive module subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_3dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_3dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1di64(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di32(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di16(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di8(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di64(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di32(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di16(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di8(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_3di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name","tags":"","loc":"interface/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"public interface from_file Subroutine for reading an external file of uniform numeric data type and format into an array. For a user reference, see from_file . Contents Subroutines from_textfile_1dc128 from_binaryfile_1dc128 from_textfile_1dc64 from_binaryfile_1dc64 from_textfile_1dc32 from_binaryfile_1dc32 from_textfile_2dc128 from_binaryfile_2dc128 from_textfile_2dc64 from_binaryfile_2dc64 from_textfile_2dc32 from_binaryfile_2dc32 from_file_3dc128 from_file_3dc64 from_file_3dc32 from_file_4dc128 from_file_4dc64 from_file_4dc32 from_file_5dc128 from_file_5dc64 from_file_5dc32 from_file_6dc128 from_file_6dc64 from_file_6dc32 from_file_7dc128 from_file_7dc64 from_file_7dc32 from_file_8dc128 from_file_8dc64 from_file_8dc32 from_file_9dc128 from_file_9dc64 from_file_9dc32 from_file_10dc128 from_file_10dc64 from_file_10dc32 from_file_11dc128 from_file_11dc64 from_file_11dc32 from_file_12dc128 from_file_12dc64 from_file_12dc32 from_file_13dc128 from_file_13dc64 from_file_13dc32 from_file_14dc128 from_file_14dc64 from_file_14dc32 from_file_15dc128 from_file_15dc64 from_file_15dc32 from_textfile_1dr128 from_binaryfile_1dr128 from_textfile_1dr64 from_binaryfile_1dr64 from_textfile_1dr32 from_binaryfile_1dr32 from_textfile_2dr128 from_binaryfile_2dr128 from_textfile_2dr64 from_binaryfile_2dr64 from_textfile_2dr32 from_binaryfile_2dr32 from_file_3dr128 from_file_3dr64 from_file_3dr32 from_file_4dr128 from_file_4dr64 from_file_4dr32 from_file_5dr128 from_file_5dr64 from_file_5dr32 from_file_6dr128 from_file_6dr64 from_file_6dr32 from_file_7dr128 from_file_7dr64 from_file_7dr32 from_file_8dr128 from_file_8dr64 from_file_8dr32 from_file_9dr128 from_file_9dr64 from_file_9dr32 from_file_10dr128 from_file_10dr64 from_file_10dr32 from_file_11dr128 from_file_11dr64 from_file_11dr32 from_file_12dr128 from_file_12dr64 from_file_12dr32 from_file_13dr128 from_file_13dr64 from_file_13dr32 from_file_14dr128 from_file_14dr64 from_file_14dr32 from_file_15dr128 from_file_15dr64 from_file_15dr32 from_textfile_1di64 from_binaryfile_1di64 from_textfile_1di32 from_binaryfile_1di32 from_textfile_1di16 from_binaryfile_1di16 from_textfile_1di8 from_binaryfile_1di8 from_textfile_2di64 from_binaryfile_2di64 from_textfile_2di32 from_binaryfile_2di32 from_textfile_2di16 from_binaryfile_2di16 from_textfile_2di8 from_binaryfile_2di8 from_file_3di64 from_file_3di32 from_file_3di16 from_file_3di8 from_file_4di64 from_file_4di32 from_file_4di16 from_file_4di8 from_file_5di64 from_file_5di32 from_file_5di16 from_file_5di8 from_file_6di64 from_file_6di32 from_file_6di16 from_file_6di8 from_file_7di64 from_file_7di32 from_file_7di16 from_file_7di8 from_file_8di64 from_file_8di32 from_file_8di16 from_file_8di8 from_file_9di64 from_file_9di32 from_file_9di16 from_file_9di8 from_file_10di64 from_file_10di32 from_file_10di16 from_file_10di8 from_file_11di64 from_file_11di32 from_file_11di16 from_file_11di8 from_file_12di64 from_file_12di32 from_file_12di16 from_file_12di8 from_file_13di64 from_file_13di32 from_file_13di16 from_file_13di8 from_file_14di64 from_file_14di32 from_file_14di16 from_file_14di8 from_file_15di64 from_file_15di32 from_file_15di16 from_file_15di8 Subroutines private impure recursive module subroutine from_textfile_1dc128(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc64(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc32(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc128(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc64(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc32(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr128(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr64(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr32(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr128(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr64(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr32(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di64(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di32(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di16(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di8(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di64(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di32(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di16(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di8(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape","tags":"","loc":"interface/from_file.html"},{"title":"echo – IO-Fortran-Library","text":"public interface echo Subroutine for writing a scalar character or String to an external text file. For a user reference, see echo . Contents Subroutines echo_chars echo_string Subroutines private impure recursive module subroutine echo_chars(substring, file_name, append, terminator) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in) :: file_name logical, intent(in), optional :: append character(len=*), intent(in), optional :: terminator private impure recursive module subroutine echo_string(substring, file_name, append, terminator) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file_name logical, intent(in), optional :: append character(len=*), intent(in), optional :: terminator","tags":"","loc":"interface/echo.html"},{"title":"aprint – IO-Fortran-Library","text":"public interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . Contents Subroutines aprint_1dc128 aprint_1dc64 aprint_1dc32 aprint_2dc128 aprint_2dc64 aprint_2dc32 aprint_1dr128 aprint_1dr64 aprint_1dr32 aprint_2dr128 aprint_2dr64 aprint_2dr32 aprint_1di64 aprint_1di32 aprint_1di16 aprint_1di8 aprint_2di64 aprint_2di32 aprint_2di16 aprint_2di8 aprint_1dchar aprint_2dchar aprint_1dString aprint_2dString Subroutines private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:,:) :: x private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in), dimension(:,:) :: x","tags":"","loc":"interface/aprint.html"},{"title":"io_fortran_lib – IO-Fortran-Library","text":"This module provides common I/O routines for data of integer , real , complex , and character type, and\na derived type String for advanced character handling and text file I/O. This module is F2018 compliant, has\nno external dependencies, and has a max line length of 120. Uses iso_c_binding iso_fortran_env Used by Descendants: array_printing binary_io file_io internal_io join_split operators string_methods text_io Contents Variables NL SPACE CR FF VT LF TAB HT BELL NUL CNUL EMPTY_STR Interfaces operator(//) operator(+) operator(-) operator(**) operator(==) operator(/=) String str cast join split to_file from_file echo aprint Derived Types String Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: NL = new_line('a') The newline character (system agnostic). character(len=1), public, parameter :: SPACE = achar(32) The space character. character(len=1), public, parameter :: CR = achar(13) The carriage return character. character(len=1), public, parameter :: FF = achar(12) The form feed character. character(len=1), public, parameter :: VT = achar(11) The vertical tab character. character(len=1), public, parameter :: LF = achar(10) The line feed character. character(len=1), public, parameter :: TAB = achar(9) The horizontal tab character. character(len=1), public, parameter :: HT = achar(9) The horizontal tab character (alternate name). character(len=1), public, parameter :: BELL = achar(7) The bell/alert character. character(len=1), public, parameter :: NUL = achar(0) The null character. character(len=1), public, parameter :: CNUL = c_null_char The C null character re-exported from iso_c_binding. character(len=0), public, parameter :: EMPTY_STR = '' The empty string. Interfaces public        interface operator(//) Concatenation operator for character and String , lifted from character . Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . private pure elemental recursive module function string_concatenation(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concatenation(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concatenation(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(+) Concatenation operator for character and String (as addition). Mixed type concatenation of character and String is explicitly defined. For a user reference, see Concatenation . private pure elemental recursive module function char_concat_plus(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value character(len=len) private pure elemental recursive module function string_concat_plus(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_concat_plus(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_concat_plus(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(-) Excision operator for character and String (as subtraction). Mixed type excision of character and String is explicitly defined. For a user reference, see Excision . private pure elemental recursive module function char_excision(charsl, charsr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function string_excision(Stringl, Stringr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value type( String ) private pure elemental recursive module function string_char_excision(Stringl, charsr) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value type( String ) private pure elemental recursive module function char_string_excision(charsl, Stringr) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value type( String ) public        interface operator(**) Repetition operator for character and String (as exponentiation). For a user reference, see Repetition . private pure elemental recursive module function repeat_chars(char_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: char_base integer, intent(in) :: ncopies Return Value character(len=len) private pure elemental recursive module function repeat_String(String_base, ncopies) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: String_base integer, intent(in) :: ncopies Return Value type( String ) public        interface operator(==) Equivalence operator for character and String . Mixed type equivalence of character and String is\nexplicitly defined. For a user reference, see Equivalence . Note The equivalence operator == is interchangeable with .eq. . private pure elemental recursive module function string_equivalence(Stringl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_equivalence(Stringl, charsr) result(equal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_equivalence(charsl, Stringr) result(equal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical public        interface operator(/=) Non-equivalence operator for character and String . Mixed type non-equivalence of character and String is explicitly defined. For a user reference, see Non-equivalence . Note The non-equivalence operator /= is interchangeable with .ne. . private pure elemental recursive module function string_nonequivalence(Stringl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl class( String ), intent(in) :: Stringr Return Value logical private pure elemental recursive module function string_char_nonequivalence(Stringl, charsr) result(unequal) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: Stringl character(len=*), intent(in) :: charsr Return Value logical private pure elemental recursive module function char_string_nonequivalence(charsl, Stringr) result(unequal) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: charsl class( String ), intent(in) :: Stringr Return Value logical public        interface String Function for returning a String representation of numbers. For a user reference, see String , String methods , and Operators . private pure elemental recursive module function new_string_from_c128(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c64(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_c32(x, locale, fmt, decimals, im) result(new) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value type( String ) private pure elemental recursive module function new_string_from_r128(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r64(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_r32(x, locale, fmt, decimals) result(new) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value type( String ) private pure elemental recursive module function new_string_from_i64(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i32(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i16(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_i8(x, fmt) result(new) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value type( String ) private pure elemental recursive module function new_string_from_string(x) result(new) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_char(x) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value type( String ) private pure elemental recursive module function new_string_from_empty() result(new) Arguments None Return Value type( String ) public        interface str Function for returning a character representation of a number. For a user reference, see str . private pure recursive module function str_from_c128(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c64(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_c32(x, locale, fmt, decimals, im) result(x_str) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im Return Value character(len=:), allocatable private pure recursive module function str_from_r128(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r64(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_r32(x, locale, fmt, decimals) result(x_str) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals Return Value character(len=:), allocatable private pure recursive module function str_from_i64(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i32(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i16(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_i8(x, fmt) result(x_str) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=*), intent(in), optional :: fmt Return Value character(len=:), allocatable private pure recursive module function str_from_string(x) result(x_str) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_char(x) result(x_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x Return Value character(len=:), allocatable private pure recursive module function str_from_empty() result(x_str) Arguments None Return Value character(len=:), allocatable public        interface cast Subroutine for casting between numeric and string data. For a user reference, see cast . private pure elemental recursive module subroutine cast_c128_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c64_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_c32_to_string(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_r128_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r64_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_r32_to_string(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure elemental recursive module subroutine cast_i64_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i32_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i16_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_i8_to_string(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x type( String ), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_c128_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c64_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_c32_to_char(x, into, locale, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_r128_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r64_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_r32_to_char(x, into, locale, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private pure recursive module subroutine cast_i64_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i32_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i16_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_i8_to_char(x, into, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: x character(len=:), intent(inout), allocatable :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring complex(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure elemental recursive module subroutine cast_string_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring real(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int64), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int32), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int16), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure elemental recursive module subroutine cast_string_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring integer(kind=int8), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_c128(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c64(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_c32(substring, into, locale, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring complex(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private pure recursive module subroutine cast_char_to_r128(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real128), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r64(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real64), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_r32(substring, into, locale, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring real(kind=real32), intent(inout) :: into character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i64(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int64), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i32(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int32), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i16(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int16), intent(inout) :: into character(len=*), intent(in), optional :: fmt private pure recursive module subroutine cast_char_to_i8(substring, into, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring integer(kind=int8), intent(inout) :: into character(len=*), intent(in), optional :: fmt public        interface join Function for joining a vector of tokens into a scalar character or String . For a user reference, see join . private pure recursive module function join_char(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: tokens character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable private pure recursive module function join_string(tokens, separator) result(new) Arguments Type Intent Optional Attributes Name type( String ), intent(in), dimension(:) :: tokens character(len=*), intent(in), optional :: separator Return Value type( String ) public        interface split Function for splitting a scalar character or String into a vector of tokens . For a user reference, see split . private pure recursive module function split_char(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, dimension(:) private pure recursive module function split_string(substring, separator) result(tokens) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in), optional :: separator Return Value type( String ), allocatable, dimension(:) public        interface to_file Subroutine for writing an array of uniform numeric data type to an external file. For a user reference, see to_file . private impure recursive module subroutine to_file_1dc128(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc64(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_1dc32(x, file_name, header, dim, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc128(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc64(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_2dc32(x, file_name, header, locale, delim, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine to_file_3dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc128(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc64(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dc32(x, file_name) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1dr128(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr64(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_1dr32(x, file_name, header, dim, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr128(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr64(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_2dr32(x, file_name, header, locale, delim, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine to_file_3dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr128(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr64(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15dr32(x, file_name) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_1di64(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di32(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di16(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_1di8(x, file_name, header, dim, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header integer, intent(in), optional :: dim character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di64(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di32(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di16(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_2di8(x, file_name, header, delim, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in) :: file_name character(len=*), intent(in), optional, dimension(:) :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine to_file_3di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_3di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_4di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_5di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_6di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_7di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_8di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_9di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_10di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_11di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_12di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_13di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_14di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di64(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di32(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di16(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name private impure recursive module subroutine to_file_15di8(x, file_name) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: x character(len=*), intent(in) :: file_name public        interface from_file Subroutine for reading an external file of uniform numeric data type and format into an array. For a user reference, see from_file . private impure recursive module subroutine from_textfile_1dc128(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc64(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dc32(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_1dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc128(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc64(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dc32(file_name, into, header, locale, delim, fmt, im) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt character(len=*), intent(in), optional :: im private impure recursive module subroutine from_binaryfile_2dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dc32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name complex(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr128(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr64(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1dr32(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr128(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr64(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2dr32(file_name, into, header, locale, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: locale character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr128(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real128), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15dr32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name real(kind=real32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di64(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di32(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di16(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_1di8(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_1di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di64(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di32(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di16(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_textfile_2di8(file_name, into, header, delim, fmt) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into logical, intent(in), optional :: header character(len=*), intent(in), optional :: delim character(len=*), intent(in), optional :: fmt private impure recursive module subroutine from_binaryfile_2di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_3di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_4di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_5di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_6di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_7di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_8di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_9di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_10di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_11di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_12di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_13di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_14di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di64(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int64), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di32(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int32), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di16(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int16), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape private impure recursive module subroutine from_file_15di8(file_name, into, data_shape) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: file_name integer(kind=int8), intent(out), allocatable, dimension(:,:,:,:,:,:,:,:,:,:,:,:,:,:,:) :: into integer, intent(in), dimension(:) :: data_shape public        interface echo Subroutine for writing a scalar character or String to an external text file. For a user reference, see echo . private impure recursive module subroutine echo_chars(substring, file_name, append, terminator) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: substring character(len=*), intent(in) :: file_name logical, intent(in), optional :: append character(len=*), intent(in), optional :: terminator private impure recursive module subroutine echo_string(substring, file_name, append, terminator) Arguments Type Intent Optional Attributes Name class( String ), intent(in) :: substring character(len=*), intent(in) :: file_name logical, intent(in), optional :: append character(len=*), intent(in), optional :: terminator public        interface aprint Subroutine for printing arrays and array sections to stdout. For a user reference, see aprint . private impure recursive module subroutine aprint_1dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc128(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc64(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_2dc32(x, fmt, decimals, im) Arguments Type Intent Optional Attributes Name complex(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals character(len=*), intent(in), optional :: im private impure recursive module subroutine aprint_1dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr128(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real128), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr64(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_2dr32(x, fmt, decimals) Arguments Type Intent Optional Attributes Name real(kind=real32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt integer, intent(in), optional :: decimals private impure recursive module subroutine aprint_1di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di64(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di32(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di16(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_2di8(x, fmt) Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in), dimension(:,:) :: x character(len=*), intent(in), optional :: fmt private impure recursive module subroutine aprint_1dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dchar(x) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), dimension(:,:) :: x private impure recursive module subroutine aprint_1dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in), dimension(:) :: x private impure recursive module subroutine aprint_2dString(x) Arguments Type Intent Optional Attributes Name class( String ), intent(in), dimension(:,:) :: x Derived Types type, public :: String A growable string type for advanced character handling and text I/O. Read more… Constructor Function for returning a String representation of numbers. Read more… private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c128 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c64 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_c32 (x, locale, fmt, decimals, im) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r128 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r64 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_r32 (x, locale, fmt, decimals) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i64 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i32 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i16 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_i8 (x, fmt) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_string (x) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_char (x) private\n\n                    pure, elemental, recursive, module\n                    function new_string_from_empty () Finalizations Procedures final :: scrub Type-Bound Procedures generic,\n                  public\n                  :: cast =>\n                    cast_string_to_c128, cast_string_to_c64, cast_string_to_c32, cast_string_to_r128, cast_string_to_r64, cast_string_to_r32, cast_string_to_i64, cast_string_to_i32, cast_string_to_i16, cast_string_to_i8 generic,\n                  public\n                  :: count =>\n                    count_substring_chars, count_substring_string generic,\n                  public\n                  :: echo =>\n                    echo_string generic,\n                  public\n                  :: push =>\n                    push_chars, push_string generic,\n                  public\n                  :: replace =>\n                    replace_ch_copy, replace_st_copy, replace_chst_copy, replace_stch_copy generic,\n                  public\n                  :: replace_inplace =>\n                    replace_ch_inplace, replace_st_inplace, replace_chst_inplace, replace_stch_inplace generic,\n                  public\n                  :: split =>\n                    split_string generic,\n                  public\n                  :: write(formatted) =>\n                    write_string procedure\n                    ,                  public\n, pass(self)                  :: as_str Interface procedure\n                    ,                  public\n, pass(self)                  :: empty Interface procedure\n                    ,                  public\n, pass(self)                  :: join =>\n                    join_into_self Interface procedure\n                    ,                  public\n, pass(self)                  :: len =>\n                    length Interface procedure\n                    ,                  public\n, pass(self)                  :: len64 =>\n                    length64 Interface procedure\n                    ,                  public\n, pass(self)                  :: read_file Interface procedure\n                    ,                  public\n, pass(self)                  :: trim =>\n                    trim_copy Interface procedure\n                    ,                  public\n, pass(self)                  :: trim_inplace Interface procedure\n                    ,                  public\n, pass(self)                  :: write_file Interface","tags":"","loc":"module/io_fortran_lib.html"},{"title":"string_methods – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the type-bound procedures of type String . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/string_methods.html"},{"title":"operators – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces operator(//) , operator(+) , operator(-) , operator(**) , operator(==) , and operator(/=) . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/operators.html"},{"title":"internal_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces String , str , and cast . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/internal_io.html"},{"title":"join_split – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces join and split . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/join_split.html"},{"title":"file_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interfaces to_file and from_file . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/file_io.html"},{"title":"text_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface echo and the private\ninterfaces to_text and from_text . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/text_io.html"},{"title":"binary_io – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the private interfaces to_binary and from_binary . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/binary_io.html"},{"title":"array_printing – IO-Fortran-Library","text":"This submodule provides module procedure implementations for the public interface aprint . Uses Ancestors: io_fortran_lib Contents None","tags":"","loc":"module/array_printing.html"},{"title":"io_fortran_lib.f90 – IO-Fortran-Library","text":"Contents Modules io_fortran_lib Submodules string_methods operators internal_io join_split file_io text_io binary_io array_printing Source Code io_fortran_lib.f90 Source Code module io_fortran_lib !------------------------------------------------------------------------------------------------------------------ !! This module provides common I/O routines for data of `integer`, `real`, `complex`, and `character` type, and !! a derived type `String` for advanced character handling and text file I/O. This module is F2018 compliant, has !! no external dependencies, and has a max line length of 120. !------------------------------------------------------------------------------------------------------------------ use , intrinsic :: iso_fortran_env , only : real128 , real64 , real32 , int64 , int32 , int16 , int8 , & ! Standard kinds input_unit , output_unit , compiler_version use , intrinsic :: iso_c_binding , only : c_null_char ! The C null character implicit none ( type , external ) ! No implicit types or interfaces private ! Public API list ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ public :: aprint , to_file , from_file ! Array I/O public :: String , str , cast , join , split , echo ! String I/O public :: NL , SPACE , CR , FF , VT , LF , TAB , HT , BELL , NUL , CNUL , EMPTY_STR ! Constants public :: operator ( // ), operator ( + ), operator ( - ), operator ( ** ), operator ( == ), operator ( /= ) ! Operators ! Definitions and Interfaces ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !! The newline character (system agnostic). character ( len = 1 ), parameter :: SPACE = achar ( 32 ) !! The space character. character ( len = 1 ), parameter :: CR = achar ( 13 ) !! The carriage return character. character ( len = 1 ), parameter :: FF = achar ( 12 ) !! The form feed character. character ( len = 1 ), parameter :: VT = achar ( 11 ) !! The vertical tab character. character ( len = 1 ), parameter :: LF = achar ( 10 ) !! The line feed character. character ( len = 1 ), parameter :: TAB = achar ( 9 ) !! The horizontal tab character. character ( len = 1 ), parameter :: HT = achar ( 9 ) !! The horizontal tab character (alternate name). character ( len = 1 ), parameter :: BELL = achar ( 7 ) !! The bell/alert character. character ( len = 1 ), parameter :: NUL = achar ( 0 ) !! The null character. character ( len = 1 ), parameter :: CNUL = c_null_char !! The C null character re-exported from iso_c_binding. character ( len = 0 ), parameter :: EMPTY_STR = '' !! The empty string. character ( len =* ), parameter :: COMPILER = compiler_version () character ( len = 1 ), parameter :: SEMICOLON = achar ( 59 ) ! Semicolon character ( len = 1 ), parameter :: POINT = achar ( 46 ) ! Full stop character ( len = 1 ), parameter :: COMMA = achar ( 44 ) ! Comma character ( len = 1 ), parameter :: QQUOTE = achar ( 34 ) ! Double quote character ( len = 1 ), dimension ( * ), parameter :: INT_FMTS = [ 'i' , 'z' ] ! Allowed formats for integers character ( len = 1 ), dimension ( * ), parameter :: REAL_FMTS = [ 'e' , 'f' , 'z' ] ! Allowed formats for floats character ( len = 2 ), dimension ( * ), parameter :: LOCALES = [ 'US' , 'EU' ] ! Allowed locale specifiers character ( len = 3 ), dimension ( * ), parameter :: BINARY_EXT = [ 'dat' , 'bin' ] ! Allowed binary extensions character ( len = 3 ), dimension ( * ), parameter :: TEXT_EXT = [ 'csv' , 'txt' , 'log' , & ! Allowed text extensions 'rtf' , 'odm' , 'odt' , & 'ods' , 'odf' , 'xls' , & 'doc' , 'org' , 'dbf' , & 'bed' , 'gff' , 'gtf' ] type String !-------------------------------------------------------------------------------------------------------------- !! A growable string type for advanced character handling and text I/O. !! !! For a user reference, see [String](../page/Ref/String.html), !! [String methods](../page/Ref/String-methods.html), and [Operators](../page/Ref/operators.html). !! !! @note TECHNICAL NOTE: The `String` type is memory safe. The user will never need to be concerned about !! accessing invalid memory when using the `String` type. Any operation defined in this documentation for the !! `String` type which may involve a `String` with an unallocated component, or arrays of `String`s in which !! some of the elements may have unallocated components, is well-defined. In all such cases, the component is !! treated as the [empty string](../module/io_fortran_lib.html#variable-empty_str). !-------------------------------------------------------------------------------------------------------------- private character ( len = :), allocatable :: s !! Component is a string slice contains private ! Generics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ generic , public :: cast => cast_string_to_c128 , cast_string_to_c64 , cast_string_to_c32 , & cast_string_to_r128 , cast_string_to_r64 , cast_string_to_r32 , & cast_string_to_i64 , cast_string_to_i32 , cast_string_to_i16 , & cast_string_to_i8 generic , public :: count => count_substring_chars , count_substring_string generic , public :: echo => echo_string generic , public :: push => push_chars , push_string generic , public :: replace => replace_ch_copy , replace_st_copy , replace_chst_copy , & replace_stch_copy generic , public :: replace_inplace => replace_ch_inplace , replace_st_inplace , replace_chst_inplace , & replace_stch_inplace generic , public :: split => split_string generic , public :: write ( formatted ) => write_string ! Specifics ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ procedure , pass ( self ), public :: as_str procedure , pass ( substring ) :: cast_string_to_c128 , cast_string_to_c64 , cast_string_to_c32 , & cast_string_to_r128 , cast_string_to_r64 , cast_string_to_r32 , & cast_string_to_i64 , cast_string_to_i32 , cast_string_to_i16 , & cast_string_to_i8 procedure , pass ( self ) :: count_substring_chars , count_substring_string procedure , pass ( substring ) :: echo_string procedure , pass ( self ), public :: empty procedure , pass ( self ), public :: join => join_into_self procedure , pass ( self ) :: join_base procedure , pass ( self ), public :: len => length procedure , pass ( self ), public :: len64 => length64 procedure , pass ( self ) :: push_chars , push_string procedure , pass ( self ), public :: read_file procedure , pass ( self ) :: replace_ch_copy , replace_st_copy , replace_chst_copy , & replace_stch_copy , replace_ch_inplace , replace_st_inplace , & replace_chst_inplace , replace_stch_inplace procedure , pass ( substring ) :: split_string procedure , pass ( self ), public :: trim => trim_copy procedure , pass ( self ), public :: trim_inplace procedure , pass ( self ), public :: write_file procedure , pass ( substring ) :: write_string final :: scrub end type String interface ! Submodule string_methods !-------------------------------------------------------------------------------------------------------------- !! Methods for the `String` type. !-------------------------------------------------------------------------------------------------------------- pure recursive module function as_str ( self ) result ( string_slice ) !---------------------------------------------------------------------------------------------------------- !! Returns a copy of the string slice component of a scalar `String`. !! !! For a user reference, see [as_str](../page/Ref/String-methods.html#as_str). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len = :), allocatable :: string_slice end function as_str pure elemental recursive integer module function count_substring_chars ( self , match ) result ( occurrences ) !---------------------------------------------------------------------------------------------------------- !! Returns number of non-overlapping occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match end function count_substring_chars pure elemental recursive integer module function count_substring_string ( self , match ) result ( occurrences ) !---------------------------------------------------------------------------------------------------------- !! Returns number of non-overlapping occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match end function count_substring_string pure elemental recursive module subroutine empty ( self ) !---------------------------------------------------------------------------------------------------------- !! Sets the string slice component to the empty string elementally. This procedure is identical in function !! to the assignment `self = String()`. !! !! For a user reference, see [empty](../page/Ref/String-methods.html#empty). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self end subroutine empty pure recursive module subroutine join_into_self ( self , tokens , separator ) !---------------------------------------------------------------------------------------------------------- !! Joins a `String` vector `tokens` into `self` with given separator. Default separator is SPACE. The !! string slice component will be replaced if already allocated. !! !! For a user reference, see [join](../page/Ref/String-methods.html#join). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), dimension (:), intent ( in ) :: tokens character ( len =* ), intent ( in ), optional :: separator end subroutine join_into_self pure recursive module subroutine join_base ( self , tokens , separator ) !---------------------------------------------------------------------------------------------------------- !! Tail recursion routine for `join_string` and `join_into_self`. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), dimension (:), intent ( in ) :: tokens character ( len =* ), intent ( in ) :: separator end subroutine join_base pure elemental recursive integer module function length ( self ) result ( self_len ) !---------------------------------------------------------------------------------------------------------- !! Returns the length of the string slice component elementally. Unallocated components return `-1`. !! !! For a user reference, see [len](../page/Ref/String-methods.html#len). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function length pure elemental recursive integer ( int64 ) module function length64 ( self ) result ( self_len ) !---------------------------------------------------------------------------------------------------------- !! Returns the length of the string slice component elementally. Unallocated components return `-1`. This !! function is identical to `len` for strings of 2,147,483,647 bytes or smaller. !! !! For a user reference, see [len](../page/Ref/String-methods.html#len). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function length64 pure elemental recursive module subroutine push_chars ( self , substring ) !---------------------------------------------------------------------------------------------------------- !! Appends characters to the string slice component elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: substring end subroutine push_chars pure elemental recursive module subroutine push_string ( self , substring ) !---------------------------------------------------------------------------------------------------------- !! Appends string to the string slice component elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: substring end subroutine push_string impure recursive module subroutine read_file ( self , file_name , cell_array , row_separator , column_separator ) !---------------------------------------------------------------------------------------------------------- !! Reads raw text file contents into `self` and optionally populates a cell array using the designated !! `row_separator` and `column_separator` whose default values are `LF` and `COMMA` respectively. !! !! For a user reference, see [read_file](../page/Ref/String-methods.html#read_file). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: file_name type ( String ), allocatable , dimension (:,:), intent ( out ), optional :: cell_array character ( len =* ), intent ( in ), optional :: row_separator , column_separator end subroutine read_file pure elemental recursive type ( String ) module function replace_ch_copy ( self , match , substring , back ) result ( new ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end function replace_ch_copy pure elemental recursive type ( String ) module function replace_st_copy ( self , match , substring , back ) result ( new ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end function replace_st_copy pure elemental recursive type ( String ) module function replace_chst_copy ( self , match , substring , back ) result ( new ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self character ( len =* ), intent ( in ) :: match type ( String ), intent ( in ) :: substring logical , intent ( in ), optional :: back end function replace_chst_copy pure elemental recursive type ( String ) module function replace_stch_copy ( self , match , substring , back ) result ( new ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self type ( String ), intent ( in ) :: match character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back end function replace_stch_copy pure elemental recursive module subroutine replace_ch_inplace ( self , match , substring , back ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end subroutine replace_ch_inplace pure elemental recursive module subroutine replace_st_inplace ( self , match , substring , back ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: match , substring logical , intent ( in ), optional :: back end subroutine replace_st_inplace pure elemental recursive module subroutine replace_chst_inplace ( self , match , substring , back ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self character ( len =* ), intent ( in ) :: match type ( String ), intent ( in ) :: substring logical , intent ( in ), optional :: back end subroutine replace_chst_inplace pure elemental recursive module subroutine replace_stch_inplace ( self , match , substring , back ) !---------------------------------------------------------------------------------------------------------- !! Matches and replaces all occurrences of a substring elementally in place. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), intent ( in ) :: match character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back end subroutine replace_stch_inplace pure elemental recursive type ( String ) module function trim_copy ( self ) result ( new ) !---------------------------------------------------------------------------------------------------------- !! Returns a copy of a `String` elementally in which each string slice component has been trimmed of any !! leading or trailing whitespace. !! !! For a user reference, see [trim](../page/Ref/String-methods.html#trim). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: self end function trim_copy pure elemental recursive module subroutine trim_inplace ( self ) !---------------------------------------------------------------------------------------------------------- !! Removes any leading or trailing whitespace of the string slice component of a `String` elementally and !! in place. !! !! For a user reference, see [trim_inplace](../page/Ref/String-methods.html#trim_inplace). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self end subroutine trim_inplace impure recursive module subroutine write_file ( self , cell_array , file_name , row_separator , column_separator , append ) !---------------------------------------------------------------------------------------------------------- !! Writes the content of a cell array to a text file. The cell array's entire contents are populated into !! `self` and then streamed to an external text file using the designated `row_separator` and !! `column_separator` whose default values are `LF` and `COMMA` respectively. !! !! For a user reference, see [write_file](../page/Ref/String-methods.html#write_file). !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( inout ) :: self type ( String ), dimension (:,:), intent ( in ) :: cell_array character ( len =* ), intent ( in ) :: file_name character ( len =* ), intent ( in ), optional :: row_separator , column_separator logical , intent ( in ), optional :: append end subroutine write_file impure recursive module subroutine write_string ( substring , unit , iotype , v_list , iostat , iomsg ) !---------------------------------------------------------------------------------------------------------- !! Formatted write DTIO procedure for type `String`. !---------------------------------------------------------------------------------------------------------- class ( String ), intent ( in ) :: substring integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , dimension (:), intent ( in ) :: v_list integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg end subroutine write_string pure elemental recursive module subroutine scrub ( self ) !---------------------------------------------------------------------------------------------------------- !! Finalization procedure for type `String`. !---------------------------------------------------------------------------------------------------------- type ( String ), intent ( inout ) :: self end subroutine scrub end interface interface operator ( // ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Concatenation operator for `character` and `String`, lifted from `character`. Mixed type concatenation of !! `character` and `String` is explicitly defined. !! !! For a user reference, see [Concatenation](../page/Ref/operators.html#concatenation). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function string_concatenation ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_concatenation pure elemental recursive type ( String ) module function string_char_concatenation ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_concatenation pure elemental recursive type ( String ) module function char_string_concatenation ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_concatenation end interface interface operator ( + ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Concatenation operator for `character` and `String` (as addition). Mixed type concatenation of !! `character` and `String` is explicitly defined. !! !! For a user reference, see [Concatenation](../page/Ref/operators.html#concatenation). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive module function char_concat_plus ( charsl , charsr ) result ( new ) character ( len =* ), intent ( in ) :: charsl , charsr character ( len = len ( charsl ) + len ( charsr )) :: new end function char_concat_plus pure elemental recursive type ( String ) module function string_concat_plus ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_concat_plus pure elemental recursive type ( String ) module function string_char_concat_plus ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_concat_plus pure elemental recursive type ( String ) module function char_string_concat_plus ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_concat_plus end interface interface operator ( - ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Excision operator for `character` and `String` (as subtraction). Mixed type excision of `character` and !! `String` is explicitly defined. !! !! For a user reference, see [Excision](../page/Ref/operators.html#excision). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function char_excision ( charsl , charsr ) result ( new ) character ( len =* ), intent ( in ) :: charsl , charsr end function char_excision pure elemental recursive type ( String ) module function string_excision ( Stringl , Stringr ) result ( new ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_excision pure elemental recursive type ( String ) module function string_char_excision ( Stringl , charsr ) result ( new ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_excision pure elemental recursive type ( String ) module function char_string_excision ( charsl , Stringr ) result ( new ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_excision end interface interface operator ( ** ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Repetition operator for `character` and `String` (as exponentiation). !! !! For a user reference, see [Repetition](../page/Ref/operators.html#repetition). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive module function repeat_chars ( char_base , ncopies ) result ( new ) character ( len =* ), intent ( in ) :: char_base integer , intent ( in ) :: ncopies character ( len = len ( char_base ) * ncopies ) :: new end function repeat_chars pure elemental recursive type ( String ) module function repeat_String ( String_base , ncopies ) result ( new ) class ( String ), intent ( in ) :: String_base integer , intent ( in ) :: ncopies end function repeat_String end interface interface operator ( == ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Equivalence operator for `character` and `String`. Mixed type equivalence of `character` and `String` is !! explicitly defined. !! !! For a user reference, see [Equivalence](../page/Ref/operators.html#equivalence). !! !! @note The equivalence operator `==` is interchangeable with `.eq.`. !-------------------------------------------------------------------------------------------------------------- pure elemental recursive logical module function string_equivalence ( Stringl , Stringr ) result ( equal ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_equivalence pure elemental recursive logical module function string_char_equivalence ( Stringl , charsr ) result ( equal ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_equivalence pure elemental recursive logical module function char_string_equivalence ( charsl , Stringr ) result ( equal ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_equivalence end interface interface operator ( /= ) ! Submodule operators !-------------------------------------------------------------------------------------------------------------- !! Non-equivalence operator for `character` and `String`. Mixed type non-equivalence of `character` and !! `String` is explicitly defined. !! !! For a user reference, see [Non-equivalence](../page/Ref/operators.html#non-equivalence). !! !! @note The non-equivalence operator `/=` is interchangeable with `.ne.`. !-------------------------------------------------------------------------------------------------------------- pure elemental recursive logical module function string_nonequivalence ( Stringl , Stringr ) result ( unequal ) class ( String ), intent ( in ) :: Stringl , Stringr end function string_nonequivalence pure elemental recursive logical module function string_char_nonequivalence ( Stringl , charsr ) result ( unequal ) class ( String ), intent ( in ) :: Stringl character ( len =* ), intent ( in ) :: charsr end function string_char_nonequivalence pure elemental recursive logical module function char_string_nonequivalence ( charsl , Stringr ) result ( unequal ) character ( len =* ), intent ( in ) :: charsl class ( String ), intent ( in ) :: Stringr end function char_string_nonequivalence end interface interface String ! Submodule internal_io !-------------------------------------------------------------------------------------------------------------- !! Function for returning a [String](../type/string.html) representation of numbers. !! !! For a user reference, see [String](../page/Ref/String.html), !! [String methods](../page/Ref/String-methods.html), and [Operators](../page/Ref/operators.html). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive type ( String ) module function new_string_from_c128 ( x , locale , fmt , decimals , im ) result ( new ) complex ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c128 pure elemental recursive type ( String ) module function new_string_from_c64 ( x , locale , fmt , decimals , im ) result ( new ) complex ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c64 pure elemental recursive type ( String ) module function new_string_from_c32 ( x , locale , fmt , decimals , im ) result ( new ) complex ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end function new_string_from_c32 pure elemental recursive type ( String ) module function new_string_from_r128 ( x , locale , fmt , decimals ) result ( new ) real ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r128 pure elemental recursive type ( String ) module function new_string_from_r64 ( x , locale , fmt , decimals ) result ( new ) real ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r64 pure elemental recursive type ( String ) module function new_string_from_r32 ( x , locale , fmt , decimals ) result ( new ) real ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end function new_string_from_r32 pure elemental recursive type ( String ) module function new_string_from_i64 ( x , fmt ) result ( new ) integer ( int64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i64 pure elemental recursive type ( String ) module function new_string_from_i32 ( x , fmt ) result ( new ) integer ( int32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i32 pure elemental recursive type ( String ) module function new_string_from_i16 ( x , fmt ) result ( new ) integer ( int16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i16 pure elemental recursive type ( String ) module function new_string_from_i8 ( x , fmt ) result ( new ) integer ( int8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end function new_string_from_i8 pure elemental recursive type ( String ) module function new_string_from_string ( x ) result ( new ) class ( String ), intent ( in ) :: x end function new_string_from_string pure elemental recursive type ( String ) module function new_string_from_char ( x ) result ( new ) character ( len =* ), intent ( in ) :: x end function new_string_from_char pure elemental recursive type ( String ) module function new_string_from_empty () result ( new ) ! No arguments end function new_string_from_empty end interface interface str ! Submodule internal_io !-------------------------------------------------------------------------------------------------------------- !! Function for returning a `character` representation of a number. !! !! For a user reference, see [str](../page/Ref/str.html). !-------------------------------------------------------------------------------------------------------------- pure recursive module function str_from_c128 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c128 pure recursive module function str_from_c64 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c64 pure recursive module function str_from_c32 ( x , locale , fmt , decimals , im ) result ( x_str ) complex ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im character ( len = :), allocatable :: x_str end function str_from_c32 pure recursive module function str_from_r128 ( x , locale , fmt , decimals ) result ( x_str ) real ( real128 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r128 pure recursive module function str_from_r64 ( x , locale , fmt , decimals ) result ( x_str ) real ( real64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r64 pure recursive module function str_from_r32 ( x , locale , fmt , decimals ) result ( x_str ) real ( real32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len = :), allocatable :: x_str end function str_from_r32 pure recursive module function str_from_i64 ( x , fmt ) result ( x_str ) integer ( int64 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i64 pure recursive module function str_from_i32 ( x , fmt ) result ( x_str ) integer ( int32 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i32 pure recursive module function str_from_i16 ( x , fmt ) result ( x_str ) integer ( int16 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i16 pure recursive module function str_from_i8 ( x , fmt ) result ( x_str ) integer ( int8 ), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt character ( len = :), allocatable :: x_str end function str_from_i8 pure recursive module function str_from_string ( x ) result ( x_str ) class ( String ), intent ( in ) :: x character ( len = :), allocatable :: x_str end function str_from_string pure recursive module function str_from_char ( x ) result ( x_str ) character ( len =* ), intent ( in ) :: x character ( len = :), allocatable :: x_str end function str_from_char pure recursive module function str_from_empty () result ( x_str ) character ( len = :), allocatable :: x_str end function str_from_empty end interface interface cast ! Submodule internal_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for casting between numeric and string data. !! !! For a user reference, see [cast](../page/Ref/cast.html). !-------------------------------------------------------------------------------------------------------------- pure elemental recursive module subroutine cast_c128_to_string ( x , into , locale , fmt , decimals , im ) complex ( real128 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c128_to_string pure elemental recursive module subroutine cast_c64_to_string ( x , into , locale , fmt , decimals , im ) complex ( real64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c64_to_string pure elemental recursive module subroutine cast_c32_to_string ( x , into , locale , fmt , decimals , im ) complex ( real32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c32_to_string pure elemental recursive module subroutine cast_r128_to_string ( x , into , locale , fmt , decimals ) real ( real128 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r128_to_string pure elemental recursive module subroutine cast_r64_to_string ( x , into , locale , fmt , decimals ) real ( real64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r64_to_string pure elemental recursive module subroutine cast_r32_to_string ( x , into , locale , fmt , decimals ) real ( real32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r32_to_string pure elemental recursive module subroutine cast_i64_to_string ( x , into , fmt ) integer ( int64 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i64_to_string pure elemental recursive module subroutine cast_i32_to_string ( x , into , fmt ) integer ( int32 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i32_to_string pure elemental recursive module subroutine cast_i16_to_string ( x , into , fmt ) integer ( int16 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i16_to_string pure elemental recursive module subroutine cast_i8_to_string ( x , into , fmt ) integer ( int8 ), intent ( in ) :: x type ( String ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i8_to_string pure recursive module subroutine cast_c128_to_char ( x , into , locale , fmt , decimals , im ) complex ( real128 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c128_to_char pure recursive module subroutine cast_c64_to_char ( x , into , locale , fmt , decimals , im ) complex ( real64 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c64_to_char pure recursive module subroutine cast_c32_to_char ( x , into , locale , fmt , decimals , im ) complex ( real32 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine cast_c32_to_char pure recursive module subroutine cast_r128_to_char ( x , into , locale , fmt , decimals ) real ( real128 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r128_to_char pure recursive module subroutine cast_r64_to_char ( x , into , locale , fmt , decimals ) real ( real64 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r64_to_char pure recursive module subroutine cast_r32_to_char ( x , into , locale , fmt , decimals ) real ( real32 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine cast_r32_to_char pure recursive module subroutine cast_i64_to_char ( x , into , fmt ) integer ( int64 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i64_to_char pure recursive module subroutine cast_i32_to_char ( x , into , fmt ) integer ( int32 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i32_to_char pure recursive module subroutine cast_i16_to_char ( x , into , fmt ) integer ( int16 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i16_to_char pure recursive module subroutine cast_i8_to_char ( x , into , fmt ) integer ( int8 ), intent ( in ) :: x character ( len = :), allocatable , intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_i8_to_char pure elemental recursive module subroutine cast_string_to_c128 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( real128 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c128 pure elemental recursive module subroutine cast_string_to_c64 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( real64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c64 pure elemental recursive module subroutine cast_string_to_c32 ( substring , into , locale , fmt , im ) class ( String ), intent ( in ) :: substring complex ( real32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_string_to_c32 pure elemental recursive module subroutine cast_string_to_r128 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( real128 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r128 pure elemental recursive module subroutine cast_string_to_r64 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( real64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r64 pure elemental recursive module subroutine cast_string_to_r32 ( substring , into , locale , fmt ) class ( String ), intent ( in ) :: substring real ( real32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_r32 pure elemental recursive module subroutine cast_string_to_i64 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( int64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i64 pure elemental recursive module subroutine cast_string_to_i32 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( int32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i32 pure elemental recursive module subroutine cast_string_to_i16 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( int16 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i16 pure elemental recursive module subroutine cast_string_to_i8 ( substring , into , fmt ) class ( String ), intent ( in ) :: substring integer ( int8 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_string_to_i8 pure recursive module subroutine cast_char_to_c128 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( real128 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c128 pure recursive module subroutine cast_char_to_c64 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( real64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c64 pure recursive module subroutine cast_char_to_c32 ( substring , into , locale , fmt , im ) character ( len =* ), intent ( in ) :: substring complex ( real32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine cast_char_to_c32 pure recursive module subroutine cast_char_to_r128 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( real128 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r128 pure recursive module subroutine cast_char_to_r64 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( real64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r64 pure recursive module subroutine cast_char_to_r32 ( substring , into , locale , fmt ) character ( len =* ), intent ( in ) :: substring real ( real32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_r32 pure recursive module subroutine cast_char_to_i64 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( int64 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i64 pure recursive module subroutine cast_char_to_i32 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( int32 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i32 pure recursive module subroutine cast_char_to_i16 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( int16 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i16 pure recursive module subroutine cast_char_to_i8 ( substring , into , fmt ) character ( len =* ), intent ( in ) :: substring integer ( int8 ), intent ( inout ) :: into character ( len =* ), intent ( in ), optional :: fmt end subroutine cast_char_to_i8 end interface interface join ! Submodule join_split !-------------------------------------------------------------------------------------------------------------- !! Function for joining a vector of `tokens` into a scalar `character` or `String`. !! !! For a user reference, see [join](../page/Ref/join-split.html). !-------------------------------------------------------------------------------------------------------------- pure recursive module function join_char ( tokens , separator ) result ( new ) character ( len =* ), dimension (:), intent ( in ) :: tokens character ( len =* ), intent ( in ), optional :: separator character ( len = :), allocatable :: new end function join_char pure recursive type ( String ) module function join_string ( tokens , separator ) result ( new ) type ( String ), dimension (:), intent ( in ) :: tokens character ( len =* ), intent ( in ), optional :: separator end function join_string end interface interface split ! Submodule join_split !-------------------------------------------------------------------------------------------------------------- !! Function for splitting a scalar `character` or `String` into a vector of `tokens`. !! !! For a user reference, see [split](../page/Ref/join-split.html). !-------------------------------------------------------------------------------------------------------------- pure recursive module function split_char ( substring , separator ) result ( tokens ) character ( len =* ), intent ( in ) :: substring character ( len =* ), intent ( in ), optional :: separator type ( String ), allocatable , dimension (:) :: tokens end function split_char pure recursive module function split_string ( substring , separator ) result ( tokens ) class ( String ), intent ( in ) :: substring character ( len =* ), intent ( in ), optional :: separator type ( String ), allocatable , dimension (:) :: tokens end function split_string end interface interface to_file ! Submodule file_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for writing an array of uniform numeric data type to an external file. !! !! For a user reference, see [to_file](../page/Ref/to_file.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_file_1dc128 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc128 impure recursive module subroutine to_file_1dc64 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc64 impure recursive module subroutine to_file_1dc32 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_1dc32 impure recursive module subroutine to_file_2dc128 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc128 impure recursive module subroutine to_file_2dc64 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc64 impure recursive module subroutine to_file_2dc32 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine to_file_2dc32 impure recursive module subroutine to_file_3dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc128 impure recursive module subroutine to_file_3dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc64 impure recursive module subroutine to_file_3dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dc32 impure recursive module subroutine to_file_4dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc128 impure recursive module subroutine to_file_4dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc64 impure recursive module subroutine to_file_4dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dc32 impure recursive module subroutine to_file_5dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc128 impure recursive module subroutine to_file_5dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc64 impure recursive module subroutine to_file_5dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dc32 impure recursive module subroutine to_file_6dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc128 impure recursive module subroutine to_file_6dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc64 impure recursive module subroutine to_file_6dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dc32 impure recursive module subroutine to_file_7dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc128 impure recursive module subroutine to_file_7dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc64 impure recursive module subroutine to_file_7dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dc32 impure recursive module subroutine to_file_8dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc128 impure recursive module subroutine to_file_8dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc64 impure recursive module subroutine to_file_8dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dc32 impure recursive module subroutine to_file_9dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc128 impure recursive module subroutine to_file_9dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc64 impure recursive module subroutine to_file_9dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dc32 impure recursive module subroutine to_file_10dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc128 impure recursive module subroutine to_file_10dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc64 impure recursive module subroutine to_file_10dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dc32 impure recursive module subroutine to_file_11dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc128 impure recursive module subroutine to_file_11dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc64 impure recursive module subroutine to_file_11dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dc32 impure recursive module subroutine to_file_12dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc128 impure recursive module subroutine to_file_12dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc64 impure recursive module subroutine to_file_12dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dc32 impure recursive module subroutine to_file_13dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc128 impure recursive module subroutine to_file_13dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc64 impure recursive module subroutine to_file_13dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dc32 impure recursive module subroutine to_file_14dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc128 impure recursive module subroutine to_file_14dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc64 impure recursive module subroutine to_file_14dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dc32 impure recursive module subroutine to_file_15dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc128 impure recursive module subroutine to_file_15dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc64 impure recursive module subroutine to_file_15dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dc32 impure recursive module subroutine to_file_1dr128 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr128 impure recursive module subroutine to_file_1dr64 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr64 impure recursive module subroutine to_file_1dr32 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_1dr32 impure recursive module subroutine to_file_2dr128 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr128 impure recursive module subroutine to_file_2dr64 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr64 impure recursive module subroutine to_file_2dr32 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine to_file_2dr32 impure recursive module subroutine to_file_3dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr128 impure recursive module subroutine to_file_3dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr64 impure recursive module subroutine to_file_3dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3dr32 impure recursive module subroutine to_file_4dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr128 impure recursive module subroutine to_file_4dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr64 impure recursive module subroutine to_file_4dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4dr32 impure recursive module subroutine to_file_5dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr128 impure recursive module subroutine to_file_5dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr64 impure recursive module subroutine to_file_5dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5dr32 impure recursive module subroutine to_file_6dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr128 impure recursive module subroutine to_file_6dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr64 impure recursive module subroutine to_file_6dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6dr32 impure recursive module subroutine to_file_7dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr128 impure recursive module subroutine to_file_7dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr64 impure recursive module subroutine to_file_7dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7dr32 impure recursive module subroutine to_file_8dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr128 impure recursive module subroutine to_file_8dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr64 impure recursive module subroutine to_file_8dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8dr32 impure recursive module subroutine to_file_9dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr128 impure recursive module subroutine to_file_9dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr64 impure recursive module subroutine to_file_9dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9dr32 impure recursive module subroutine to_file_10dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr128 impure recursive module subroutine to_file_10dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr64 impure recursive module subroutine to_file_10dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10dr32 impure recursive module subroutine to_file_11dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr128 impure recursive module subroutine to_file_11dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr64 impure recursive module subroutine to_file_11dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11dr32 impure recursive module subroutine to_file_12dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr128 impure recursive module subroutine to_file_12dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr64 impure recursive module subroutine to_file_12dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12dr32 impure recursive module subroutine to_file_13dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr128 impure recursive module subroutine to_file_13dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr64 impure recursive module subroutine to_file_13dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13dr32 impure recursive module subroutine to_file_14dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr128 impure recursive module subroutine to_file_14dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr64 impure recursive module subroutine to_file_14dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14dr32 impure recursive module subroutine to_file_15dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr128 impure recursive module subroutine to_file_15dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr64 impure recursive module subroutine to_file_15dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15dr32 impure recursive module subroutine to_file_1di64 ( x , file_name , header , dim , delim , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di64 impure recursive module subroutine to_file_1di32 ( x , file_name , header , dim , delim , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di32 impure recursive module subroutine to_file_1di16 ( x , file_name , header , dim , delim , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di16 impure recursive module subroutine to_file_1di8 ( x , file_name , header , dim , delim , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header integer , intent ( in ), optional :: dim character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_1di8 impure recursive module subroutine to_file_2di64 ( x , file_name , header , delim , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di64 impure recursive module subroutine to_file_2di32 ( x , file_name , header , delim , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di32 impure recursive module subroutine to_file_2di16 ( x , file_name , header , delim , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di16 impure recursive module subroutine to_file_2di8 ( x , file_name , header , delim , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine to_file_2di8 impure recursive module subroutine to_file_3di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di64 impure recursive module subroutine to_file_3di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di32 impure recursive module subroutine to_file_3di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di16 impure recursive module subroutine to_file_3di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_3di8 impure recursive module subroutine to_file_4di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di64 impure recursive module subroutine to_file_4di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di32 impure recursive module subroutine to_file_4di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di16 impure recursive module subroutine to_file_4di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_4di8 impure recursive module subroutine to_file_5di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di64 impure recursive module subroutine to_file_5di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di32 impure recursive module subroutine to_file_5di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di16 impure recursive module subroutine to_file_5di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_5di8 impure recursive module subroutine to_file_6di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di64 impure recursive module subroutine to_file_6di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di32 impure recursive module subroutine to_file_6di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di16 impure recursive module subroutine to_file_6di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_6di8 impure recursive module subroutine to_file_7di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di64 impure recursive module subroutine to_file_7di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di32 impure recursive module subroutine to_file_7di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di16 impure recursive module subroutine to_file_7di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_7di8 impure recursive module subroutine to_file_8di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di64 impure recursive module subroutine to_file_8di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di32 impure recursive module subroutine to_file_8di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di16 impure recursive module subroutine to_file_8di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_8di8 impure recursive module subroutine to_file_9di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di64 impure recursive module subroutine to_file_9di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di32 impure recursive module subroutine to_file_9di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di16 impure recursive module subroutine to_file_9di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_9di8 impure recursive module subroutine to_file_10di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di64 impure recursive module subroutine to_file_10di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di32 impure recursive module subroutine to_file_10di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di16 impure recursive module subroutine to_file_10di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_10di8 impure recursive module subroutine to_file_11di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di64 impure recursive module subroutine to_file_11di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di32 impure recursive module subroutine to_file_11di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di16 impure recursive module subroutine to_file_11di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_11di8 impure recursive module subroutine to_file_12di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di64 impure recursive module subroutine to_file_12di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di32 impure recursive module subroutine to_file_12di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di16 impure recursive module subroutine to_file_12di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_12di8 impure recursive module subroutine to_file_13di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di64 impure recursive module subroutine to_file_13di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di32 impure recursive module subroutine to_file_13di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di16 impure recursive module subroutine to_file_13di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_13di8 impure recursive module subroutine to_file_14di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di64 impure recursive module subroutine to_file_14di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di32 impure recursive module subroutine to_file_14di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di16 impure recursive module subroutine to_file_14di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_14di8 impure recursive module subroutine to_file_15di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di64 impure recursive module subroutine to_file_15di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di32 impure recursive module subroutine to_file_15di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di16 impure recursive module subroutine to_file_15di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_file_15di8 end interface interface from_file ! Submodule file_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for reading an external file of uniform numeric data type and format into an array. !! !! For a user reference, see [from_file](../page/Ref/from_file.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_textfile_1dc128 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc128 impure recursive module subroutine from_binaryfile_1dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc128 impure recursive module subroutine from_textfile_1dc64 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc64 impure recursive module subroutine from_binaryfile_1dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc64 impure recursive module subroutine from_textfile_1dc32 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_1dc32 impure recursive module subroutine from_binaryfile_1dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dc32 impure recursive module subroutine from_textfile_2dc128 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc128 impure recursive module subroutine from_binaryfile_2dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc128 impure recursive module subroutine from_textfile_2dc64 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc64 impure recursive module subroutine from_binaryfile_2dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc64 impure recursive module subroutine from_textfile_2dc32 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt character ( len =* ), intent ( in ), optional :: im end subroutine from_textfile_2dc32 impure recursive module subroutine from_binaryfile_2dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dc32 impure recursive module subroutine from_file_3dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc128 impure recursive module subroutine from_file_3dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc64 impure recursive module subroutine from_file_3dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dc32 impure recursive module subroutine from_file_4dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc128 impure recursive module subroutine from_file_4dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc64 impure recursive module subroutine from_file_4dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dc32 impure recursive module subroutine from_file_5dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc128 impure recursive module subroutine from_file_5dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc64 impure recursive module subroutine from_file_5dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dc32 impure recursive module subroutine from_file_6dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc128 impure recursive module subroutine from_file_6dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc64 impure recursive module subroutine from_file_6dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dc32 impure recursive module subroutine from_file_7dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc128 impure recursive module subroutine from_file_7dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc64 impure recursive module subroutine from_file_7dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dc32 impure recursive module subroutine from_file_8dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc128 impure recursive module subroutine from_file_8dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc64 impure recursive module subroutine from_file_8dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dc32 impure recursive module subroutine from_file_9dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc128 impure recursive module subroutine from_file_9dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc64 impure recursive module subroutine from_file_9dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dc32 impure recursive module subroutine from_file_10dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc128 impure recursive module subroutine from_file_10dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc64 impure recursive module subroutine from_file_10dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dc32 impure recursive module subroutine from_file_11dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc128 impure recursive module subroutine from_file_11dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc64 impure recursive module subroutine from_file_11dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dc32 impure recursive module subroutine from_file_12dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc128 impure recursive module subroutine from_file_12dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc64 impure recursive module subroutine from_file_12dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dc32 impure recursive module subroutine from_file_13dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc128 impure recursive module subroutine from_file_13dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc64 impure recursive module subroutine from_file_13dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dc32 impure recursive module subroutine from_file_14dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc128 impure recursive module subroutine from_file_14dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc64 impure recursive module subroutine from_file_14dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dc32 impure recursive module subroutine from_file_15dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc128 impure recursive module subroutine from_file_15dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc64 impure recursive module subroutine from_file_15dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dc32 impure recursive module subroutine from_textfile_1dr128 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr128 impure recursive module subroutine from_binaryfile_1dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr128 impure recursive module subroutine from_textfile_1dr64 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr64 impure recursive module subroutine from_binaryfile_1dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr64 impure recursive module subroutine from_textfile_1dr32 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1dr32 impure recursive module subroutine from_binaryfile_1dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1dr32 impure recursive module subroutine from_textfile_2dr128 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr128 impure recursive module subroutine from_binaryfile_2dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr128 impure recursive module subroutine from_textfile_2dr64 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr64 impure recursive module subroutine from_binaryfile_2dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr64 impure recursive module subroutine from_textfile_2dr32 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: locale character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2dr32 impure recursive module subroutine from_binaryfile_2dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2dr32 impure recursive module subroutine from_file_3dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr128 impure recursive module subroutine from_file_3dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr64 impure recursive module subroutine from_file_3dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3dr32 impure recursive module subroutine from_file_4dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr128 impure recursive module subroutine from_file_4dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr64 impure recursive module subroutine from_file_4dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4dr32 impure recursive module subroutine from_file_5dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr128 impure recursive module subroutine from_file_5dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr64 impure recursive module subroutine from_file_5dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5dr32 impure recursive module subroutine from_file_6dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr128 impure recursive module subroutine from_file_6dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr64 impure recursive module subroutine from_file_6dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6dr32 impure recursive module subroutine from_file_7dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr128 impure recursive module subroutine from_file_7dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr64 impure recursive module subroutine from_file_7dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7dr32 impure recursive module subroutine from_file_8dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr128 impure recursive module subroutine from_file_8dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr64 impure recursive module subroutine from_file_8dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8dr32 impure recursive module subroutine from_file_9dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr128 impure recursive module subroutine from_file_9dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr64 impure recursive module subroutine from_file_9dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9dr32 impure recursive module subroutine from_file_10dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr128 impure recursive module subroutine from_file_10dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr64 impure recursive module subroutine from_file_10dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10dr32 impure recursive module subroutine from_file_11dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr128 impure recursive module subroutine from_file_11dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr64 impure recursive module subroutine from_file_11dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11dr32 impure recursive module subroutine from_file_12dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr128 impure recursive module subroutine from_file_12dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr64 impure recursive module subroutine from_file_12dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12dr32 impure recursive module subroutine from_file_13dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr128 impure recursive module subroutine from_file_13dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr64 impure recursive module subroutine from_file_13dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13dr32 impure recursive module subroutine from_file_14dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr128 impure recursive module subroutine from_file_14dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr64 impure recursive module subroutine from_file_14dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14dr32 impure recursive module subroutine from_file_15dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr128 impure recursive module subroutine from_file_15dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr64 impure recursive module subroutine from_file_15dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15dr32 impure recursive module subroutine from_textfile_1di64 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di64 impure recursive module subroutine from_binaryfile_1di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di64 impure recursive module subroutine from_textfile_1di32 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di32 impure recursive module subroutine from_binaryfile_1di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di32 impure recursive module subroutine from_textfile_1di16 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di16 impure recursive module subroutine from_binaryfile_1di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di16 impure recursive module subroutine from_textfile_1di8 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_1di8 impure recursive module subroutine from_binaryfile_1di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_1di8 impure recursive module subroutine from_textfile_2di64 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di64 impure recursive module subroutine from_binaryfile_2di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di64 impure recursive module subroutine from_textfile_2di32 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di32 impure recursive module subroutine from_binaryfile_2di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di32 impure recursive module subroutine from_textfile_2di16 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di16 impure recursive module subroutine from_binaryfile_2di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di16 impure recursive module subroutine from_textfile_2di8 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ), optional :: header character ( len =* ), intent ( in ), optional :: delim character ( len =* ), intent ( in ), optional :: fmt end subroutine from_textfile_2di8 impure recursive module subroutine from_binaryfile_2di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binaryfile_2di8 impure recursive module subroutine from_file_3di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di64 impure recursive module subroutine from_file_3di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di32 impure recursive module subroutine from_file_3di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di16 impure recursive module subroutine from_file_3di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_3di8 impure recursive module subroutine from_file_4di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di64 impure recursive module subroutine from_file_4di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di32 impure recursive module subroutine from_file_4di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di16 impure recursive module subroutine from_file_4di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_4di8 impure recursive module subroutine from_file_5di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di64 impure recursive module subroutine from_file_5di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di32 impure recursive module subroutine from_file_5di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di16 impure recursive module subroutine from_file_5di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_5di8 impure recursive module subroutine from_file_6di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di64 impure recursive module subroutine from_file_6di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di32 impure recursive module subroutine from_file_6di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di16 impure recursive module subroutine from_file_6di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_6di8 impure recursive module subroutine from_file_7di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di64 impure recursive module subroutine from_file_7di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di32 impure recursive module subroutine from_file_7di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di16 impure recursive module subroutine from_file_7di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_7di8 impure recursive module subroutine from_file_8di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di64 impure recursive module subroutine from_file_8di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di32 impure recursive module subroutine from_file_8di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di16 impure recursive module subroutine from_file_8di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_8di8 impure recursive module subroutine from_file_9di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di64 impure recursive module subroutine from_file_9di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di32 impure recursive module subroutine from_file_9di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di16 impure recursive module subroutine from_file_9di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_9di8 impure recursive module subroutine from_file_10di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di64 impure recursive module subroutine from_file_10di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di32 impure recursive module subroutine from_file_10di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di16 impure recursive module subroutine from_file_10di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_10di8 impure recursive module subroutine from_file_11di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di64 impure recursive module subroutine from_file_11di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di32 impure recursive module subroutine from_file_11di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di16 impure recursive module subroutine from_file_11di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_11di8 impure recursive module subroutine from_file_12di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di64 impure recursive module subroutine from_file_12di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di32 impure recursive module subroutine from_file_12di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di16 impure recursive module subroutine from_file_12di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_12di8 impure recursive module subroutine from_file_13di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di64 impure recursive module subroutine from_file_13di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di32 impure recursive module subroutine from_file_13di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di16 impure recursive module subroutine from_file_13di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_13di8 impure recursive module subroutine from_file_14di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di64 impure recursive module subroutine from_file_14di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di32 impure recursive module subroutine from_file_14di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di16 impure recursive module subroutine from_file_14di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_14di8 impure recursive module subroutine from_file_15di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di64 impure recursive module subroutine from_file_15di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di32 impure recursive module subroutine from_file_15di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di16 impure recursive module subroutine from_file_15di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_file_15di8 end interface interface echo ! Submodule text_io !-------------------------------------------------------------------------------------------------------------- !! Subroutine for writing a scalar `character` or `String` to an external text file. !! !! For a user reference, see [echo](../page/Ref/echo.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine echo_chars ( substring , file_name , append , terminator ) character ( len =* ), intent ( in ) :: substring character ( len =* ), intent ( in ) :: file_name logical , intent ( in ), optional :: append character ( len =* ), intent ( in ), optional :: terminator end subroutine echo_chars impure recursive module subroutine echo_string ( substring , file_name , append , terminator ) class ( String ), intent ( in ) :: substring character ( len =* ), intent ( in ) :: file_name logical , intent ( in ), optional :: append character ( len =* ), intent ( in ), optional :: terminator end subroutine echo_string end interface interface to_text ! Submodule text_io !-------------------------------------------------------------------------------------------------------------- !! Private interface for writing an array to an external text file. !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_text_1dc128 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc128 impure recursive module subroutine to_text_1dc64 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc64 impure recursive module subroutine to_text_1dc32 ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_1dc32 impure recursive module subroutine to_text_2dc128 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc128 impure recursive module subroutine to_text_2dc64 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc64 impure recursive module subroutine to_text_2dc32 ( x , file_name , header , locale , delim , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals character ( len =* ), intent ( in ) :: im end subroutine to_text_2dc32 impure recursive module subroutine to_text_1dr128 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr128 impure recursive module subroutine to_text_1dr64 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr64 impure recursive module subroutine to_text_1dr32 ( x , file_name , header , dim , locale , delim , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_1dr32 impure recursive module subroutine to_text_2dr128 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr128 impure recursive module subroutine to_text_2dr64 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr64 impure recursive module subroutine to_text_2dr32 ( x , file_name , header , locale , delim , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt integer , intent ( in ) :: decimals end subroutine to_text_2dr32 impure recursive module subroutine to_text_1di64 ( x , file_name , header , dim , delim , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di64 impure recursive module subroutine to_text_1di32 ( x , file_name , header , dim , delim , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di32 impure recursive module subroutine to_text_1di16 ( x , file_name , header , dim , delim , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di16 impure recursive module subroutine to_text_1di8 ( x , file_name , header , dim , delim , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header integer , intent ( in ) :: dim character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_1di8 impure recursive module subroutine to_text_2di64 ( x , file_name , header , delim , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di64 impure recursive module subroutine to_text_2di32 ( x , file_name , header , delim , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di32 impure recursive module subroutine to_text_2di16 ( x , file_name , header , delim , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di16 impure recursive module subroutine to_text_2di8 ( x , file_name , header , delim , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name character ( len =* ), dimension (:), intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine to_text_2di8 end interface interface from_text ! Submodule text_io !-------------------------------------------------------------------------------------------------------------- !! Private interface for reading an external text file into an array. !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_text_1dc128 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc128 impure recursive module subroutine from_text_1dc64 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc64 impure recursive module subroutine from_text_1dc32 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_1dc32 impure recursive module subroutine from_text_2dc128 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc128 impure recursive module subroutine from_text_2dc64 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc64 impure recursive module subroutine from_text_2dc32 ( file_name , into , header , locale , delim , fmt , im ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt character ( len =* ), intent ( in ) :: im end subroutine from_text_2dc32 impure recursive module subroutine from_text_1dr128 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr128 impure recursive module subroutine from_text_1dr64 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr64 impure recursive module subroutine from_text_1dr32 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1dr32 impure recursive module subroutine from_text_2dr128 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr128 impure recursive module subroutine from_text_2dr64 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr64 impure recursive module subroutine from_text_2dr32 ( file_name , into , header , locale , delim , fmt ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: locale character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2dr32 impure recursive module subroutine from_text_1di64 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di64 impure recursive module subroutine from_text_1di32 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di32 impure recursive module subroutine from_text_1di16 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di16 impure recursive module subroutine from_text_1di8 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_1di8 impure recursive module subroutine from_text_2di64 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di64 impure recursive module subroutine from_text_2di32 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di32 impure recursive module subroutine from_text_2di16 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di16 impure recursive module subroutine from_text_2di8 ( file_name , into , header , delim , fmt ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into logical , intent ( in ) :: header character ( len =* ), intent ( in ) :: delim character ( len =* ), intent ( in ) :: fmt end subroutine from_text_2di8 end interface interface to_binary ! Submodule binary_io !-------------------------------------------------------------------------------------------------------------- !! Private interface for writing an array to an external binary file. !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine to_binary_1dc128 ( x , file_name ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc128 impure recursive module subroutine to_binary_1dc64 ( x , file_name ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc64 impure recursive module subroutine to_binary_1dc32 ( x , file_name ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dc32 impure recursive module subroutine to_binary_2dc128 ( x , file_name ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc128 impure recursive module subroutine to_binary_2dc64 ( x , file_name ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc64 impure recursive module subroutine to_binary_2dc32 ( x , file_name ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dc32 impure recursive module subroutine to_binary_3dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc128 impure recursive module subroutine to_binary_3dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc64 impure recursive module subroutine to_binary_3dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dc32 impure recursive module subroutine to_binary_4dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc128 impure recursive module subroutine to_binary_4dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc64 impure recursive module subroutine to_binary_4dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dc32 impure recursive module subroutine to_binary_5dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc128 impure recursive module subroutine to_binary_5dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc64 impure recursive module subroutine to_binary_5dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dc32 impure recursive module subroutine to_binary_6dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc128 impure recursive module subroutine to_binary_6dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc64 impure recursive module subroutine to_binary_6dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dc32 impure recursive module subroutine to_binary_7dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc128 impure recursive module subroutine to_binary_7dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc64 impure recursive module subroutine to_binary_7dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dc32 impure recursive module subroutine to_binary_8dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc128 impure recursive module subroutine to_binary_8dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc64 impure recursive module subroutine to_binary_8dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dc32 impure recursive module subroutine to_binary_9dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc128 impure recursive module subroutine to_binary_9dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc64 impure recursive module subroutine to_binary_9dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dc32 impure recursive module subroutine to_binary_10dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc128 impure recursive module subroutine to_binary_10dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc64 impure recursive module subroutine to_binary_10dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dc32 impure recursive module subroutine to_binary_11dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc128 impure recursive module subroutine to_binary_11dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc64 impure recursive module subroutine to_binary_11dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dc32 impure recursive module subroutine to_binary_12dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc128 impure recursive module subroutine to_binary_12dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc64 impure recursive module subroutine to_binary_12dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dc32 impure recursive module subroutine to_binary_13dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc128 impure recursive module subroutine to_binary_13dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc64 impure recursive module subroutine to_binary_13dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dc32 impure recursive module subroutine to_binary_14dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc128 impure recursive module subroutine to_binary_14dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc64 impure recursive module subroutine to_binary_14dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dc32 impure recursive module subroutine to_binary_15dc128 ( x , file_name ) complex ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc128 impure recursive module subroutine to_binary_15dc64 ( x , file_name ) complex ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc64 impure recursive module subroutine to_binary_15dc32 ( x , file_name ) complex ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dc32 impure recursive module subroutine to_binary_1dr128 ( x , file_name ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr128 impure recursive module subroutine to_binary_1dr64 ( x , file_name ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr64 impure recursive module subroutine to_binary_1dr32 ( x , file_name ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1dr32 impure recursive module subroutine to_binary_2dr128 ( x , file_name ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr128 impure recursive module subroutine to_binary_2dr64 ( x , file_name ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr64 impure recursive module subroutine to_binary_2dr32 ( x , file_name ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2dr32 impure recursive module subroutine to_binary_3dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr128 impure recursive module subroutine to_binary_3dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr64 impure recursive module subroutine to_binary_3dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3dr32 impure recursive module subroutine to_binary_4dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr128 impure recursive module subroutine to_binary_4dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr64 impure recursive module subroutine to_binary_4dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4dr32 impure recursive module subroutine to_binary_5dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr128 impure recursive module subroutine to_binary_5dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr64 impure recursive module subroutine to_binary_5dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5dr32 impure recursive module subroutine to_binary_6dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr128 impure recursive module subroutine to_binary_6dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr64 impure recursive module subroutine to_binary_6dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6dr32 impure recursive module subroutine to_binary_7dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr128 impure recursive module subroutine to_binary_7dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr64 impure recursive module subroutine to_binary_7dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7dr32 impure recursive module subroutine to_binary_8dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr128 impure recursive module subroutine to_binary_8dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr64 impure recursive module subroutine to_binary_8dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8dr32 impure recursive module subroutine to_binary_9dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr128 impure recursive module subroutine to_binary_9dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr64 impure recursive module subroutine to_binary_9dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9dr32 impure recursive module subroutine to_binary_10dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr128 impure recursive module subroutine to_binary_10dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr64 impure recursive module subroutine to_binary_10dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10dr32 impure recursive module subroutine to_binary_11dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr128 impure recursive module subroutine to_binary_11dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr64 impure recursive module subroutine to_binary_11dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11dr32 impure recursive module subroutine to_binary_12dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr128 impure recursive module subroutine to_binary_12dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr64 impure recursive module subroutine to_binary_12dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12dr32 impure recursive module subroutine to_binary_13dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr128 impure recursive module subroutine to_binary_13dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr64 impure recursive module subroutine to_binary_13dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13dr32 impure recursive module subroutine to_binary_14dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr128 impure recursive module subroutine to_binary_14dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr64 impure recursive module subroutine to_binary_14dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14dr32 impure recursive module subroutine to_binary_15dr128 ( x , file_name ) real ( real128 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr128 impure recursive module subroutine to_binary_15dr64 ( x , file_name ) real ( real64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr64 impure recursive module subroutine to_binary_15dr32 ( x , file_name ) real ( real32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15dr32 impure recursive module subroutine to_binary_1di64 ( x , file_name ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di64 impure recursive module subroutine to_binary_1di32 ( x , file_name ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di32 impure recursive module subroutine to_binary_1di16 ( x , file_name ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di16 impure recursive module subroutine to_binary_1di8 ( x , file_name ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_1di8 impure recursive module subroutine to_binary_2di64 ( x , file_name ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di64 impure recursive module subroutine to_binary_2di32 ( x , file_name ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di32 impure recursive module subroutine to_binary_2di16 ( x , file_name ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di16 impure recursive module subroutine to_binary_2di8 ( x , file_name ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_2di8 impure recursive module subroutine to_binary_3di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di64 impure recursive module subroutine to_binary_3di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di32 impure recursive module subroutine to_binary_3di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di16 impure recursive module subroutine to_binary_3di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_3di8 impure recursive module subroutine to_binary_4di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di64 impure recursive module subroutine to_binary_4di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di32 impure recursive module subroutine to_binary_4di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di16 impure recursive module subroutine to_binary_4di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_4di8 impure recursive module subroutine to_binary_5di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di64 impure recursive module subroutine to_binary_5di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di32 impure recursive module subroutine to_binary_5di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di16 impure recursive module subroutine to_binary_5di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_5di8 impure recursive module subroutine to_binary_6di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di64 impure recursive module subroutine to_binary_6di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di32 impure recursive module subroutine to_binary_6di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di16 impure recursive module subroutine to_binary_6di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_6di8 impure recursive module subroutine to_binary_7di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di64 impure recursive module subroutine to_binary_7di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di32 impure recursive module subroutine to_binary_7di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di16 impure recursive module subroutine to_binary_7di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_7di8 impure recursive module subroutine to_binary_8di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di64 impure recursive module subroutine to_binary_8di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di32 impure recursive module subroutine to_binary_8di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di16 impure recursive module subroutine to_binary_8di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_8di8 impure recursive module subroutine to_binary_9di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di64 impure recursive module subroutine to_binary_9di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di32 impure recursive module subroutine to_binary_9di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di16 impure recursive module subroutine to_binary_9di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_9di8 impure recursive module subroutine to_binary_10di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di64 impure recursive module subroutine to_binary_10di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di32 impure recursive module subroutine to_binary_10di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di16 impure recursive module subroutine to_binary_10di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_10di8 impure recursive module subroutine to_binary_11di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di64 impure recursive module subroutine to_binary_11di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di32 impure recursive module subroutine to_binary_11di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di16 impure recursive module subroutine to_binary_11di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_11di8 impure recursive module subroutine to_binary_12di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di64 impure recursive module subroutine to_binary_12di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di32 impure recursive module subroutine to_binary_12di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di16 impure recursive module subroutine to_binary_12di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_12di8 impure recursive module subroutine to_binary_13di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di64 impure recursive module subroutine to_binary_13di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di32 impure recursive module subroutine to_binary_13di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di16 impure recursive module subroutine to_binary_13di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_13di8 impure recursive module subroutine to_binary_14di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di64 impure recursive module subroutine to_binary_14di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di32 impure recursive module subroutine to_binary_14di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di16 impure recursive module subroutine to_binary_14di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_14di8 impure recursive module subroutine to_binary_15di64 ( x , file_name ) integer ( int64 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di64 impure recursive module subroutine to_binary_15di32 ( x , file_name ) integer ( int32 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di32 impure recursive module subroutine to_binary_15di16 ( x , file_name ) integer ( int16 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di16 impure recursive module subroutine to_binary_15di8 ( x , file_name ) integer ( int8 ), dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( in ) :: x character ( len =* ), intent ( in ) :: file_name end subroutine to_binary_15di8 end interface interface from_binary ! Submodule binary_io !-------------------------------------------------------------------------------------------------------------- !! Private interface for reading an external binary file into an array. !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine from_binary_1dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc128 impure recursive module subroutine from_binary_1dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc64 impure recursive module subroutine from_binary_1dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dc32 impure recursive module subroutine from_binary_2dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc128 impure recursive module subroutine from_binary_2dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc64 impure recursive module subroutine from_binary_2dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dc32 impure recursive module subroutine from_binary_3dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc128 impure recursive module subroutine from_binary_3dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc64 impure recursive module subroutine from_binary_3dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dc32 impure recursive module subroutine from_binary_4dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc128 impure recursive module subroutine from_binary_4dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc64 impure recursive module subroutine from_binary_4dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dc32 impure recursive module subroutine from_binary_5dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc128 impure recursive module subroutine from_binary_5dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc64 impure recursive module subroutine from_binary_5dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dc32 impure recursive module subroutine from_binary_6dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc128 impure recursive module subroutine from_binary_6dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc64 impure recursive module subroutine from_binary_6dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dc32 impure recursive module subroutine from_binary_7dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc128 impure recursive module subroutine from_binary_7dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc64 impure recursive module subroutine from_binary_7dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dc32 impure recursive module subroutine from_binary_8dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc128 impure recursive module subroutine from_binary_8dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc64 impure recursive module subroutine from_binary_8dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dc32 impure recursive module subroutine from_binary_9dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc128 impure recursive module subroutine from_binary_9dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc64 impure recursive module subroutine from_binary_9dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dc32 impure recursive module subroutine from_binary_10dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc128 impure recursive module subroutine from_binary_10dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc64 impure recursive module subroutine from_binary_10dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dc32 impure recursive module subroutine from_binary_11dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc128 impure recursive module subroutine from_binary_11dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc64 impure recursive module subroutine from_binary_11dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dc32 impure recursive module subroutine from_binary_12dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc128 impure recursive module subroutine from_binary_12dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc64 impure recursive module subroutine from_binary_12dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dc32 impure recursive module subroutine from_binary_13dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc128 impure recursive module subroutine from_binary_13dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc64 impure recursive module subroutine from_binary_13dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dc32 impure recursive module subroutine from_binary_14dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc128 impure recursive module subroutine from_binary_14dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc64 impure recursive module subroutine from_binary_14dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dc32 impure recursive module subroutine from_binary_15dc128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc128 impure recursive module subroutine from_binary_15dc64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc64 impure recursive module subroutine from_binary_15dc32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name complex ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dc32 impure recursive module subroutine from_binary_1dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr128 impure recursive module subroutine from_binary_1dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr64 impure recursive module subroutine from_binary_1dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1dr32 impure recursive module subroutine from_binary_2dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr128 impure recursive module subroutine from_binary_2dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr64 impure recursive module subroutine from_binary_2dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2dr32 impure recursive module subroutine from_binary_3dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr128 impure recursive module subroutine from_binary_3dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr64 impure recursive module subroutine from_binary_3dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3dr32 impure recursive module subroutine from_binary_4dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr128 impure recursive module subroutine from_binary_4dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr64 impure recursive module subroutine from_binary_4dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4dr32 impure recursive module subroutine from_binary_5dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr128 impure recursive module subroutine from_binary_5dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr64 impure recursive module subroutine from_binary_5dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5dr32 impure recursive module subroutine from_binary_6dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr128 impure recursive module subroutine from_binary_6dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr64 impure recursive module subroutine from_binary_6dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6dr32 impure recursive module subroutine from_binary_7dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr128 impure recursive module subroutine from_binary_7dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr64 impure recursive module subroutine from_binary_7dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7dr32 impure recursive module subroutine from_binary_8dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr128 impure recursive module subroutine from_binary_8dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr64 impure recursive module subroutine from_binary_8dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8dr32 impure recursive module subroutine from_binary_9dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr128 impure recursive module subroutine from_binary_9dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr64 impure recursive module subroutine from_binary_9dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9dr32 impure recursive module subroutine from_binary_10dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr128 impure recursive module subroutine from_binary_10dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr64 impure recursive module subroutine from_binary_10dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10dr32 impure recursive module subroutine from_binary_11dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr128 impure recursive module subroutine from_binary_11dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr64 impure recursive module subroutine from_binary_11dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11dr32 impure recursive module subroutine from_binary_12dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr128 impure recursive module subroutine from_binary_12dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr64 impure recursive module subroutine from_binary_12dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12dr32 impure recursive module subroutine from_binary_13dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr128 impure recursive module subroutine from_binary_13dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr64 impure recursive module subroutine from_binary_13dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13dr32 impure recursive module subroutine from_binary_14dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr128 impure recursive module subroutine from_binary_14dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr64 impure recursive module subroutine from_binary_14dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14dr32 impure recursive module subroutine from_binary_15dr128 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real128 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr128 impure recursive module subroutine from_binary_15dr64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr64 impure recursive module subroutine from_binary_15dr32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name real ( real32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15dr32 impure recursive module subroutine from_binary_1di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di64 impure recursive module subroutine from_binary_1di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di32 impure recursive module subroutine from_binary_1di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di16 impure recursive module subroutine from_binary_1di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_1di8 impure recursive module subroutine from_binary_2di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di64 impure recursive module subroutine from_binary_2di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di32 impure recursive module subroutine from_binary_2di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di16 impure recursive module subroutine from_binary_2di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_2di8 impure recursive module subroutine from_binary_3di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di64 impure recursive module subroutine from_binary_3di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di32 impure recursive module subroutine from_binary_3di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di16 impure recursive module subroutine from_binary_3di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_3di8 impure recursive module subroutine from_binary_4di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di64 impure recursive module subroutine from_binary_4di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di32 impure recursive module subroutine from_binary_4di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di16 impure recursive module subroutine from_binary_4di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_4di8 impure recursive module subroutine from_binary_5di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di64 impure recursive module subroutine from_binary_5di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di32 impure recursive module subroutine from_binary_5di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di16 impure recursive module subroutine from_binary_5di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_5di8 impure recursive module subroutine from_binary_6di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di64 impure recursive module subroutine from_binary_6di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di32 impure recursive module subroutine from_binary_6di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di16 impure recursive module subroutine from_binary_6di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_6di8 impure recursive module subroutine from_binary_7di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di64 impure recursive module subroutine from_binary_7di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di32 impure recursive module subroutine from_binary_7di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di16 impure recursive module subroutine from_binary_7di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_7di8 impure recursive module subroutine from_binary_8di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di64 impure recursive module subroutine from_binary_8di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di32 impure recursive module subroutine from_binary_8di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di16 impure recursive module subroutine from_binary_8di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_8di8 impure recursive module subroutine from_binary_9di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di64 impure recursive module subroutine from_binary_9di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di32 impure recursive module subroutine from_binary_9di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di16 impure recursive module subroutine from_binary_9di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_9di8 impure recursive module subroutine from_binary_10di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di64 impure recursive module subroutine from_binary_10di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di32 impure recursive module subroutine from_binary_10di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di16 impure recursive module subroutine from_binary_10di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_10di8 impure recursive module subroutine from_binary_11di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di64 impure recursive module subroutine from_binary_11di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di32 impure recursive module subroutine from_binary_11di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di16 impure recursive module subroutine from_binary_11di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_11di8 impure recursive module subroutine from_binary_12di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di64 impure recursive module subroutine from_binary_12di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di32 impure recursive module subroutine from_binary_12di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di16 impure recursive module subroutine from_binary_12di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_12di8 impure recursive module subroutine from_binary_13di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di64 impure recursive module subroutine from_binary_13di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di32 impure recursive module subroutine from_binary_13di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di16 impure recursive module subroutine from_binary_13di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_13di8 impure recursive module subroutine from_binary_14di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di64 impure recursive module subroutine from_binary_14di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di32 impure recursive module subroutine from_binary_14di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di16 impure recursive module subroutine from_binary_14di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_14di8 impure recursive module subroutine from_binary_15di64 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int64 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di64 impure recursive module subroutine from_binary_15di32 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int32 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di32 impure recursive module subroutine from_binary_15di16 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int16 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di16 impure recursive module subroutine from_binary_15di8 ( file_name , into , data_shape ) character ( len =* ), intent ( in ) :: file_name integer ( int8 ), allocatable , dimension (:,:,:,:,:,:,:,:,:,:,:,:,:,:,:), intent ( out ) :: into integer , dimension (:), intent ( in ) :: data_shape end subroutine from_binary_15di8 end interface interface aprint ! Submodule array_printing !-------------------------------------------------------------------------------------------------------------- !! Subroutine for printing arrays and array sections to stdout. !! !! For a user reference, see [aprint](../page/Ref/aprint.html). !-------------------------------------------------------------------------------------------------------------- impure recursive module subroutine aprint_1dc128 ( x , fmt , decimals , im ) complex ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc128 impure recursive module subroutine aprint_1dc64 ( x , fmt , decimals , im ) complex ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc64 impure recursive module subroutine aprint_1dc32 ( x , fmt , decimals , im ) complex ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_1dc32 impure recursive module subroutine aprint_2dc128 ( x , fmt , decimals , im ) complex ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc128 impure recursive module subroutine aprint_2dc64 ( x , fmt , decimals , im ) complex ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc64 impure recursive module subroutine aprint_2dc32 ( x , fmt , decimals , im ) complex ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals character ( len =* ), intent ( in ), optional :: im end subroutine aprint_2dc32 impure recursive module subroutine aprint_1dr128 ( x , fmt , decimals ) real ( real128 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr128 impure recursive module subroutine aprint_1dr64 ( x , fmt , decimals ) real ( real64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr64 impure recursive module subroutine aprint_1dr32 ( x , fmt , decimals ) real ( real32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_1dr32 impure recursive module subroutine aprint_2dr128 ( x , fmt , decimals ) real ( real128 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr128 impure recursive module subroutine aprint_2dr64 ( x , fmt , decimals ) real ( real64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr64 impure recursive module subroutine aprint_2dr32 ( x , fmt , decimals ) real ( real32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt integer , intent ( in ), optional :: decimals end subroutine aprint_2dr32 impure recursive module subroutine aprint_1di64 ( x , fmt ) integer ( int64 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di64 impure recursive module subroutine aprint_1di32 ( x , fmt ) integer ( int32 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di32 impure recursive module subroutine aprint_1di16 ( x , fmt ) integer ( int16 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di16 impure recursive module subroutine aprint_1di8 ( x , fmt ) integer ( int8 ), dimension (:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_1di8 impure recursive module subroutine aprint_2di64 ( x , fmt ) integer ( int64 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di64 impure recursive module subroutine aprint_2di32 ( x , fmt ) integer ( int32 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di32 impure recursive module subroutine aprint_2di16 ( x , fmt ) integer ( int16 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di16 impure recursive module subroutine aprint_2di8 ( x , fmt ) integer ( int8 ), dimension (:,:), intent ( in ) :: x character ( len =* ), intent ( in ), optional :: fmt end subroutine aprint_2di8 impure recursive module subroutine aprint_1dchar ( x ) character ( len =* ), dimension (:), intent ( in ) :: x end subroutine aprint_1dchar impure recursive module subroutine aprint_2dchar ( x ) character ( len =* ), dimension (:,:), intent ( in ) :: x end subroutine aprint_2dchar impure recursive module subroutine aprint_1dString ( x ) class ( String ), dimension (:), intent ( in ) :: x end subroutine aprint_1dString impure recursive module subroutine aprint_2dString ( x ) class ( String ), dimension (:,:), intent ( in ) :: x end subroutine aprint_2dString end interface contains pure recursive function ext_of ( file_name ) result ( ext ) ! Function for parsing a file name for an extension character ( len =* ), intent ( in ) :: file_name character ( len = :), allocatable :: ext integer :: i , l l = len_trim ( file_name ) do i = l , 1 , - 1 if ( file_name ( i : i ) == POINT ) exit end do if ( i > 0 ) then ext = trim ( adjustl ( file_name ( i + 1 : l ))) else ext = EMPTY_STR end if end function ext_of end module io_fortran_lib submodule ( io_fortran_lib ) string_methods !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **type-bound procedures** of type `String`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains module procedure as_str if ( self % len () < 1 ) then string_slice = EMPTY_STR else string_slice = self % s end if end procedure as_str module procedure count_substring_chars integer ( int64 ) :: self_len , match_len , max_pos , upper_ind , i , j integer :: first_char , last_char self_len = self % len64 () match_len = len ( match , kind = int64 ) if ( self_len < 1_int64 ) then if ( self_len == match_len ) then occurrences = 1 ; return else occurrences = 0 ; return end if end if if ( ( match_len == 0_int64 ) . or . ( match_len > self_len ) ) then occurrences = 0 ; return end if occurrences = 0 ; max_pos = self_len - match_len + 1_int64 first_char = iachar ( match ( 1 : 1 )); last_char = iachar ( match ( match_len : match_len )) if ( match_len == 1_int64 ) then i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle else occurrences = occurrences + 1 ; i = i + 1_int64 ; cycle end if end do end if if ( match_len == 2_int64 ) then i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle end if if ( iachar ( self % s ( i + 1_int64 : i + 1_int64 )) /= last_char ) then i = i + 1_int64 ; cycle else occurrences = occurrences + 1 ; i = i + 2_int64 ; cycle end if end do end if i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle end if upper_ind = i + match_len - 1_int64 if ( iachar ( self % s ( upper_ind : upper_ind )) /= last_char ) then i = i + 1_int64 ; cycle end if if ( self % s ( i : upper_ind ) == match ) then occurrences = occurrences + 1 ; i = i + match_len ; cycle else i = i + 1_int64 ; cycle end if end do end procedure count_substring_chars module procedure count_substring_string integer ( int64 ) :: self_len , match_len , max_pos , upper_ind , i , j integer :: first_char , last_char self_len = self % len64 () match_len = match % len64 () if ( self_len < 1_int64 ) then if ( self_len == match_len ) then occurrences = 1 ; return else occurrences = 0 ; return end if end if if ( ( match_len == 0_int64 ) . or . ( match_len > self_len ) ) then occurrences = 0 ; return end if occurrences = 0 ; max_pos = self_len - match_len + 1_int64 first_char = iachar ( match % s ( 1 : 1 )); last_char = iachar ( match % s ( match_len : match_len )) if ( match_len == 1_int64 ) then i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle else occurrences = occurrences + 1 ; i = i + 1_int64 ; cycle end if end do end if if ( match_len == 2_int64 ) then i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle end if if ( iachar ( self % s ( i + 1_int64 : i + 1_int64 )) /= last_char ) then i = i + 1_int64 ; cycle else occurrences = occurrences + 1 ; i = i + 2_int64 ; cycle end if end do end if i = 1_int64 ; do if ( i > max_pos ) return if ( iachar ( self % s ( i : i )) /= first_char ) then i = i + 1_int64 ; cycle end if upper_ind = i + match_len - 1_int64 if ( iachar ( self % s ( upper_ind : upper_ind )) /= last_char ) then i = i + 1_int64 ; cycle end if if ( self % s ( i : upper_ind ) == match % s ) then occurrences = occurrences + 1 ; i = i + match_len ; cycle else i = i + 1_int64 ; cycle end if end do end procedure count_substring_string module procedure empty self % s = EMPTY_STR end procedure empty module procedure join_into_self type ( String ), dimension ( 2 ) :: token_pair character ( len = :), allocatable :: separator_ integer ( int64 ) :: num_tokens type ( String ) :: comp logical :: GCC num_tokens = size ( tokens , kind = int64 ) if ( num_tokens == 1_int64 ) then if ( tokens ( 1_int64 )% len64 () < 1_int64 ) then self % s = EMPTY_STR ; return else self % s = tokens ( 1_int64 )% s ; return end if end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if comp = String ( COMPILER ); GCC = ( comp % count ( match = 'GCC' ) > 0 ); deallocate ( comp % s ) if ( num_tokens > 500_int64 ) then if ( GCC ) then call self % join ( tokens = [ join ( tokens (: num_tokens / 2_int64 ), separator_ ), & join ( tokens ( 1_int64 + num_tokens / 2_int64 :), separator_ ) ], separator = separator_ ) else call token_pair ( 1 )% join ( tokens (: num_tokens / 2_int64 ), separator_ ) call token_pair ( 2 )% join ( tokens ( 1_int64 + num_tokens / 2_int64 :), separator_ ) call self % join ( tokens = token_pair , separator = separator_ ) end if else call self % join_base ( tokens = tokens , separator = separator_ ) end if end procedure join_into_self module procedure join_base integer ( int64 ), dimension ( size ( tokens , kind = int64 )) :: lengths , cumm_lengths integer ( int64 ) :: num_tokens , sep_len , total_length , pos , i num_tokens = size ( tokens , kind = int64 ) lengths = tokens % len64 () sep_len = len ( separator , kind = int64 ) where ( lengths == - 1_int64 ) lengths = 0_int64 total_length = sum ( lengths ) if ( total_length == 0_int64 ) then self % s = EMPTY_STR ; return end if cumm_lengths ( 1_int64 ) = 1_int64 do concurrent ( i = 2_int64 : num_tokens ) cumm_lengths ( i ) = sum ( lengths (: i - 1_int64 ) ) + 1_int64 end do if ( allocated ( self % s ) ) deallocate ( self % s ) total_length = total_length + ( num_tokens - 1_int64 ) * sep_len allocate ( character ( len = total_length ) :: self % s ) positional_transfer : do concurrent ( i = 1_int64 : num_tokens ) pos = cumm_lengths ( i ) + ( i - 1_int64 ) * sep_len if ( lengths ( i ) > 0_int64 ) then self % s ( pos : pos + lengths ( i ) - 1_int64 ) = tokens ( i )% s if ( sep_len > 0_int64 ) then if ( i < num_tokens ) self % s ( pos + lengths ( i ): pos + lengths ( i ) + sep_len - 1_int64 ) = separator end if else if ( sep_len > 0_int64 ) then if ( i < num_tokens ) self % s ( pos : pos + sep_len - 1_int64 ) = separator end if end if end do positional_transfer end procedure join_base module procedure length if ( . not . allocated ( self % s ) ) then self_len = - 1 else self_len = len ( self % s ) end if end procedure length module procedure length64 if ( . not . allocated ( self % s ) ) then self_len = - 1_int64 else self_len = len ( self % s , kind = int64 ) end if end procedure length64 module procedure push_chars if ( self % len () < 1 ) then self % s = substring else self % s = self % s // substring end if end procedure push_chars module procedure push_string if ( self % len () < 1 ) then if ( substring % len () < 1 ) then self % s = EMPTY_STR else self % s = substring % s end if else if ( substring % len () < 1 ) then return else self % s = self % s // substring % s end if end if end procedure push_string module procedure read_file character ( len = :), allocatable :: ext integer ( int64 ) :: file_length integer :: file_unit , iostat logical :: exists ext = ext_of ( file_name ) if ( . not . any ( TEXT_EXT == ext ) ) then if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\" in method READ_FILE. Binary data ' // & 'cannot be read into a String.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\" in ' // & 'method READ_FILE.' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) end if end if inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if if ( allocated ( self % s ) ) deallocate ( self % s ) allocate ( character ( len = file_length ) :: self % s ) read ( unit = file_unit , iostat = iostat ) self % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if if ( . not . present ( cell_array ) ) then if ( present ( row_separator ) ) then write ( * , '(a)' ) LF // 'WARNING: Row separator was specified in method READ_FILE for file \"' // & file_name // '\" without a cell array output. To use this option, ' // & 'provide an actual argument to cell_array.' end if if ( present ( column_separator ) ) then write ( * , '(a)' ) LF // 'WARNING: Column separator was specified in method READ_FILE for file \"' // & file_name // '\" without a cell array output. To use this option, ' // & 'provide an actual argument to cell_array.' end if return end if if ( present ( row_separator ) ) then if ( len ( row_separator ) == 0 ) then write ( * , '(a)' ) LF // 'WARNING: Cannot populate a cell array with the contents of file \"' // & file_name // '\" using an empty row separator. Returning without cell array...' return end if end if if ( present ( column_separator ) ) then if ( len ( column_separator ) == 0 ) then write ( * , '(a)' ) LF // 'WARNING: Cannot populate a cell array with the contents of file \"' // & file_name // '\" using an empty column separator. Returning without cell array...' return end if end if cell_block : block character ( len = :), allocatable :: row_separator_ , column_separator_ integer ( int64 ) :: n_rows , n_cols , row , col , l , i integer :: row_sep , row_sep_len , col_sep , col_sep_len , quote , current logical :: in_quote if ( . not . present ( row_separator ) ) then row_separator_ = LF else row_separator_ = row_separator end if if ( . not . present ( column_separator ) ) then column_separator_ = COMMA else column_separator_ = column_separator end if row_sep_len = len ( row_separator_ ); col_sep_len = len ( column_separator_ ) row_sep = iachar ( row_separator_ ( 1 : 1 )); col_sep = iachar ( column_separator_ ( 1 : 1 )) quote = iachar ( QQUOTE ); in_quote = . false . n_rows = self % count ( match = row_separator_ ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( self % s ( i : i )) if ( ( current /= quote ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == quote ) then in_quote = (. not . in_quote ); i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_quote ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( self % s ( i : i + col_sep_len - 1_int64 ) == column_separator_ ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then if ( row_sep_len == 1 ) then exit get_n_cols else if ( self % s ( i : i + row_sep_len - 1_int64 ) == row_separator_ ) then exit get_n_cols else i = i + 1_int64 ; cycle end if end if end if end do get_n_cols allocate ( cell_array ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( self % s ( i : i )) if ( ( current /= quote ) . and . ( current /= col_sep ) . and . ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == quote ) then in_quote = (. not . in_quote ); i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_quote ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cell_array ( row , col )% s = self % s ( l : i - 1 ); i = i + 1_int64 ; l = i ; col = col + 1_int64 ; cycle else if ( self % s ( i : i + col_sep_len - 1_int64 ) == column_separator_ ) then cell_array ( row , col )% s = self % s ( l : i - 1 ); i = i + col_sep_len ; l = i ; col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then if ( row_sep_len == 1 ) then cell_array ( row , col )% s = self % s ( l : i - 1 ) if ( row == n_rows ) return i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle else if ( self % s ( i : i + row_sep_len - 1_int64 ) == row_separator_ ) then cell_array ( row , col )% s = self % s ( l : i - 1 ) if ( row == n_rows ) return i = i + row_sep_len ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if end do positional_transfers end block cell_block end procedure read_file module procedure replace_ch_copy integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = len ( match ) substring_len = len ( substring ) if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_ch_copy module procedure replace_st_copy character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = match % len () substring_len = substring % len () if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_st_copy module procedure replace_chst_copy character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = len ( match ) substring_len = substring % len () if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_chst_copy module procedure replace_stch_copy integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = match % len () substring_len = len ( substring ) if ( self_len < 1 ) then new % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) then new % s = self % s ; return end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if end procedure replace_stch_copy module procedure replace_ch_inplace type ( String ) :: new integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = len ( match ) substring_len = len ( substring ) if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_ch_inplace module procedure replace_st_inplace type ( String ) :: new character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = match % len () substring_len = substring % len () if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_st_inplace module procedure replace_chst_inplace type ( String ) :: new character ( len = :), allocatable :: substring_ integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = len ( match ) substring_len = substring % len () if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( substring_len < 1 ) then substring_ = EMPTY_STR else substring_ = substring % s end if if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match ) then new % s = new % s (: i - 1 + diff_len ) // substring_ // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match ) then new % s = new % s (: i - match_len ) // substring_ // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_chst_inplace module procedure replace_stch_inplace type ( String ) :: new integer :: i , self_len , match_len , substring_len , diff_len logical :: back_ self_len = self % len () match_len = match % len () substring_len = len ( substring ) if ( self_len < 1 ) then self % s = EMPTY_STR ; return end if if ( ( match_len < 1 ) . or . ( match_len > self_len ) ) return if ( . not . present ( back ) ) then back_ = . false . else back_ = back end if new % s = self % s if ( . not . back_ ) then i = 1 ; diff_len = 0 match_and_replace_forward : do while ( i <= self_len ) if ( self % s ( i : i ) == match % s ( 1 : 1 ) ) then if ( i + match_len - 1 > self_len ) exit match_and_replace_forward if ( self % s ( i : i + match_len - 1 ) == match % s ) then new % s = new % s (: i - 1 + diff_len ) // substring // new % s ( i + match_len + diff_len :) diff_len = diff_len + ( substring_len - match_len ) i = i + match_len ; cycle match_and_replace_forward else i = i + 1 ; cycle match_and_replace_forward end if else i = i + 1 ; cycle match_and_replace_forward end if end do match_and_replace_forward else i = self_len match_and_replace_backward : do while ( i > 0 ) if ( self % s ( i : i ) == match % s ( match_len : match_len ) ) then if ( i - match_len + 1 < 1 ) exit match_and_replace_backward if ( self % s ( i - match_len + 1 : i ) == match % s ) then new % s = new % s (: i - match_len ) // substring // new % s ( i + 1 :) i = i - match_len ; cycle match_and_replace_backward else i = i - 1 ; cycle match_and_replace_backward end if else i = i - 1 ; cycle match_and_replace_backward end if end do match_and_replace_backward end if self % s = new % s end procedure replace_stch_inplace module procedure trim_copy if ( self % len () < 1 ) then new % s = EMPTY_STR else new % s = trim ( adjustl ( self % s )) end if end procedure trim_copy module procedure trim_inplace if ( self % len () < 1 ) then self % s = EMPTY_STR else self % s = trim ( adjustl ( self % s )) end if end procedure trim_inplace module procedure write_file character ( len = :), allocatable :: ext , row_separator_ , column_separator_ integer ( int64 ), allocatable , dimension (:,:) :: lengths integer ( int64 ) :: n_rows , n_cols , row_sep_len , col_sep_len , total_len , row , col , pos logical :: exists , append_ integer :: file_unit ext = ext_of ( file_name ) if ( . not . any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" in method WRITE_FILE' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) return end if if ( . not . present ( row_separator ) ) then row_separator_ = LF else row_separator_ = row_separator end if if ( . not . present ( column_separator ) ) then column_separator_ = COMMA else column_separator_ = column_separator end if if ( . not . present ( append ) ) then append_ = . false . else append_ = append end if n_rows = size ( cell_array , dim = 1 , kind = int64 ) n_cols = size ( cell_array , dim = 2 , kind = int64 ) row_sep_len = len ( row_separator_ , kind = int64 ) col_sep_len = len ( column_separator_ , kind = int64 ) if ( allocated ( self % s ) ) deallocate ( self % s ) lengths = cell_array % len64 () total_len = sum ( lengths ) + n_rows * row_sep_len + n_rows * ( n_cols - 1_int64 ) * col_sep_len allocate ( character ( len = total_len ) :: self % s ) row = 1_int64 ; col = 1_int64 ; pos = 1_int64 ; positional_transfers : do if ( lengths ( row , col ) > 0_int64 ) then self % s ( pos : pos + lengths ( row , col ) - 1_int64 ) = cell_array ( row , col )% s pos = pos + lengths ( row , col ) end if if ( col < n_cols ) then if ( col_sep_len > 0_int64 ) self % s ( pos : pos + col_sep_len - 1_int64 ) = column_separator_ pos = pos + col_sep_len ; col = col + 1_int64 ; cycle else if ( row_sep_len > 0_int64 ) self % s ( pos : pos + row_sep_len - 1_int64 ) = row_separator_ if ( row < n_rows ) then pos = pos + row_sep_len ; row = row + 1_int64 ; col = 1_int64 ; cycle else exit end if end if end do positional_transfers inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'append' ) end if end if write ( unit = file_unit ) self % s close ( file_unit ) end procedure write_file module procedure write_string if ( substring % len () < 1 ) then write ( unit = unit , fmt = '(a)' , iostat = iostat , iomsg = iomsg ) EMPTY_STR else write ( unit = unit , fmt = '(a)' , iostat = iostat , iomsg = iomsg ) substring % s end if end procedure write_string module procedure scrub if ( allocated ( self % s ) ) deallocate ( self % s ) end procedure scrub end submodule string_methods submodule ( io_fortran_lib ) operators !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interfaces** `operator(//)`, !! `operator(+)`, `operator(-)`, `operator(**)`, `operator(==)`, and `operator(/=)`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains module procedure string_concatenation if ( Stringl % len () < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // Stringr % s end procedure string_concatenation module procedure string_char_concatenation if ( Stringl % len () < 1 ) then if ( len ( charsr ) < 1 ) then new % s = EMPTY_STR ; return else new % s = charsr ; return end if end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // charsr end procedure string_char_concatenation module procedure char_string_concatenation if ( len ( charsl ) < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = charsl ; return end if new % s = charsl // Stringr % s end procedure char_string_concatenation module procedure char_concat_plus new = charsl // charsr end procedure char_concat_plus module procedure string_concat_plus if ( Stringl % len () < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // Stringr % s end procedure string_concat_plus module procedure string_char_concat_plus if ( Stringl % len () < 1 ) then if ( len ( charsr ) < 1 ) then new % s = EMPTY_STR ; return else new % s = charsr ; return end if end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new % s = Stringl % s // charsr end procedure string_char_concat_plus module procedure char_string_concat_plus if ( len ( charsl ) < 1 ) then if ( Stringr % len () < 1 ) then new % s = EMPTY_STR ; return else new % s = Stringr % s ; return end if end if if ( Stringr % len () < 1 ) then new % s = charsl ; return end if new % s = charsl // Stringr % s end procedure char_string_concat_plus module procedure char_excision type ( String ) :: Stringl Stringl % s = charsl if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = charsr , substring = EMPTY_STR ) end procedure char_excision module procedure string_excision if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = Stringr % s , substring = EMPTY_STR ) end procedure string_excision module procedure string_char_excision if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( len ( charsr ) < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = charsr , substring = EMPTY_STR ) end procedure string_char_excision module procedure char_string_excision type ( String ) :: Stringl Stringl % s = charsl if ( Stringl % len () < 1 ) then new % s = EMPTY_STR ; return end if if ( Stringr % len () < 1 ) then new % s = Stringl % s ; return end if new = Stringl % replace ( match = Stringr % s , substring = EMPTY_STR ) end procedure char_string_excision module procedure repeat_chars new = repeat ( char_base , ncopies = ncopies ) end procedure repeat_chars module procedure repeat_String if ( String_base % len () < 1 ) then new % s = EMPTY_STR ; return end if new % s = repeat ( String_base % s , ncopies = ncopies ) end procedure repeat_String module procedure string_equivalence integer :: Stringl_len , Stringr_len Stringl_len = Stringl % len () Stringr_len = Stringr % len () if ( Stringl_len /= Stringr_len ) then equal = . false .; return end if if ( Stringl_len < 1 ) then equal = . true .; return end if equal = ( Stringl % s == Stringr % s ) end procedure string_equivalence module procedure string_char_equivalence integer :: Stringl_len , charsr_len Stringl_len = Stringl % len () charsr_len = len ( charsr ) if ( Stringl_len /= charsr_len ) then equal = . false .; return end if if ( Stringl_len < 1 ) then equal = . true .; return end if equal = ( Stringl % s == charsr ) end procedure string_char_equivalence module procedure char_string_equivalence integer :: charsl_len , Stringr_len charsl_len = len ( charsl ) Stringr_len = Stringr % len () if ( charsl_len /= Stringr_len ) then equal = . false .; return end if if ( charsl_len < 1 ) then equal = . true .; return end if equal = ( charsl == Stringr % s ) end procedure char_string_equivalence module procedure string_nonequivalence integer :: Stringl_len , Stringr_len Stringl_len = Stringl % len () Stringr_len = Stringr % len () if ( Stringl_len /= Stringr_len ) then unequal = . true .; return end if if ( Stringl_len < 1 ) then unequal = . false .; return end if unequal = ( Stringl % s /= Stringr % s ) end procedure string_nonequivalence module procedure string_char_nonequivalence integer :: Stringl_len , charsr_len Stringl_len = Stringl % len () charsr_len = len ( charsr ) if ( Stringl_len /= charsr_len ) then unequal = . true .; return end if if ( Stringl_len < 1 ) then unequal = . false .; return end if unequal = ( Stringl % s /= charsr ) end procedure string_char_nonequivalence module procedure char_string_nonequivalence integer :: charsl_len , Stringr_len charsl_len = len ( charsl ) Stringr_len = Stringr % len () if ( charsl_len /= Stringr_len ) then unequal = . true .; return end if if ( charsl_len < 1 ) then unequal = . false .; return end if unequal = ( charsl /= Stringr % s ) end procedure char_string_nonequivalence end submodule operators submodule ( io_fortran_lib ) internal_io !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interfaces** `String`, `str`, and !! `cast`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) ! Submodule variables ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ integer ( int64 ), parameter :: smallest_int64 = - huge ( 1_int64 ) - 1_int64 integer ( int32 ), parameter :: smallest_int32 = - huge ( 1_int32 ) - 1_int32 integer ( int16 ), parameter :: smallest_int16 = - huge ( 1_int16 ) - 1_int16 integer ( int8 ), parameter :: smallest_int8 = - huge ( 1_int8 ) - 1_int8 integer ( int64 ), parameter :: largest_int64 = huge ( 1_int64 ) integer ( int32 ), parameter :: largest_int32 = huge ( 1_int32 ) integer ( int16 ), parameter :: largest_int16 = huge ( 1_int16 ) integer ( int8 ), parameter :: largest_int8 = huge ( 1_int8 ) integer ( int64 ), dimension ( 0 : 18 ), parameter :: TENS_i64 = int ([ 1 d0 , 1 d1 , 1 d2 , 1 d3 , 1 d4 , 1 d5 , 1 d6 , 1 d7 , 1 d8 , 1 d9 , & 1 d10 , 1 d11 , 1 d12 , 1 d13 , 1 d14 , 1 d15 , 1 d16 , 1 d17 , & 1 d18 ], kind = int64 ) integer ( int32 ), dimension ( 0 : 9 ), parameter :: TENS_i32 = int ([ 1e0 , 1e1 , 1e2 , 1e3 , 1e4 , 1e5 , 1e6 , 1e7 , 1e8 , 1e9 ]) integer ( int16 ), dimension ( 0 : 4 ), parameter :: TENS_i16 = int ([ 1e0 , 1e1 , 1e2 , 1e3 , 1e4 ], kind = int16 ) integer ( int8 ), dimension ( 0 : 2 ), parameter :: TENS_i8 = int ([ 1e0 , 1e1 , 1e2 ], kind = int8 ) integer ( int64 ), dimension ( 0 : 15 ), parameter :: SIXTEENS_i64 = [ 1_int64 , 16_int64 , 16_int64 ** 2 , 16_int64 ** 3 , & 16_int64 ** 4 , 16_int64 ** 5 , 16_int64 ** 6 , 16_int64 ** 7 ,& 16_int64 ** 8 , 16_int64 ** 9 , 16_int64 ** 10 , & 16_int64 ** 11 , 16_int64 ** 12 , 16_int64 ** 13 , & 16_int64 ** 14 , 16_int64 ** 15 ] integer ( int32 ), dimension ( 0 : 7 ), parameter :: SIXTEENS_i32 = [ 1 , 16 , 16 ** 2 , 16 ** 3 , 16 ** 4 , 16 ** 5 , 16 ** 6 , 16 ** 7 ] integer ( int16 ), dimension ( 0 : 3 ), parameter :: SIXTEENS_i16 = [ 1_int16 , 16_int16 , 256_int16 , 4096_int16 ] integer ( int8 ), dimension ( 0 : 1 ), parameter :: SIXTEENS_i8 = [ 1_int8 , 16_int8 ] character ( len = 1 ), dimension ( 0 : 15 ), parameter :: DIGITS_A = [ '0' , '1' , '2' , '3' , '4' , '5' , '6' , '7' , '8' , '9' , & 'a' , 'b' , 'c' , 'd' , 'e' , 'f' ] contains ! String ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure new_string_from_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re /= 0.0_real128 ) then xre_str = '0x00000000000000000000000000000000' else xre_str = '0x0' ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = '(z32)' ) x % re do concurrent ( i = 3 : 34 ) if ( ( xre_str ( i : i ) >= 'A' ) . and . ( xre_str ( i : i ) <= 'F' ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im /= 0.0_real128 ) then xim_str = '0x00000000000000000000000000000000' else xim_str = '0x0' ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = '(z32)' ) x % im do concurrent ( i = 3 : 34 ) if ( ( xim_str ( i : i ) >= 'A' ) . and . ( xim_str ( i : i ) <= 'F' ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real128 ) then xre_str = '0.0e+0000' ; exit if_eorf_re end if if ( x % re < 0.0_real128 ) then xre_str = '00000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es44.35e4)' , decimal = decimal ) x % re xre_str ( 39 : 39 ) = 'e' else xre_str = '0000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es43.35e4)' , decimal = decimal ) x % re xre_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.36)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.100)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real128 ) then xim_str = '0.0e+0000' ; exit if_eorf_im end if if ( x % im < 0.0_real128 ) then xim_str = '00000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es44.35e4)' , decimal = decimal ) x % im xim_str ( 39 : 39 ) = 'e' else xim_str = '0000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es43.35e4)' , decimal = decimal ) x % im xim_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.36)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.100)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then new % s = '(' // xre_str // COMMA // xim_str // ')' ; return else new % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then new % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real128 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // '+' // xim_str // im_ end if end procedure new_string_from_c128 module procedure new_string_from_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real64 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int64 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real64 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int64 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real64 ) then xre_str = '0.0e+000' ; exit if_eorf_re end if if ( x % re < 0.0_real64 ) then xre_str = '0000000000000000000000000' write ( unit = xre_str , fmt = '(es25.17e3)' , decimal = decimal ) x % re xre_str ( 21 : 21 ) = 'e' else xre_str = '000000000000000000000000' write ( unit = xre_str , fmt = '(es24.17e3)' , decimal = decimal ) x % re xre_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.18)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.80)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real64 ) then xim_str = '0.0e+000' ; exit if_eorf_im end if if ( x % im < 0.0_real64 ) then xim_str = '0000000000000000000000000' write ( unit = xim_str , fmt = '(es25.17e3)' , decimal = decimal ) x % im xim_str ( 21 : 21 ) = 'e' else xim_str = '000000000000000000000000' write ( unit = xim_str , fmt = '(es24.17e3)' , decimal = decimal ) x % im xim_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.18)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.80)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then new % s = '(' // xre_str // COMMA // xim_str // ')' ; return else new % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then new % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real64 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // '+' // xim_str // im_ end if end procedure new_string_from_c64 module procedure new_string_from_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real32 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int32 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real32 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int32 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real32 ) then xre_str = '0.0e+00' ; exit if_eorf_re end if if ( x % re < 0.0_real32 ) then xre_str = '000000000000000' write ( unit = xre_str , fmt = '(es15.8e2)' , decimal = decimal ) x % re xre_str ( 12 : 12 ) = 'e' else xre_str = '00000000000000' write ( unit = xre_str , fmt = '(es14.8e2)' , decimal = decimal ) x % re xre_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.9)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.70)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real32 ) then xim_str = '0.0e+00' ; exit if_eorf_im end if if ( x % im < 0.0_real32 ) then xim_str = '000000000000000' write ( unit = xim_str , fmt = '(es15.8e2)' , decimal = decimal ) x % im xim_str ( 12 : 12 ) = 'e' else xim_str = '00000000000000' write ( unit = xim_str , fmt = '(es14.8e2)' , decimal = decimal ) x % im xim_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.9)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.70)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then new % s = '(' // xre_str // COMMA // xim_str // ')' ; return else new % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then new % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real32 ) then new % s = xre_str // xim_str // im_ else new % s = xre_str // '+' // xim_str // im_ end if end procedure new_string_from_c32 module procedure new_string_from_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x /= 0.0_real128 ) then new % s = '0x00000000000000000000000000000000' else new % s = '0x0' ; return end if write ( unit = new % s ( 3 :), fmt = '(z32)' ) x do concurrent ( i = 3 : 34 ) if ( ( new % s ( i : i ) >= 'A' ) . and . ( new % s ( i : i ) <= 'F' ) ) new % s ( i : i ) = achar ( iachar ( new % s ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real128 ) then new % s = '0.0e+0000' ; return end if if ( x < 0.0_real128 ) then new % s = '00000000000000000000000000000000000000000000' write ( unit = new % s , fmt = '(es44.35e4)' , decimal = decimal ) x new % s ( 39 : 39 ) = 'e' else new % s = '0000000000000000000000000000000000000000000' write ( unit = new % s , fmt = '(es43.35e4)' , decimal = decimal ) x new % s ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x ))) else new % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = '(f0.36)' , decimal = decimal ) x else write ( unit = new % s , fmt = '(f0.100)' , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == '-' ) ) ) then new % s ( i + 1 : 125 ) = new % s ( i : 124 ); new % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 36 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 36 - e ) then new % s = new % s (: i + 36 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r128 module procedure new_string_from_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real64 ) then new % s = '0x0' ; return end if inline_cast : block integer ( int64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_int64 ) then num = ( x_int + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 1 :) = '0x0000000000000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real64 ) then new % s = '0.0e+000' ; return end if if ( x < 0.0_real64 ) then new % s = '0000000000000000000000000' write ( unit = new % s , fmt = '(es25.17e3)' , decimal = decimal ) x new % s ( 21 : 21 ) = 'e' else new % s = '000000000000000000000000' write ( unit = new % s , fmt = '(es24.17e3)' , decimal = decimal ) x new % s ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x ))) else new % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = '(f0.18)' , decimal = decimal ) x else write ( unit = new % s , fmt = '(f0.80)' , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == '-' ) ) ) then new % s ( i + 1 : 100 ) = new % s ( i : 99 ); new % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 18 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 18 - e ) then new % s = new % s (: i + 18 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r64 module procedure new_string_from_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real32 ) then new % s = '0x0' ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_int32 ; negative = . true .; buffer ( 1 :) = '0x00000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real32 ) then new % s = '0.0e+00' ; return end if if ( x < 0.0_real32 ) then new % s = '000000000000000' write ( unit = new % s , fmt = '(es15.8e2)' , decimal = decimal ) x new % s ( 12 : 12 ) = 'e' else new % s = '00000000000000' write ( unit = new % s , fmt = '(es14.8e2)' , decimal = decimal ) x new % s ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) then new % s = new % s (: i + decimals_ ) // new % s ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x ))) else new % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: new % s ) if ( e > 0 ) then write ( unit = new % s , fmt = '(f0.9)' , decimal = decimal ) x else write ( unit = new % s , fmt = '(f0.70)' , decimal = decimal ) x end if i = 1 ; do if ( ( new % s ( i : i ) == POINT ) . or . ( new % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( new % s ( 1 : 1 ) == '-' ) ) ) then new % s ( i + 1 : 75 ) = new % s ( i : 74 ); new % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then new % s = new % s (: i ); return end if if ( . not . present ( decimals ) ) then new % s = new % s (: i + 9 - e ); return end if if ( decimals <= 0 ) then new % s = new % s (: i ); return end if if ( decimals >= 9 - e ) then new % s = new % s (: i + 9 - e ); return end if new % s = new % s (: i + decimals ); return end if end procedure new_string_from_r32 module procedure new_string_from_i64 character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( int64 ) :: num , next integer :: ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int64 ) then if ( x == smallest_int64 ) then new % s = '-9223372036854775808' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_int64 ; buffer ( i : i ) = achar ( num - 10_int64 * next + 48_int64 ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_int64 ) then num = ( x + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 3 :) = '0x0000000000000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i64 module procedure new_string_from_i32 character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0 ) then if ( x == smallest_int32 ) then new % s = '-2147483648' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_int32 ; negative = . true .; buffer ( 2 :) = '0x00000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i32 module procedure new_string_from_i16 character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int16 ) then if ( x == smallest_int16 ) then new % s = '-32768' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_int16 ) then num = int (( x + 1_int16 ) + largest_int16 ); negative = . true .; buffer ( 1 :) = '0x0000' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i16 module procedure new_string_from_i8 character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else new % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int8 ) then if ( x == smallest_int8 ) then new % s = '-128' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; new % s = buffer ( i - 1 :); return else new % s = buffer ( i :); return end if else if ( x < 0_int8 ) then num = int (( x + 1_int8 ) + largest_int8 ); negative = . true .; buffer ( 1 :) = '0x00' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if new % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; new % s = buffer ( i - 2 :); return end if end if end procedure new_string_from_i8 module procedure new_string_from_string if ( x % len () < 1 ) then new % s = EMPTY_STR else new % s = x % s end if end procedure new_string_from_string module procedure new_string_from_char new % s = x end procedure new_string_from_char module procedure new_string_from_empty new % s = EMPTY_STR end procedure new_string_from_empty ! str ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure str_from_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re /= 0.0_real128 ) then xre_str = '0x00000000000000000000000000000000' else xre_str = '0x0' ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = '(z32)' ) x % re do concurrent ( i = 3 : 34 ) if ( ( xre_str ( i : i ) >= 'A' ) . and . ( xre_str ( i : i ) <= 'F' ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im /= 0.0_real128 ) then xim_str = '0x00000000000000000000000000000000' else xim_str = '0x0' ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = '(z32)' ) x % im do concurrent ( i = 3 : 34 ) if ( ( xim_str ( i : i ) >= 'A' ) . and . ( xim_str ( i : i ) <= 'F' ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real128 ) then xre_str = '0.0e+0000' ; exit if_eorf_re end if if ( x % re < 0.0_real128 ) then xre_str = '00000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es44.35e4)' , decimal = decimal ) x % re xre_str ( 39 : 39 ) = 'e' else xre_str = '0000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es43.35e4)' , decimal = decimal ) x % re xre_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.36)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.100)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real128 ) then xim_str = '0.0e+0000' ; exit if_eorf_im end if if ( x % im < 0.0_real128 ) then xim_str = '00000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es44.35e4)' , decimal = decimal ) x % im xim_str ( 39 : 39 ) = 'e' else xim_str = '0000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es43.35e4)' , decimal = decimal ) x % im xim_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.36)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.100)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then x_str = '(' // xre_str // COMMA // xim_str // ')' ; return else x_str = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then x_str = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real128 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // '+' // xim_str // im_ end if end procedure str_from_c128 module procedure str_from_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real64 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int64 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real64 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int64 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real64 ) then xre_str = '0.0e+000' ; exit if_eorf_re end if if ( x % re < 0.0_real64 ) then xre_str = '0000000000000000000000000' write ( unit = xre_str , fmt = '(es25.17e3)' , decimal = decimal ) x % re xre_str ( 21 : 21 ) = 'e' else xre_str = '000000000000000000000000' write ( unit = xre_str , fmt = '(es24.17e3)' , decimal = decimal ) x % re xre_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.18)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.80)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real64 ) then xim_str = '0.0e+000' ; exit if_eorf_im end if if ( x % im < 0.0_real64 ) then xim_str = '0000000000000000000000000' write ( unit = xim_str , fmt = '(es25.17e3)' , decimal = decimal ) x % im xim_str ( 21 : 21 ) = 'e' else xim_str = '000000000000000000000000' write ( unit = xim_str , fmt = '(es24.17e3)' , decimal = decimal ) x % im xim_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.18)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.80)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then x_str = '(' // xre_str // COMMA // xim_str // ')' ; return else x_str = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then x_str = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real64 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // '+' // xim_str // im_ end if end procedure str_from_c64 module procedure str_from_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real32 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int32 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real32 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int32 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real32 ) then xre_str = '0.0e+00' ; exit if_eorf_re end if if ( x % re < 0.0_real32 ) then xre_str = '000000000000000' write ( unit = xre_str , fmt = '(es15.8e2)' , decimal = decimal ) x % re xre_str ( 12 : 12 ) = 'e' else xre_str = '00000000000000' write ( unit = xre_str , fmt = '(es14.8e2)' , decimal = decimal ) x % re xre_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.9)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.70)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real32 ) then xim_str = '0.0e+00' ; exit if_eorf_im end if if ( x % im < 0.0_real32 ) then xim_str = '000000000000000' write ( unit = xim_str , fmt = '(es15.8e2)' , decimal = decimal ) x % im xim_str ( 12 : 12 ) = 'e' else xim_str = '00000000000000' write ( unit = xim_str , fmt = '(es14.8e2)' , decimal = decimal ) x % im xim_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.9)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.70)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then x_str = '(' // xre_str // COMMA // xim_str // ')' ; return else x_str = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then x_str = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real32 ) then x_str = xre_str // xim_str // im_ else x_str = xre_str // '+' // xim_str // im_ end if end procedure str_from_c32 module procedure str_from_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x /= 0.0_real128 ) then x_str = '0x00000000000000000000000000000000' else x_str = '0x0' ; return end if write ( unit = x_str ( 3 :), fmt = '(z32)' ) x do concurrent ( i = 3 : 34 ) if ( ( x_str ( i : i ) >= 'A' ) . and . ( x_str ( i : i ) <= 'F' ) ) x_str ( i : i ) = achar ( iachar ( x_str ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real128 ) then x_str = '0.0e+0000' ; return end if if ( x < 0.0_real128 ) then x_str = '00000000000000000000000000000000000000000000' write ( unit = x_str , fmt = '(es44.35e4)' , decimal = decimal ) x x_str ( 39 : 39 ) = 'e' else x_str = '0000000000000000000000000000000000000000000' write ( unit = x_str , fmt = '(es43.35e4)' , decimal = decimal ) x x_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x ))) else x_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = '(f0.36)' , decimal = decimal ) x else write ( unit = x_str , fmt = '(f0.100)' , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == '-' ) ) ) then x_str ( i + 1 : 125 ) = x_str ( i : 124 ); x_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 36 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 36 - e ) then x_str = x_str (: i + 36 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r128 module procedure str_from_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real64 ) then x_str = '0x0' ; return end if call cast ( transfer ( source = x , mold = 1_int64 ), into = x_str , fmt = 'z' ); return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real64 ) then x_str = '0.0e+000' ; return end if if ( x < 0.0_real64 ) then x_str = '0000000000000000000000000' write ( unit = x_str , fmt = '(es25.17e3)' , decimal = decimal ) x x_str ( 21 : 21 ) = 'e' else x_str = '000000000000000000000000' write ( unit = x_str , fmt = '(es24.17e3)' , decimal = decimal ) x x_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x ))) else x_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = '(f0.18)' , decimal = decimal ) x else write ( unit = x_str , fmt = '(f0.80)' , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == '-' ) ) ) then x_str ( i + 1 : 100 ) = x_str ( i : 99 ); x_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 18 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 18 - e ) then x_str = x_str (: i + 18 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r64 module procedure str_from_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real32 ) then x_str = '0x0' ; return end if call cast ( transfer ( source = x , mold = 1_int32 ), into = x_str , fmt = 'z' ); return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real32 ) then x_str = '0.0e+00' ; return end if if ( x < 0.0_real32 ) then x_str = '000000000000000' write ( unit = x_str , fmt = '(es15.8e2)' , decimal = decimal ) x x_str ( 12 : 12 ) = 'e' else x_str = '00000000000000' write ( unit = x_str , fmt = '(es14.8e2)' , decimal = decimal ) x x_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) then x_str = x_str (: i + decimals_ ) // x_str ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x ))) else x_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: x_str ) if ( e > 0 ) then write ( unit = x_str , fmt = '(f0.9)' , decimal = decimal ) x else write ( unit = x_str , fmt = '(f0.70)' , decimal = decimal ) x end if i = 1 ; do if ( ( x_str ( i : i ) == POINT ) . or . ( x_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( x_str ( 1 : 1 ) == '-' ) ) ) then x_str ( i + 1 : 75 ) = x_str ( i : 74 ); x_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then x_str = x_str (: i ); return end if if ( . not . present ( decimals ) ) then x_str = x_str (: i + 9 - e ); return end if if ( decimals <= 0 ) then x_str = x_str (: i ); return end if if ( decimals >= 9 - e ) then x_str = x_str (: i + 9 - e ); return end if x_str = x_str (: i + decimals ); return end if end procedure str_from_r32 module procedure str_from_i64 character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( int64 ) :: num , next integer :: ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int64 ) then if ( x == smallest_int64 ) then x_str = '-9223372036854775808' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_int64 ; buffer ( i : i ) = achar ( num - 10_int64 * next + 48_int64 ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_int64 ) then num = ( x + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 3 :) = '0x0000000000000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i64 module procedure str_from_i32 character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( ( any ( INT_FMTS == fmt )) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0 ) then if ( x == smallest_int32 ) then x_str = '-2147483648' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_int32 ; negative = . true .; buffer ( 2 :) = '0x00000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i32 module procedure str_from_i16 character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int16 ) then if ( x == smallest_int16 ) then x_str = '-32768' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_int16 ) then num = int (( x + 1_int16 ) + largest_int16 ); negative = . true .; buffer ( 1 :) = '0x0000' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i16 module procedure str_from_i8 character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else x_str = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int8 ) then if ( x == smallest_int8 ) then x_str = '-128' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; x_str = buffer ( i - 1 :); return else x_str = buffer ( i :); return end if else if ( x < 0_int8 ) then num = int (( x + 1_int8 ) + largest_int8 ); negative = . true .; buffer ( 1 :) = '0x00' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if x_str = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; x_str = buffer ( i - 2 :); return end if end if end procedure str_from_i8 module procedure str_from_string if ( x % len () < 1 ) then x_str = EMPTY_STR else x_str = x % s end if end procedure str_from_string module procedure str_from_char x_str = x end procedure str_from_char module procedure str_from_empty x_str = EMPTY_STR end procedure str_from_empty ! cast ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure cast_c128_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re /= 0.0_real128 ) then xre_str = '0x00000000000000000000000000000000' else xre_str = '0x0' ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = '(z32)' ) x % re do concurrent ( i = 3 : 34 ) if ( ( xre_str ( i : i ) >= 'A' ) . and . ( xre_str ( i : i ) <= 'F' ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im /= 0.0_real128 ) then xim_str = '0x00000000000000000000000000000000' else xim_str = '0x0' ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = '(z32)' ) x % im do concurrent ( i = 3 : 34 ) if ( ( xim_str ( i : i ) >= 'A' ) . and . ( xim_str ( i : i ) <= 'F' ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real128 ) then xre_str = '0.0e+0000' ; exit if_eorf_re end if if ( x % re < 0.0_real128 ) then xre_str = '00000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es44.35e4)' , decimal = decimal ) x % re xre_str ( 39 : 39 ) = 'e' else xre_str = '0000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es43.35e4)' , decimal = decimal ) x % re xre_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.36)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.100)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real128 ) then xim_str = '0.0e+0000' ; exit if_eorf_im end if if ( x % im < 0.0_real128 ) then xim_str = '00000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es44.35e4)' , decimal = decimal ) x % im xim_str ( 39 : 39 ) = 'e' else xim_str = '0000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es43.35e4)' , decimal = decimal ) x % im xim_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.36)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.100)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into % s = '(' // xre_str // COMMA // xim_str // ')' ; return else into % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real128 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // '+' // xim_str // im_ end if end procedure cast_c128_to_string module procedure cast_c64_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real64 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int64 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real64 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int64 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real64 ) then xre_str = '0.0e+000' ; exit if_eorf_re end if if ( x % re < 0.0_real64 ) then xre_str = '0000000000000000000000000' write ( unit = xre_str , fmt = '(es25.17e3)' , decimal = decimal ) x % re xre_str ( 21 : 21 ) = 'e' else xre_str = '000000000000000000000000' write ( unit = xre_str , fmt = '(es24.17e3)' , decimal = decimal ) x % re xre_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.18)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.80)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real64 ) then xim_str = '0.0e+000' ; exit if_eorf_im end if if ( x % im < 0.0_real64 ) then xim_str = '0000000000000000000000000' write ( unit = xim_str , fmt = '(es25.17e3)' , decimal = decimal ) x % im xim_str ( 21 : 21 ) = 'e' else xim_str = '000000000000000000000000' write ( unit = xim_str , fmt = '(es24.17e3)' , decimal = decimal ) x % im xim_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.18)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.80)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into % s = '(' // xre_str // COMMA // xim_str // ')' ; return else into % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real64 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // '+' // xim_str // im_ end if end procedure cast_c64_to_string module procedure cast_c32_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real32 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int32 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real32 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int32 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real32 ) then xre_str = '0.0e+00' ; exit if_eorf_re end if if ( x % re < 0.0_real32 ) then xre_str = '000000000000000' write ( unit = xre_str , fmt = '(es15.8e2)' , decimal = decimal ) x % re xre_str ( 12 : 12 ) = 'e' else xre_str = '00000000000000' write ( unit = xre_str , fmt = '(es14.8e2)' , decimal = decimal ) x % re xre_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.9)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.70)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real32 ) then xim_str = '0.0e+00' ; exit if_eorf_im end if if ( x % im < 0.0_real32 ) then xim_str = '000000000000000' write ( unit = xim_str , fmt = '(es15.8e2)' , decimal = decimal ) x % im xim_str ( 12 : 12 ) = 'e' else xim_str = '00000000000000' write ( unit = xim_str , fmt = '(es14.8e2)' , decimal = decimal ) x % im xim_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.9)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.70)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into % s = '(' // xre_str // COMMA // xim_str // ')' ; return else into % s = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into % s = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real32 ) then into % s = xre_str // xim_str // im_ else into % s = xre_str // '+' // xim_str // im_ end if end procedure cast_c32_to_string module procedure cast_r128_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x /= 0.0_real128 ) then into % s = '0x00000000000000000000000000000000' else into % s = '0x0' ; return end if write ( unit = into % s ( 3 :), fmt = '(z32)' ) x do concurrent ( i = 3 : 34 ) if ( ( into % s ( i : i ) >= 'A' ) . and . ( into % s ( i : i ) <= 'F' ) ) into % s ( i : i ) = achar ( iachar ( into % s ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real128 ) then into % s = '0.0e+0000' ; return end if if ( x < 0.0_real128 ) then into % s = '00000000000000000000000000000000000000000000' write ( unit = into % s , fmt = '(es44.35e4)' , decimal = decimal ) x into % s ( 39 : 39 ) = 'e' else into % s = '0000000000000000000000000000000000000000000' write ( unit = into % s , fmt = '(es43.35e4)' , decimal = decimal ) x into % s ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x ))) else into % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 125 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = '(f0.36)' , decimal = decimal ) x else write ( unit = into % s , fmt = '(f0.100)' , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == '-' ) ) ) then into % s ( i + 1 : 125 ) = into % s ( i : 124 ); into % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 36 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 36 - e ) then into % s = into % s (: i + 36 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r128_to_string module procedure cast_r64_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real64 ) then into % s = '0x0' ; return end if inline_cast : block integer ( int64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_int64 ) then num = ( x_int + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 1 :) = '0x0000000000000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real64 ) then into % s = '0.0e+000' ; return end if if ( x < 0.0_real64 ) then into % s = '0000000000000000000000000' write ( unit = into % s , fmt = '(es25.17e3)' , decimal = decimal ) x into % s ( 21 : 21 ) = 'e' else into % s = '000000000000000000000000' write ( unit = into % s , fmt = '(es24.17e3)' , decimal = decimal ) x into % s ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x ))) else into % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 100 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = '(f0.18)' , decimal = decimal ) x else write ( unit = into % s , fmt = '(f0.80)' , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == '-' ) ) ) then into % s ( i + 1 : 100 ) = into % s ( i : 99 ); into % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 18 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 18 - e ) then into % s = into % s (: i + 18 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r64_to_string module procedure cast_r32_to_string character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real32 ) then into % s = '0x0' ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_int32 ; negative = . true .; buffer ( 1 :) = '0x00000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real32 ) then into % s = '0.0e+00' ; return end if if ( x < 0.0_real32 ) then into % s = '000000000000000' write ( unit = into % s , fmt = '(es15.8e2)' , decimal = decimal ) x into % s ( 12 : 12 ) = 'e' else into % s = '00000000000000' write ( unit = into % s , fmt = '(es14.8e2)' , decimal = decimal ) x into % s ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) then into % s = into % s (: i + decimals_ ) // into % s ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x ))) else into % s = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into % s ) ) deallocate ( into % s ) allocate ( character ( len = 75 ) :: into % s ) if ( e > 0 ) then write ( unit = into % s , fmt = '(f0.9)' , decimal = decimal ) x else write ( unit = into % s , fmt = '(f0.70)' , decimal = decimal ) x end if i = 1 ; do if ( ( into % s ( i : i ) == POINT ) . or . ( into % s ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into % s ( 1 : 1 ) == '-' ) ) ) then into % s ( i + 1 : 75 ) = into % s ( i : 74 ); into % s ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then into % s = into % s (: i ); return end if if ( . not . present ( decimals ) ) then into % s = into % s (: i + 9 - e ); return end if if ( decimals <= 0 ) then into % s = into % s (: i ); return end if if ( decimals >= 9 - e ) then into % s = into % s (: i + 9 - e ); return end if into % s = into % s (: i + decimals ); return end if end procedure cast_r32_to_string module procedure cast_i64_to_string character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( int64 ) :: num , next integer :: ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int64 ) then if ( x == smallest_int64 ) then into % s = '-9223372036854775808' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_int64 ; buffer ( i : i ) = achar ( num - 10_int64 * next + 48_int64 ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_int64 ) then num = ( x + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 3 :) = '0x0000000000000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i64_to_string module procedure cast_i32_to_string character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0 ) then if ( x == smallest_int32 ) then into % s = '-2147483648' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_int32 ; negative = . true .; buffer ( 2 :) = '0x00000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i32_to_string module procedure cast_i16_to_string character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int16 ) then if ( x == smallest_int16 ) then into % s = '-32768' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_int16 ) then num = int (( x + 1_int16 ) + largest_int16 ); negative = . true .; buffer ( 1 :) = '0x0000' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i16_to_string module procedure cast_i8_to_string character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into % s = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int8 ) then if ( x == smallest_int8 ) then into % s = '-128' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into % s = buffer ( i - 1 :); return else into % s = buffer ( i :); return end if else if ( x < 0_int8 ) then num = int (( x + 1_int8 ) + largest_int8 ); negative = . true .; buffer ( 1 :) = '0x00' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into % s = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into % s = buffer ( i - 2 :); return end if end if end procedure cast_i8_to_string module procedure cast_c128_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re /= 0.0_real128 ) then xre_str = '0x00000000000000000000000000000000' else xre_str = '0x0' ; exit if_z_re end if write ( unit = xre_str ( 3 :), fmt = '(z32)' ) x % re do concurrent ( i = 3 : 34 ) if ( ( xre_str ( i : i ) >= 'A' ) . and . ( xre_str ( i : i ) <= 'F' ) ) xre_str ( i : i ) = achar ( iachar ( xre_str ( i : i )) + 32 ) end do end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im /= 0.0_real128 ) then xim_str = '0x00000000000000000000000000000000' else xim_str = '0x0' ; exit if_z_im end if write ( unit = xim_str ( 3 :), fmt = '(z32)' ) x % im do concurrent ( i = 3 : 34 ) if ( ( xim_str ( i : i ) >= 'A' ) . and . ( xim_str ( i : i ) <= 'F' ) ) xim_str ( i : i ) = achar ( iachar ( xim_str ( i : i )) + 32 ) end do end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real128 ) then xre_str = '0.0e+0000' ; exit if_eorf_re end if if ( x % re < 0.0_real128 ) then xre_str = '00000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es44.35e4)' , decimal = decimal ) x % re xre_str ( 39 : 39 ) = 'e' else xre_str = '0000000000000000000000000000000000000000000' write ( unit = xre_str , fmt = '(es43.35e4)' , decimal = decimal ) x % re xre_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 35 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 36 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.36)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.100)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 125 ) = xre_str ( i : 124 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 36 - e ) then xre_str = xre_str (: i + 36 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real128 ) then xim_str = '0.0e+0000' ; exit if_eorf_im end if if ( x % im < 0.0_real128 ) then xim_str = '00000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es44.35e4)' , decimal = decimal ) x % im xim_str ( 39 : 39 ) = 'e' else xim_str = '0000000000000000000000000000000000000000000' write ( unit = xim_str , fmt = '(es43.35e4)' , decimal = decimal ) x % im xim_str ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 35 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 36 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 125 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.36)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.100)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 125 ) = xim_str ( i : 124 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 36 - e ) then xim_str = xim_str (: i + 36 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into = '(' // xre_str // COMMA // xim_str // ')' ; return else into = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real128 ) then into = xre_str // xim_str // im_ else into = xre_str // '+' // xim_str // im_ end if end procedure cast_c128_to_char module procedure cast_c64_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real64 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int64 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real64 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int64 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real64 ) then xre_str = '0.0e+000' ; exit if_eorf_re end if if ( x % re < 0.0_real64 ) then xre_str = '0000000000000000000000000' write ( unit = xre_str , fmt = '(es25.17e3)' , decimal = decimal ) x % re xre_str ( 21 : 21 ) = 'e' else xre_str = '000000000000000000000000' write ( unit = xre_str , fmt = '(es24.17e3)' , decimal = decimal ) x % re xre_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 17 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 18 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.18)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.80)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 100 ) = xre_str ( i : 99 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 18 - e ) then xre_str = xre_str (: i + 18 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real64 ) then xim_str = '0.0e+000' ; exit if_eorf_im end if if ( x % im < 0.0_real64 ) then xim_str = '0000000000000000000000000' write ( unit = xim_str , fmt = '(es25.17e3)' , decimal = decimal ) x % im xim_str ( 21 : 21 ) = 'e' else xim_str = '000000000000000000000000' write ( unit = xim_str , fmt = '(es24.17e3)' , decimal = decimal ) x % im xim_str ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 17 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 18 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 100 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.18)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.80)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 100 ) = xim_str ( i : 99 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 18 - e ) then xim_str = xim_str (: i + 18 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into = '(' // xre_str // COMMA // xim_str // ')' ; return else into = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real64 ) then into = xre_str // xim_str // im_ else into = xre_str // '+' // xim_str // im_ end if end procedure cast_c64_to_char module procedure cast_c32_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: xre_str , xim_str , im_ integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if_z_re : if ( fmt_ == 'z' ) then if ( x % re == 0.0_real32 ) then xre_str = '0x0' ; exit if_z_re end if call cast ( transfer ( source = x % re , mold = 1_int32 ), into = xre_str , fmt = 'z' ); exit if_z_re end if if_z_re if_z_im : if ( fmt_ == 'z' ) then if ( x % im == 0.0_real32 ) then xim_str = '0x0' ; exit if_z_im end if call cast ( transfer ( source = x % im , mold = 1_int32 ), into = xim_str , fmt = 'z' ); exit if_z_im end if if_z_im if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if_eorf_re : if ( fmt_ == 'e' ) then if ( x % re == 0.0_real32 ) then xre_str = '0.0e+00' ; exit if_eorf_re end if if ( x % re < 0.0_real32 ) then xre_str = '000000000000000' write ( unit = xre_str , fmt = '(es15.8e2)' , decimal = decimal ) x % re xre_str ( 12 : 12 ) = 'e' else xre_str = '00000000000000' write ( unit = xre_str , fmt = '(es14.8e2)' , decimal = decimal ) x % re xre_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_re if ( decimals >= 8 ) exit if_eorf_re if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) then xre_str = xre_str (: i + decimals_ ) // xre_str ( i + 9 :); exit if_eorf_re end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % re ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % re ))) else xre_str = '0.0' ; exit if_eorf_re end if if ( e == 0 ) then if ( floor ( x % re ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xre_str ) if ( e > 0 ) then write ( unit = xre_str , fmt = '(f0.9)' , decimal = decimal ) x % re else write ( unit = xre_str , fmt = '(f0.70)' , decimal = decimal ) x % re end if i = 1 ; do if ( ( xre_str ( i : i ) == POINT ) . or . ( xre_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xre_str ( 1 : 1 ) == '-' ) ) ) then xre_str ( i + 1 : 75 ) = xre_str ( i : 74 ); xre_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( . not . present ( decimals ) ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if if ( decimals <= 0 ) then xre_str = xre_str (: i ); exit if_eorf_re end if if ( decimals >= 9 - e ) then xre_str = xre_str (: i + 9 - e ); exit if_eorf_re end if xre_str = xre_str (: i + decimals ); exit if_eorf_re end if if_eorf_re if_eorf_im : if ( fmt_ == 'e' ) then if ( x % im == 0.0_real32 ) then xim_str = '0.0e+00' ; exit if_eorf_im end if if ( x % im < 0.0_real32 ) then xim_str = '000000000000000' write ( unit = xim_str , fmt = '(es15.8e2)' , decimal = decimal ) x % im xim_str ( 12 : 12 ) = 'e' else xim_str = '00000000000000' write ( unit = xim_str , fmt = '(es14.8e2)' , decimal = decimal ) x % im xim_str ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) exit if_eorf_im if ( decimals >= 8 ) exit if_eorf_im if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) then xim_str = xim_str (: i + decimals_ ) // xim_str ( i + 9 :); exit if_eorf_im end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x % im ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x % im ))) else xim_str = '0.0' ; exit if_eorf_im end if if ( e == 0 ) then if ( floor ( x % im ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if allocate ( character ( len = 75 ) :: xim_str ) if ( e > 0 ) then write ( unit = xim_str , fmt = '(f0.9)' , decimal = decimal ) x % im else write ( unit = xim_str , fmt = '(f0.70)' , decimal = decimal ) x % im end if i = 1 ; do if ( ( xim_str ( i : i ) == POINT ) . or . ( xim_str ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( xim_str ( 1 : 1 ) == '-' ) ) ) then xim_str ( i + 1 : 75 ) = xim_str ( i : 74 ); xim_str ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( . not . present ( decimals ) ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if if ( decimals <= 0 ) then xim_str = xim_str (: i ); exit if_eorf_im end if if ( decimals >= 9 - e ) then xim_str = xim_str (: i + 9 - e ); exit if_eorf_im end if xim_str = xim_str (: i + decimals ); exit if_eorf_im end if if_eorf_im if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( im_ == EMPTY_STR ) then if ( decimal == 'POINT' ) then into = '(' // xre_str // COMMA // xim_str // ')' ; return else into = '(' // xre_str // SEMICOLON // xim_str // ')' ; return end if end if if ( fmt_ == 'z' ) then into = xre_str // '+' // xim_str // im_ ; return end if if ( x % im < 0.0_real32 ) then into = xre_str // xim_str // im_ else into = xre_str // '+' // xim_str // im_ end if end procedure cast_c32_to_char module procedure cast_r128_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x /= 0.0_real128 ) then into = '0x00000000000000000000000000000000' else into = '0x0' ; return end if write ( unit = into ( 3 :), fmt = '(z32)' ) x do concurrent ( i = 3 : 34 ) if ( ( into ( i : i ) >= 'A' ) . and . ( into ( i : i ) <= 'F' ) ) into ( i : i ) = achar ( iachar ( into ( i : i )) + 32 ) end do return end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real128 ) then into = '0.0e+0000' ; return end if if ( x < 0.0_real128 ) then into = '00000000000000000000000000000000000000000000' write ( unit = into , fmt = '(es44.35e4)' , decimal = decimal ) x into ( 39 : 39 ) = 'e' else into = '0000000000000000000000000000000000000000000' write ( unit = into , fmt = '(es43.35e4)' , decimal = decimal ) x into ( 38 : 38 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 35 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 36 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real128 ) then e = int ( log10 ( abs ( x ))) else into = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 125 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = '(f0.36)' , decimal = decimal ) x else write ( unit = into , fmt = '(f0.100)' , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == '-' ) ) ) then into ( i + 1 : 125 ) = into ( i : 124 ); into ( i : i ) = '0' ; i = i + 1 end if if ( i > 36 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 36 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 36 - e ) then into = into (: i + 36 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r128_to_char module procedure cast_r64_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real64 ) then into = '0x0' ; return end if inline_cast : block integer ( int64 ) :: x_int , num , next ; character ( len = 18 ) :: buffer ; integer :: ascii_code logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0_int64 ) then num = ( x_int + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 1 :) = '0x0000000000000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real64 ) then into = '0.0e+000' ; return end if if ( x < 0.0_real64 ) then into = '0000000000000000000000000' write ( unit = into , fmt = '(es25.17e3)' , decimal = decimal ) x into ( 21 : 21 ) = 'e' else into = '000000000000000000000000' write ( unit = into , fmt = '(es24.17e3)' , decimal = decimal ) x into ( 20 : 20 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 17 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 18 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real64 ) then e = int ( log10 ( abs ( x ))) else into = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 100 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = '(f0.18)' , decimal = decimal ) x else write ( unit = into , fmt = '(f0.80)' , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == '-' ) ) ) then into ( i + 1 : 100 ) = into ( i : 99 ); into ( i : i ) = '0' ; i = i + 1 end if if ( i > 18 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 18 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 18 - e ) then into = into (: i + 18 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r64_to_char module procedure cast_r32_to_char character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal integer :: e , decimals_ , i if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'z' ) then if ( x == 0.0_real32 ) then into = '0x0' ; return end if inline_cast : block integer :: x_int , num , next ; character ( len = 10 ) :: buffer ; integer :: ascii_code ; logical :: negative x_int = transfer ( source = x , mold = x_int ) if ( x_int < 0 ) then num = ( x_int + 1 ) + largest_int32 ; negative = . true .; buffer ( 1 :) = '0x00000000' else num = x_int ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = EMPTY_STR ; return end if end if if ( fmt_ == 'e' ) then if ( x == 0.0_real32 ) then into = '0.0e+00' ; return end if if ( x < 0.0_real32 ) then into = '000000000000000' write ( unit = into , fmt = '(es15.8e2)' , decimal = decimal ) x into ( 12 : 12 ) = 'e' else into = '00000000000000' write ( unit = into , fmt = '(es14.8e2)' , decimal = decimal ) x into ( 11 : 11 ) = 'e' end if if ( . not . present ( decimals ) ) return if ( decimals >= 8 ) return if ( decimals < 0 ) then decimals_ = 0 else decimals_ = decimals end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) then into = into (: i + decimals_ ) // into ( i + 9 :); return end if i = i + 1 ; cycle end do else if ( fmt_ == 'f' ) then if ( abs ( x ) /= 0.0_real32 ) then e = int ( log10 ( abs ( x ))) else into = '0.0' ; return end if if ( e == 0 ) then if ( floor ( x ) > 0 ) e = 1 + e else if ( e > 0 ) then e = 1 + e end if if ( allocated ( into ) ) deallocate ( into ) allocate ( character ( len = 75 ) :: into ) if ( e > 0 ) then write ( unit = into , fmt = '(f0.9)' , decimal = decimal ) x else write ( unit = into , fmt = '(f0.70)' , decimal = decimal ) x end if i = 1 ; do if ( ( into ( i : i ) == POINT ) . or . ( into ( i : i ) == COMMA ) ) exit i = i + 1 ; cycle end do if ( ( i == 1 ) . or . ( ( i == 2 ) . and . ( into ( 1 : 1 ) == '-' ) ) ) then into ( i + 1 : 75 ) = into ( i : 74 ); into ( i : i ) = '0' ; i = i + 1 end if if ( i > 9 ) then into = into (: i ); return end if if ( . not . present ( decimals ) ) then into = into (: i + 9 - e ); return end if if ( decimals <= 0 ) then into = into (: i ); return end if if ( decimals >= 9 - e ) then into = into (: i + 9 - e ); return end if into = into (: i + decimals ); return end if end procedure cast_r32_to_char module procedure cast_i64_to_char character ( len = 1 ) :: fmt_ character ( len = 20 ) :: buffer integer ( int64 ) :: num , next integer :: ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int64 ) then if ( x == smallest_int64 ) then into = '-9223372036854775808' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10_int64 ; buffer ( i : i ) = achar ( num - 10_int64 * next + 48_int64 ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_int64 ) then num = ( x + 1_int64 ) + largest_int64 ; negative = . true .; buffer ( 3 :) = '0x0000000000000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16_int64 ; buffer ( i : i ) = DIGITS_A ( num - 16_int64 * next ); if ( next == 0_int64 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 5 : 5 )) if ( ascii_code < 50 ) then buffer ( 5 : 5 ) = achar ( ascii_code + 8 ) else buffer ( 5 : 5 ) = achar ( ascii_code + 47 ) end if into = buffer ( 3 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end if end procedure cast_i64_to_char module procedure cast_i32_to_char character ( len = 1 ) :: fmt_ character ( len = 11 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0 ) then if ( x == smallest_int32 ) then into = '-2147483648' ; return end if num = - x ; negative = . true . else num = x ; negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0 ) then num = ( x + 1 ) + largest_int32 ; negative = . true .; buffer ( 2 :) = '0x00000000' else num = x ; negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 4 : 4 )) if ( ascii_code < 50 ) then buffer ( 4 : 4 ) = achar ( ascii_code + 8 ) else buffer ( 4 : 4 ) = achar ( ascii_code + 47 ) end if into = buffer ( 2 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end if end procedure cast_i32_to_char module procedure cast_i16_to_char character ( len = 1 ) :: fmt_ character ( len = 6 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int16 ) then if ( x == smallest_int16 ) then into = '-32768' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_int16 ) then num = int (( x + 1_int16 ) + largest_int16 ); negative = . true .; buffer ( 1 :) = '0x0000' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end if end procedure cast_i16_to_char module procedure cast_i8_to_char character ( len = 1 ) :: fmt_ character ( len = 4 ) :: buffer integer :: num , next , ascii_code , i logical :: negative if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = EMPTY_STR ; return end if end if if ( fmt_ == 'i' ) then if ( x < 0_int8 ) then if ( x == smallest_int8 ) then into = '-128' ; return end if num = int ( - x ); negative = . true . else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_digits : do next = num / 10 ; buffer ( i : i ) = achar ( num - 10 * next + 48 ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_digits if ( negative ) then buffer ( i - 1 : i - 1 ) = '-' ; into = buffer ( i - 1 :); return else into = buffer ( i :); return end if else if ( x < 0_int8 ) then num = int (( x + 1_int8 ) + largest_int8 ); negative = . true .; buffer ( 1 :) = '0x00' else num = int ( x ); negative = . false . end if i = len ( buffer ); extract_hex_digits : do next = num / 16 ; buffer ( i : i ) = DIGITS_A ( num - 16 * next ); if ( next == 0 ) exit num = next ; i = i - 1 ; cycle end do extract_hex_digits if ( negative ) then ascii_code = iachar ( buffer ( 3 : 3 )) if ( ascii_code < 50 ) then buffer ( 3 : 3 ) = achar ( ascii_code + 8 ) else buffer ( 3 : 3 ) = achar ( ascii_code + 47 ) end if into = buffer ( 1 :); return else buffer ( i - 2 : i - 1 ) = '0x' ; into = buffer ( i - 2 :); return end if end if end procedure cast_i8_to_char module procedure cast_string_to_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real128 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0.0_real128 , 0.0_real128 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real128 , 0.0_real128 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real128 , 0.0_real128 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then if ( i - l - 1 > 2 ) then if ( substring % s ( l + 1 : l + 2 ) == '0x' ) then read ( unit = substring % s ( l + 3 : i - 1 ), fmt = '(z100)' ) z_re else read ( unit = substring % s ( l + 1 : i - 1 ), fmt = '(z100)' ) z_re end if else read ( unit = substring % s ( l + 1 : i - 1 ), fmt = '(z100)' ) z_re end if if ( r - i - 1 > 2 ) then if ( substring % s ( i + 1 : i + 2 ) == '0x' ) then read ( unit = substring % s ( i + 3 : r - 1 ), fmt = '(z100)' ) z_im else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if into = cmplx ( z_re , z_im , kind = real128 ); return else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real128 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then if ( i - l > 2 ) then if ( substring % s ( l : l + 1 ) == '0x' ) then read ( unit = substring % s ( l + 2 : i - 1 ), fmt = '(z100)' ) z_re else read ( unit = substring % s ( l : i - 1 ), fmt = '(z100)' ) z_re end if else read ( unit = substring % s ( l : i - 1 ), fmt = '(z100)' ) z_re end if if ( r - i - 1 > 2 ) then if ( substring % s ( i + 1 : i + 2 ) == '0x' ) then read ( unit = substring % s ( i + 3 : r - 1 ), fmt = '(z100)' ) z_im else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if else read ( unit = substring % s ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if into = cmplx ( z_re , z_im , kind = real128 ); return else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real128 ); return end if end procedure cast_string_to_c128 module procedure cast_string_to_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real64 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0.0_real64 , 0.0_real64 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real64 , 0.0_real64 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real64 , 0.0_real64 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then block ; integer ( int64 ) :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l + 1 : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real64 ); return end block else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real64 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then block ; integer ( int64 ) :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real64 ); return end block else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real64 ); return end if end procedure cast_string_to_c64 module procedure cast_string_to_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real32 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = substring % len () if ( substring_len < 1 ) then into = ( 0.0_real32 , 0.0_real32 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real32 , 0.0_real32 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real32 , 0.0_real32 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring % s ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring % s ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then block ; integer :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l + 1 : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real32 ); return end block else read ( unit = substring % s ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real32 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring % s ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring % s ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring % s ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring % s ( i : i )) == sep_code ) . or . ( iachar ( substring % s ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring % s ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring % s ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then block ; integer :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring % s ( l : i - 1 ); hex_str_im = substring % s ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real32 ); return end block else read ( unit = substring % s ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring % s ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real32 ); return end if end procedure cast_string_to_c32 module procedure cast_string_to_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0.0_real128 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real128 ; return end if end if if ( fmt_ == 'z' ) then if ( substring % len () > 2 ) then if ( substring % s ( 1 : 2 ) == '0x' ) then read ( unit = substring % s ( 3 :), fmt = '(z100)' ) into ; return else read ( unit = substring % s , fmt = '(z100)' ) into ; return end if else read ( unit = substring % s , fmt = '(z100)' ) into ; return end if end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real128 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r128 module procedure cast_string_to_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0.0_real64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real64 ; return end if end if if ( fmt_ == 'z' ) then inline_cast : block ; integer ( int64 ) :: num ; integer :: substring_len , r , l , i , digit ; logical :: negative substring_len = substring % len () r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if num = 0_int64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then num = num + int ( digit , int64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; num = num + int ( digit , int64 ) * SIXTEENS_i64 ( i ) num = ( num - 1_int64 ) - largest_int64 into = transfer ( source = num , mold = into ); return else num = num + int ( digit , int64 ) * SIXTEENS_i64 ( i ) into = transfer ( source = num , mold = into ); return end if end if end do end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real64 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r64 module procedure cast_string_to_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( substring % len () < 1 ) then into = 0.0_real32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real32 ; return end if end if if ( fmt_ == 'z' ) then inline_cast : block ; integer :: num , substring_len , r , l , i , digit ; logical :: negative substring_len = substring % len () r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if num = 0 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then num = num + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; num = num + digit * SIXTEENS_i32 ( i ) num = ( num - 1 ) - largest_int32 into = transfer ( source = num , mold = into ); return else num = num + digit * SIXTEENS_i32 ( i ) into = transfer ( source = num , mold = into ); return end if end if end do end block inline_cast end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real32 ; return end if end if read ( unit = substring % s , fmt =* , decimal = decimal ) into end procedure cast_string_to_r32 module procedure cast_string_to_i64 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = substring % len () if ( substring_len < 1 ) then into = 0_int64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int64 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int64 do i = 0 , ubound ( TENS_i64 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , int64 ) * TENS_i64 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ) into = ( into - 1_int64 ) - largest_int64 ; return else into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ); return end if end if end do end if end procedure cast_string_to_i64 module procedure cast_string_to_i32 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = substring % len () if ( substring_len < 1 ) then into = 0_int32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int32 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0 do i = 0 , ubound ( TENS_i32 , dim = 1 ) into = into + ( iachar ( substring % s ( r : r )) - 48 ) * TENS_i32 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + digit * SIXTEENS_i32 ( i ) into = ( into - 1 ) - largest_int32 ; return else into = into + digit * SIXTEENS_i32 ( i ); return end if end if end do end if end procedure cast_string_to_i32 module procedure cast_string_to_i16 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = substring % len () if ( substring_len < 1 ) then into = 0_int16 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int16 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int16 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , int16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 4 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int16 do i = 0 , ubound ( SIXTEENS_i16 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ) into = ( into - 1_int16 ) - largest_int16 ; return else into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ); return end if end if end do end if end procedure cast_string_to_i16 module procedure cast_string_to_i8 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = substring % len () if ( substring_len < 1 ) then into = 0_int8 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int8 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring % s ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int8 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring % s ( r : r )) - 48 , int16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring % s ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring % s ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring % s ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 2 ) . and . ( iachar ( substring % s ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int8 do i = 0 , ubound ( SIXTEENS_i8 , dim = 1 ) digit = iachar ( substring % s ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ) into = ( into - 1_int8 ) - largest_int8 ; return else into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ); return end if end if end do end if end procedure cast_string_to_i8 module procedure cast_char_to_c128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real128 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0.0_real128 , 0.0_real128 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real128 , 0.0_real128 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real128 , 0.0_real128 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then if ( i - l - 1 > 2 ) then if ( substring ( l + 1 : l + 2 ) == '0x' ) then read ( unit = substring ( l + 3 : i - 1 ), fmt = '(z100)' ) z_re else read ( unit = substring ( l + 1 : i - 1 ), fmt = '(z100)' ) z_re end if else read ( unit = substring ( l + 1 : i - 1 ), fmt = '(z100)' ) z_re end if if ( r - i - 1 > 2 ) then if ( substring ( i + 1 : i + 2 ) == '0x' ) then read ( unit = substring ( i + 3 : r - 1 ), fmt = '(z100)' ) z_im else read ( unit = substring ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if else read ( unit = substring ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if into = cmplx ( z_re , z_im , kind = real128 ); return else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real128 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then if ( i - l > 2 ) then if ( substring ( l : l + 1 ) == '0x' ) then read ( unit = substring ( l + 2 : i - 1 ), fmt = '(z100)' ) z_re else read ( unit = substring ( l : i - 1 ), fmt = '(z100)' ) z_re end if else read ( unit = substring ( l : i - 1 ), fmt = '(z100)' ) z_re end if if ( r - i - 1 > 2 ) then if ( substring ( i + 1 : i + 2 ) == '0x' ) then read ( unit = substring ( i + 3 : r - 1 ), fmt = '(z100)' ) z_im else read ( unit = substring ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if else read ( unit = substring ( i + 1 : r - 1 ), fmt = '(z100)' ) z_im end if into = cmplx ( z_re , z_im , kind = real128 ); return else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real128 ); return end if end procedure cast_char_to_c128 module procedure cast_char_to_c64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real64 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0.0_real64 , 0.0_real64 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real64 , 0.0_real64 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real64 , 0.0_real64 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then block ; integer ( int64 ) :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l + 1 : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real64 ); return end block else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real64 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then block ; integer ( int64 ) :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real64 ); return end block else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real64 ); return end if end procedure cast_char_to_c64 module procedure cast_char_to_c32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal character ( len = :), allocatable :: im_ real ( real32 ) :: z_re , z_im integer :: substring_len , l , r , i , sep_code , e_code , im_len substring_len = len ( substring ) if ( substring_len < 1 ) then into = ( 0.0_real32 , 0.0_real32 ); return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = ( 0.0_real32 , 0.0_real32 ); return end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = ( 0.0_real32 , 0.0_real32 ); return end if end if if ( len ( im_ ) == 0 ) then if ( decimal == 'POINT' ) then sep_code = iachar ( COMMA ) else sep_code = iachar ( SEMICOLON ) end if l = 1 ; do if ( iachar ( substring ( l : l )) == 40 ) exit l = l + 1 ; cycle end do r = substring_len ; do if ( iachar ( substring ( r : r )) == 41 ) exit r = r - 1 ; cycle end do i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do if ( fmt_ == 'z' ) then block ; integer :: num ; character ( len = i - l - 1 ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l + 1 : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real32 ); return end block else read ( unit = substring ( l + 1 : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i + 1 : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real32 ); return end if end if sep_code = iachar ( '+' ); e_code = iachar ( 'e' ); im_len = len ( im_ ) l = 1 ; do if ( iachar ( substring ( l : l )) > sep_code ) exit l = l + 1 ; cycle end do r = substring_len - im_len + 1 ; do if ( substring ( r : r + im_len - 1 ) == im_ ) exit r = r - 1 ; cycle end do if ( fmt_ == 'z' ) then i = l + 1 ; do if ( iachar ( substring ( i : i )) == sep_code ) exit i = i + 1 ; cycle end do else i = l + 1 ; do if ( ( iachar ( substring ( i : i )) == sep_code ) . or . ( iachar ( substring ( i : i )) == sep_code + 2 ) ) then if ( ( iachar ( substring ( i - 1 : i - 1 )) == e_code ). or .( iachar ( substring ( i - 1 : i - 1 )) == e_code - 32 ) ) then i = i + 1 ; cycle else exit end if end if i = i + 1 ; cycle end do end if if ( fmt_ == 'z' ) then block ; integer :: num ; character ( len = i - l ) :: hex_str_re ; character ( len = r - i - 1 ) :: hex_str_im hex_str_re = substring ( l : i - 1 ); hex_str_im = substring ( i + 1 : r - 1 ) call cast ( hex_str_re , into = num , fmt = 'z' ); z_re = transfer ( source = num , mold = z_re ) call cast ( hex_str_im , into = num , fmt = 'z' ); z_im = transfer ( source = num , mold = z_im ) into = cmplx ( z_re , z_im , kind = real32 ); return end block else read ( unit = substring ( l : i - 1 ), fmt =* , decimal = decimal ) z_re read ( unit = substring ( i : r - 1 ), fmt =* , decimal = decimal ) z_im into = cmplx ( z_re , z_im , kind = real32 ); return end if end procedure cast_char_to_c32 module procedure cast_char_to_r128 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( len ( substring ) < 1 ) then into = 0.0_real128 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real128 ; return end if end if if ( fmt_ == 'z' ) then if ( len ( substring ) > 2 ) then if ( substring ( 1 : 2 ) == '0x' ) then read ( unit = substring ( 3 :), fmt = '(z100)' ) into ; return else read ( unit = substring , fmt = '(z100)' ) into ; return end if else read ( unit = substring , fmt = '(z100)' ) into ; return end if end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real128 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r128 module procedure cast_char_to_r64 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( len ( substring ) < 1 ) then into = 0.0_real64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real64 ; return end if end if if ( fmt_ == 'z' ) then block ; integer ( int64 ) :: num call cast ( substring , into = num , fmt = 'z' ); into = transfer ( source = num , mold = into ); return end block end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real64 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r64 module procedure cast_char_to_r32 character ( len = 1 ) :: fmt_ character ( len = 5 ) :: decimal if ( len ( substring ) < 1 ) then into = 0.0_real32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else into = 0.0_real32 ; return end if end if if ( fmt_ == 'z' ) then block ; integer ( int32 ) :: num call cast ( substring , into = num , fmt = 'z' ); into = transfer ( source = num , mold = into ); return end block end if if ( . not . present ( locale ) ) then decimal = 'POINT' else if ( locale == 'US' ) then decimal = 'POINT' else if ( locale == 'EU' ) then decimal = 'COMMA' else into = 0.0_real32 ; return end if end if read ( unit = substring , fmt =* , decimal = decimal ) into end procedure cast_char_to_r32 module procedure cast_char_to_i64 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_int64 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int64 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int64 do i = 0 , ubound ( TENS_i64 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , int64 ) * TENS_i64 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 16 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int64 do i = 0 , ubound ( SIXTEENS_i64 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ) into = ( into - 1_int64 ) - largest_int64 ; return else into = into + int ( digit , int64 ) * SIXTEENS_i64 ( i ); return end if end if end do end if end procedure cast_char_to_i64 module procedure cast_char_to_i32 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_int32 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int32 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0 do i = 0 , ubound ( TENS_i32 , dim = 1 ) into = into + ( iachar ( substring ( r : r )) - 48 ) * TENS_i32 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 8 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0 do i = 0 , ubound ( SIXTEENS_i32 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + digit * SIXTEENS_i32 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + digit * SIXTEENS_i32 ( i ) into = ( into - 1 ) - largest_int32 ; return else into = into + digit * SIXTEENS_i32 ( i ); return end if end if end do end if end procedure cast_char_to_i32 module procedure cast_char_to_i16 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_int16 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int16 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int16 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , int16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 4 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int16 do i = 0 , ubound ( SIXTEENS_i16 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ) into = ( into - 1_int16 ) - largest_int16 ; return else into = into + int ( digit , int16 ) * SIXTEENS_i16 ( i ); return end if end if end do end if end procedure cast_char_to_i16 module procedure cast_char_to_i8 character ( len = 1 ) :: fmt_ integer :: substring_len , r , l , i , digit logical :: negative substring_len = len ( substring ) if ( substring_len < 1 ) then into = 0_int8 ; return end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else into = 0_int8 ; return end if end if if ( fmt_ == 'i' ) then r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 44 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 44 ) . or . ( l == substring_len ) ) exit l = l + 1 ; cycle end do if ( iachar ( substring ( l : l )) == 45 ) then negative = . true .; l = l + 1 else negative = . false . end if into = 0_int8 do i = 0 , ubound ( TENS_i16 , dim = 1 ) into = into + int ( iachar ( substring ( r : r )) - 48 , int16 ) * TENS_i16 ( i ); if ( r == l ) exit r = r - 1 ; cycle end do if ( . not . negative ) return into = - into ; return else r = substring_len ; do if ( ( iachar ( substring ( r : r )) > 47 ) . or . ( r == 1 ) ) exit r = r - 1 ; cycle end do l = 1 ; do if ( ( iachar ( substring ( l : l )) > 47 ) . or . ( l == substring_len ) ) then if ( r - l + 1 > 2 ) then if ( iachar ( substring ( l + 1 : l + 1 )) == 120 ) l = l + 2 end if exit end if l = l + 1 ; cycle end do if ( ( r - l + 1 == 2 ) . and . ( iachar ( substring ( l : l )) > 55 ) ) then negative = . true . else negative = . false . end if into = 0_int8 do i = 0 , ubound ( SIXTEENS_i8 , dim = 1 ) digit = iachar ( substring ( r : r )) - 48 if ( digit > 16 ) then if ( digit < 23 ) then digit = digit - 7 else digit = digit - 39 end if end if if ( r > l ) then into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ); r = r - 1 ; cycle else if ( negative ) then digit = digit - 8 ; into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ) into = ( into - 1_int8 ) - largest_int8 ; return else into = into + int ( digit , int8 ) * SIXTEENS_i8 ( i ); return end if end if end do end if end procedure cast_char_to_i8 end submodule internal_io submodule ( io_fortran_lib ) join_split !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interfaces** `join` and `split`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains module procedure join_char type ( String ) :: temp_String character ( len = :), allocatable :: separator_ if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if temp_String = join ( String ( tokens ), separator = separator_ ) if ( temp_String % len () < 1 ) then new = EMPTY_STR else new = temp_String % s end if end procedure join_char module procedure join_string type ( String ), dimension ( 2 ) :: token_pair character ( len = :), allocatable :: separator_ integer ( int64 ) :: num_tokens num_tokens = size ( tokens , kind = int64 ) if ( num_tokens == 1_int64 ) then if ( tokens ( 1_int64 )% len64 () < 1_int64 ) then new % s = EMPTY_STR ; return else new % s = tokens ( 1_int64 )% s ; return end if end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if if ( num_tokens > 500_int64 ) then new = join ( tokens = [ join ( tokens (: num_tokens / 2_int64 ), separator_ ), & join ( tokens ( 1_int64 + num_tokens / 2_int64 :), separator_ ) ], separator = separator_ ) else call new % join_base ( tokens = tokens , separator = separator_ ) end if end procedure join_string module procedure split_char character ( len = :), allocatable :: separator_ if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if tokens = split ( String ( substring ), separator = separator_ ) end procedure split_char module procedure split_string character ( len = :), allocatable :: separator_ integer ( int64 ) :: substring_len , l , i integer :: sep_len , num_seps , sep , token , current substring_len = substring % len64 () if ( substring_len < 1_int64 ) then allocate ( tokens ( 1 ) ); tokens ( 1 )% s = EMPTY_STR ; return end if if ( . not . present ( separator ) ) then separator_ = SPACE else separator_ = separator end if sep_len = len ( separator_ ) if ( sep_len == 0 ) then allocate ( tokens ( substring_len ) ) do concurrent ( i = 1_int64 : substring_len ) tokens ( i )% s = substring % s ( i : i ) end do return end if num_seps = substring % count ( match = separator_ ) if ( num_seps == 0 ) then allocate ( tokens ( 1 ) ); tokens ( 1 )% s = substring % s ; return end if allocate ( tokens ( num_seps + 1 ) ) sep = iachar ( separator_ ( 1 : 1 )) i = 1_int64 ; l = 1_int64 ; token = 1 ; positional_transfers : do current = iachar ( substring % s ( i : i )) if ( current /= sep ) then i = i + 1_int64 ; cycle end if if ( sep_len == 1 ) then tokens ( token )% s = substring % s ( l : i - 1 ) if ( token == num_seps ) then tokens ( num_seps + 1 )% s = substring % s ( i + 1 :); return end if token = token + 1 ; i = i + 1_int64 ; l = i ; cycle else if ( substring % s ( i : i + sep_len - 1 ) == separator_ ) then tokens ( token )% s = substring % s ( l : i - 1 ) if ( token == num_seps ) then tokens ( num_seps + 1 )% s = substring % s ( i + sep_len :); return end if token = token + 1 ; i = i + sep_len ; l = i ; cycle else i = i + 1_int64 ; cycle end if end if end do positional_transfers end procedure split_string end submodule join_split submodule ( io_fortran_lib ) file_io !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interfaces** `to_file` and !! `from_file`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_file_1dc128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dc128 module procedure to_file_1dc64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dc64 module procedure to_file_1dc32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dc32 module procedure to_file_2dc128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dc128 module procedure to_file_2dc64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dc64 module procedure to_file_2dc32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = trim ( adjustl ( im )) end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' if ( present ( im ) ) write ( * , '(a)' ) LF // 'WARNING: im not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dc32 module procedure to_file_3dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dc128 module procedure to_file_3dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dc64 module procedure to_file_3dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dc32 module procedure to_file_4dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dc128 module procedure to_file_4dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dc64 module procedure to_file_4dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dc32 module procedure to_file_5dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dc128 module procedure to_file_5dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dc64 module procedure to_file_5dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dc32 module procedure to_file_6dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dc128 module procedure to_file_6dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dc64 module procedure to_file_6dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dc32 module procedure to_file_7dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dc128 module procedure to_file_7dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dc64 module procedure to_file_7dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dc32 module procedure to_file_8dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dc128 module procedure to_file_8dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dc64 module procedure to_file_8dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dc32 module procedure to_file_9dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dc128 module procedure to_file_9dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dc64 module procedure to_file_9dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dc32 module procedure to_file_10dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dc128 module procedure to_file_10dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dc64 module procedure to_file_10dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dc32 module procedure to_file_11dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dc128 module procedure to_file_11dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dc64 module procedure to_file_11dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dc32 module procedure to_file_12dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dc128 module procedure to_file_12dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dc64 module procedure to_file_12dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dc32 module procedure to_file_13dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dc128 module procedure to_file_13dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dc64 module procedure to_file_13dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dc32 module procedure to_file_14dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dc128 module procedure to_file_14dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dc64 module procedure to_file_14dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dc32 module procedure to_file_15dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dc128 module procedure to_file_15dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dc64 module procedure to_file_15dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dc32 module procedure to_file_1dr128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dr128 module procedure to_file_1dr64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dr64 module procedure to_file_1dr32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ , hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1dr32 module procedure to_file_2dr128 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dr128 module procedure to_file_2dr64 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dr64 module procedure to_file_2dr32 character ( len = :), allocatable , dimension (:) :: header_ character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ integer :: decimals_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else locale_ = 'US' write ( * , '(a)' ) LF // 'WARNING: Invalid locale \"' // locale // '\" for file \"' // file_name // '\". ' // & 'Defaulting to US format.' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'e' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to exponential format.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( decimals ) ) then decimals_ = 150 else decimals_ = decimals end if call to_text ( x = x , file_name = file_name , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , decimals = decimals_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( locale ) ) write ( * , '(a)' ) LF // 'WARNING: locale not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' if ( present ( decimals ) ) write ( * , '(a)' ) LF // 'WARNING: decimals not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2dr32 module procedure to_file_3dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dr128 module procedure to_file_3dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dr64 module procedure to_file_3dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3dr32 module procedure to_file_4dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dr128 module procedure to_file_4dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dr64 module procedure to_file_4dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4dr32 module procedure to_file_5dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dr128 module procedure to_file_5dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dr64 module procedure to_file_5dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5dr32 module procedure to_file_6dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dr128 module procedure to_file_6dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dr64 module procedure to_file_6dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6dr32 module procedure to_file_7dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dr128 module procedure to_file_7dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dr64 module procedure to_file_7dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7dr32 module procedure to_file_8dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dr128 module procedure to_file_8dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dr64 module procedure to_file_8dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8dr32 module procedure to_file_9dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dr128 module procedure to_file_9dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dr64 module procedure to_file_9dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9dr32 module procedure to_file_10dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dr128 module procedure to_file_10dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dr64 module procedure to_file_10dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10dr32 module procedure to_file_11dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dr128 module procedure to_file_11dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dr64 module procedure to_file_11dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11dr32 module procedure to_file_12dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dr128 module procedure to_file_12dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dr64 module procedure to_file_12dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12dr32 module procedure to_file_13dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dr128 module procedure to_file_13dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dr64 module procedure to_file_13dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13dr32 module procedure to_file_14dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dr128 module procedure to_file_14dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dr64 module procedure to_file_14dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14dr32 module procedure to_file_15dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dr128 module procedure to_file_15dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dr64 module procedure to_file_15dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15dr32 module procedure to_file_1di64 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = COMMA end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1di64 module procedure to_file_1di32 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = COMMA end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1di32 module procedure to_file_1di16 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = COMMA end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1di16 module procedure to_file_1di8 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ integer :: hstat , dim_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] hstat = 0 else if ( ( size ( header , kind = int64 ) /= 1_int64 ) . and . ( size ( header , kind = int64 ) /= size ( x , kind = int64 )) ) then header_ = [ EMPTY_STR ] hstat = - 1 write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , kind = int64 )) // ').' else header_ = header if ( size ( header , kind = int64 ) == 1_int64 ) then hstat = 1 else hstat = 2 end if end if end if if ( . not . present ( dim ) ) then if ( hstat == 2 ) then dim_ = 2 else dim_ = 1 end if else if ( hstat == 2 ) then dim_ = 2 if ( dim /= 2 ) then write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (2).' end if else if ( dim == 1 ) then dim_ = 1 else if ( dim == 2 ) then dim_ = 2 else dim_ = 1 write ( * , '(a)' ) LF // 'WARNING: Invalid dim (' // str ( dim ) // ') in write to file \"' // & file_name // '\" for given header... defaulting to (1).' end if end if end if if ( . not . present ( delim ) ) then if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = COMMA end if else if ( dim_ == 1 ) then delim_ = EMPTY_STR else delim_ = delim end if end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , dim = dim_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( dim ) ) write ( * , '(a)' ) LF // 'WARNING: dim not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_1di8 module procedure to_file_2di64 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2di64 module procedure to_file_2di32 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2di32 module procedure to_file_2di16 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2di16 module procedure to_file_2di8 character ( len = :), allocatable :: ext , delim_ , fmt_ character ( len = :), allocatable , dimension (:) :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = [ EMPTY_STR ] else if ( ( size ( header , kind = int64 ) /= 1_int64 ). and .( size ( header , kind = int64 ) /= size ( x , dim = 2 , kind = int64 )) ) then header_ = [ EMPTY_STR ] write ( * , '(a)' ) LF // 'WARNING: Invalid header for file \"' // file_name // '\".' // & LF // 'Header for this data must have size (1) or ' // & '(' // str ( size ( x , dim = 2 , kind = int64 )) // ').' else header_ = header end if end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' write ( * , '(a)' ) LF // 'WARNING: Invalid format \"' // fmt // '\" for file \"' // file_name // '\". ' // & 'Defaulting to integer format.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call to_text ( x = x , file_name = file_name , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then if ( present ( header ) ) write ( * , '(a)' ) LF // 'WARNING: header not supported for file type \"' // ext // '\".' if ( present ( delim ) ) write ( * , '(a)' ) LF // 'WARNING: delim not supported for file type \"' // ext // '\".' if ( present ( fmt ) ) write ( * , '(a)' ) LF // 'WARNING: fmt not supported for file type \"' // ext // '\".' call to_binary ( x = x , file_name = file_name ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end procedure to_file_2di8 module procedure to_file_3di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3di64 module procedure to_file_3di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3di32 module procedure to_file_3di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3di16 module procedure to_file_3di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_3di8 module procedure to_file_4di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4di64 module procedure to_file_4di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4di32 module procedure to_file_4di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4di16 module procedure to_file_4di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_4di8 module procedure to_file_5di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5di64 module procedure to_file_5di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5di32 module procedure to_file_5di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5di16 module procedure to_file_5di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_5di8 module procedure to_file_6di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6di64 module procedure to_file_6di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6di32 module procedure to_file_6di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6di16 module procedure to_file_6di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_6di8 module procedure to_file_7di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7di64 module procedure to_file_7di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7di32 module procedure to_file_7di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7di16 module procedure to_file_7di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_7di8 module procedure to_file_8di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8di64 module procedure to_file_8di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8di32 module procedure to_file_8di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8di16 module procedure to_file_8di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_8di8 module procedure to_file_9di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9di64 module procedure to_file_9di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9di32 module procedure to_file_9di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9di16 module procedure to_file_9di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_9di8 module procedure to_file_10di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10di64 module procedure to_file_10di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10di32 module procedure to_file_10di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10di16 module procedure to_file_10di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_10di8 module procedure to_file_11di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11di64 module procedure to_file_11di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11di32 module procedure to_file_11di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11di16 module procedure to_file_11di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_11di8 module procedure to_file_12di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12di64 module procedure to_file_12di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12di32 module procedure to_file_12di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12di16 module procedure to_file_12di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_12di8 module procedure to_file_13di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13di64 module procedure to_file_13di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13di32 module procedure to_file_13di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13di16 module procedure to_file_13di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_13di8 module procedure to_file_14di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14di64 module procedure to_file_14di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14di32 module procedure to_file_14di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14di16 module procedure to_file_14di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_14di8 module procedure to_file_15di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15di64 module procedure to_file_15di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15di32 module procedure to_file_15di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15di16 module procedure to_file_15di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then call to_binary ( x = x , file_name = file_name ) else if ( any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". Cannot write array of ' // & 'dimension (' // str ( rank ( x )) // ') to text.' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) else write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure to_file_15di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_textfile_1dc128 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dc128 module procedure from_binaryfile_1dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dc128 module procedure from_textfile_1dc64 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dc64 module procedure from_binaryfile_1dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dc64 module procedure from_textfile_1dc32 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dc32 module procedure from_binaryfile_1dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dc32 module procedure from_textfile_2dc128 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dc128 module procedure from_binaryfile_2dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dc128 module procedure from_textfile_2dc64 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dc64 module procedure from_binaryfile_2dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dc64 module procedure from_textfile_2dc32 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ , im_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into complex array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if if ( . not . present ( im ) ) then im_ = EMPTY_STR else im_ = im end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , & fmt = fmt_ , im = im_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dc32 module procedure from_binaryfile_2dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dc32 module procedure from_file_3dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dc128 module procedure from_file_3dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dc64 module procedure from_file_3dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dc32 module procedure from_file_4dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dc128 module procedure from_file_4dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dc64 module procedure from_file_4dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dc32 module procedure from_file_5dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dc128 module procedure from_file_5dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dc64 module procedure from_file_5dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dc32 module procedure from_file_6dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dc128 module procedure from_file_6dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dc64 module procedure from_file_6dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dc32 module procedure from_file_7dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dc128 module procedure from_file_7dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dc64 module procedure from_file_7dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dc32 module procedure from_file_8dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dc128 module procedure from_file_8dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dc64 module procedure from_file_8dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dc32 module procedure from_file_9dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dc128 module procedure from_file_9dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dc64 module procedure from_file_9dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dc32 module procedure from_file_10dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dc128 module procedure from_file_10dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dc64 module procedure from_file_10dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dc32 module procedure from_file_11dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dc128 module procedure from_file_11dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dc64 module procedure from_file_11dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dc32 module procedure from_file_12dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dc128 module procedure from_file_12dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dc64 module procedure from_file_12dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dc32 module procedure from_file_13dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dc128 module procedure from_file_13dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dc64 module procedure from_file_13dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dc32 module procedure from_file_14dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dc128 module procedure from_file_14dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dc64 module procedure from_file_14dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dc32 module procedure from_file_15dc128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dc128 module procedure from_file_15dc64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dc64 module procedure from_file_15dc32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dc32 module procedure from_textfile_1dr128 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dr128 module procedure from_binaryfile_1dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dr128 module procedure from_textfile_1dr64 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dr64 module procedure from_binaryfile_1dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dr64 module procedure from_textfile_1dr32 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1dr32 module procedure from_binaryfile_1dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1dr32 module procedure from_textfile_2dr128 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dr128 module procedure from_binaryfile_2dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dr128 module procedure from_textfile_2dr64 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dr64 module procedure from_binaryfile_2dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dr64 module procedure from_textfile_2dr32 character ( len = :), allocatable :: ext , locale_ , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( locale ) ) then locale_ = 'US' else if ( any ( LOCALES == locale ) ) then locale_ = locale else error stop LF // 'FATAL: Invalid locale \"' // locale // '\" for read of file \"' // file_name // '\".' // & LF // 'Locale must be one of: ' // join ( LOCALES ) end if end if if ( . not . present ( delim ) ) then if ( locale_ == 'US' ) then delim_ = COMMA else delim_ = SEMICOLON end if else delim_ = delim if ( locale_ == 'US' ) then if ( delim_ == POINT ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with US decimal.' end if else if ( delim_ == COMMA ) then error stop LF // 'FATAL: Invalid delimiter for read of file \"' // file_name // '\" with EU decimal.' end if end if end if if ( . not . present ( fmt ) ) then fmt_ = 'e' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into real array.' // & LF // 'Format must be one of: ' // join ( REAL_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , locale = locale_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2dr32 module procedure from_binaryfile_2dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2dr32 module procedure from_file_3dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dr128 module procedure from_file_3dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dr64 module procedure from_file_3dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3dr32 module procedure from_file_4dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dr128 module procedure from_file_4dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dr64 module procedure from_file_4dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4dr32 module procedure from_file_5dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dr128 module procedure from_file_5dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dr64 module procedure from_file_5dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5dr32 module procedure from_file_6dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dr128 module procedure from_file_6dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dr64 module procedure from_file_6dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6dr32 module procedure from_file_7dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dr128 module procedure from_file_7dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dr64 module procedure from_file_7dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7dr32 module procedure from_file_8dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dr128 module procedure from_file_8dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dr64 module procedure from_file_8dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8dr32 module procedure from_file_9dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dr128 module procedure from_file_9dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dr64 module procedure from_file_9dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9dr32 module procedure from_file_10dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dr128 module procedure from_file_10dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dr64 module procedure from_file_10dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10dr32 module procedure from_file_11dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dr128 module procedure from_file_11dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dr64 module procedure from_file_11dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11dr32 module procedure from_file_12dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dr128 module procedure from_file_12dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dr64 module procedure from_file_12dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12dr32 module procedure from_file_13dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dr128 module procedure from_file_13dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dr64 module procedure from_file_13dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13dr32 module procedure from_file_14dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dr128 module procedure from_file_14dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dr64 module procedure from_file_14dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14dr32 module procedure from_file_15dr128 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dr128 module procedure from_file_15dr64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dr64 module procedure from_file_15dr32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15dr32 module procedure from_textfile_1di64 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1di64 module procedure from_binaryfile_1di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1di64 module procedure from_textfile_1di32 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1di32 module procedure from_binaryfile_1di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1di32 module procedure from_textfile_1di16 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1di16 module procedure from_binaryfile_1di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1di16 module procedure from_textfile_1di8 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_1di8 module procedure from_binaryfile_1di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_1di8 module procedure from_textfile_2di64 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2di64 module procedure from_binaryfile_2di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2di64 module procedure from_textfile_2di32 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2di32 module procedure from_binaryfile_2di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2di32 module procedure from_textfile_2di16 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2di16 module procedure from_binaryfile_2di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2di16 module procedure from_textfile_2di8 character ( len = :), allocatable :: ext , delim_ , fmt_ logical :: header_ ext = ext_of ( file_name ) if ( any ( TEXT_EXT == ext ) ) then if ( . not . present ( header ) ) then header_ = . false . else header_ = header end if if ( . not . present ( delim ) ) then delim_ = COMMA else delim_ = delim end if if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else error stop LF // 'FATAL: Invalid format \"' // fmt // '\" for read of file \"' // file_name // '\" ' // & 'into integer array.' // & LF // 'Format must be one of: ' // join ( INT_FMTS ) end if end if call from_text ( file_name = file_name , into = into , header = header_ , delim = delim_ , fmt = fmt_ ) else if ( any ( BINARY_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must be specified ' // & 'for binary data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_textfile_2di8 module procedure from_binaryfile_2di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\", data_shape must not be specified ' // & 'for textual data.' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) // SPACE // & join ( BINARY_EXT ) end if end if end procedure from_binaryfile_2di8 module procedure from_file_3di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3di64 module procedure from_file_3di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3di32 module procedure from_file_3di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3di16 module procedure from_file_3di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_3di8 module procedure from_file_4di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4di64 module procedure from_file_4di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4di32 module procedure from_file_4di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4di16 module procedure from_file_4di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_4di8 module procedure from_file_5di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5di64 module procedure from_file_5di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5di32 module procedure from_file_5di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5di16 module procedure from_file_5di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_5di8 module procedure from_file_6di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6di64 module procedure from_file_6di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6di32 module procedure from_file_6di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6di16 module procedure from_file_6di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_6di8 module procedure from_file_7di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7di64 module procedure from_file_7di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7di32 module procedure from_file_7di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7di16 module procedure from_file_7di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_7di8 module procedure from_file_8di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8di64 module procedure from_file_8di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8di32 module procedure from_file_8di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8di16 module procedure from_file_8di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_8di8 module procedure from_file_9di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9di64 module procedure from_file_9di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9di32 module procedure from_file_9di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9di16 module procedure from_file_9di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_9di8 module procedure from_file_10di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10di64 module procedure from_file_10di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10di32 module procedure from_file_10di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10di16 module procedure from_file_10di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_10di8 module procedure from_file_11di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11di64 module procedure from_file_11di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11di32 module procedure from_file_11di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11di16 module procedure from_file_11di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_11di8 module procedure from_file_12di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12di64 module procedure from_file_12di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12di32 module procedure from_file_12di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12di16 module procedure from_file_12di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_12di8 module procedure from_file_13di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13di64 module procedure from_file_13di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13di32 module procedure from_file_13di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13di16 module procedure from_file_13di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_13di8 module procedure from_file_14di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14di64 module procedure from_file_14di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14di32 module procedure from_file_14di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14di16 module procedure from_file_14di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_14di8 module procedure from_file_15di64 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15di64 module procedure from_file_15di32 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15di32 module procedure from_file_15di16 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15di16 module procedure from_file_15di8 character ( len = :), allocatable :: ext ext = ext_of ( file_name ) if ( any ( BINARY_EXT == ext ) ) then if ( size ( data_shape ) /= rank ( into ) ) then error stop LF // 'FATAL: Shape mismatch in read of file \"' // file_name // '\".' // & LF // 'Output array has dimension (' // str ( rank ( into )) // ') while data_shape has size (' & // str ( size ( data_shape )) // '). These must match.' end if call from_binary ( file_name = file_name , into = into , data_shape = data_shape ) else if ( any ( TEXT_EXT == ext ) ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". Textual data cannot be read into ' // & 'arrays of dimension greater than (2).' else error stop LF // 'FATAL: Unsupported file extension \"' // ext // '\" for file \"' // file_name // '\".' // & LF // 'Supported file extensions: ' // join ( BINARY_EXT ) end if end if end procedure from_file_15di8 end submodule file_io submodule ( io_fortran_lib ) text_io !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interface** `echo` and the **private !! interfaces** `to_text` and `from_text`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure echo_chars character ( len = :), allocatable :: ext , terminator_ logical :: exists , append_ integer :: file_unit ext = ext_of ( file_name ) if ( . not . any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) return end if if ( len ( substring , kind = int64 ) == 0_int64 ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". ' // & 'String to write is empty.' return end if if ( . not . present ( append ) ) then append_ = . true . else append_ = append end if if ( . not . present ( terminator ) ) then terminator_ = LF else terminator_ = terminator end if inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'append' ) end if end if write ( unit = file_unit ) substring // terminator_ close ( file_unit ) end procedure echo_chars module procedure echo_string character ( len = :), allocatable :: ext , terminator_ logical :: exists , append_ integer :: file_unit ext = ext_of ( file_name ) if ( . not . any ( TEXT_EXT == ext ) ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\" ' // & 'due to unsupported file extension \"' // ext // '\".' // & LF // 'Supported file extensions: ' // join ( TEXT_EXT ) return end if if ( substring % len64 () < 1_int64 ) then write ( * , '(a)' ) LF // 'WARNING: Skipping write to \"' // file_name // '\". ' // & 'String to write is empty.' return end if if ( . not . present ( append ) ) then append_ = . true . else append_ = append end if if ( . not . present ( terminator ) ) then terminator_ = LF else terminator_ = terminator end if inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else if ( . not . append_ ) then open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'write' , access = 'stream' , position = 'append' ) end if end if write ( unit = file_unit ) substring % s // terminator_ close ( file_unit ) end procedure echo_string module procedure to_text_1dc128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dc128 module procedure to_text_1dc64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dc64 module procedure to_text_1dc32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dc32 module procedure to_text_2dc128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals , im = im ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dc128 module procedure to_text_2dc64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals , im = im ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dc64 module procedure to_text_2dc32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals , im = im ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals , im = im ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dc32 module procedure to_text_1dr128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dr128 module procedure to_text_1dr64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dr64 module procedure to_text_1dr32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 2_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells ( 1_int64 ,:), locale = locale , fmt = fmt , decimals = decimals ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1dr32 module procedure to_text_2dr128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dr128 module procedure to_text_2dr64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dr64 module procedure to_text_2dr32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), locale = locale , fmt = fmt , decimals = decimals ) else call cast ( x , into = cells , locale = locale , fmt = fmt , decimals = decimals ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2dr32 module procedure to_text_1di64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 2_int64 ,:), fmt = fmt ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 1_int64 ,:), fmt = fmt ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1di64 module procedure to_text_1di32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 2_int64 ,:), fmt = fmt ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 1_int64 ,:), fmt = fmt ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1di32 module procedure to_text_1di16 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 2_int64 ,:), fmt = fmt ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 1_int64 ,:), fmt = fmt ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1di16 module procedure to_text_1di8 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: nx , j logical :: header_present nx = size ( x , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then if ( dim == 1 ) then allocate ( cells ( nx , 1_int64 ) ) else allocate ( cells ( 1_int64 , nx ) ) end if else header_present = . true . if ( dim == 1 ) then allocate ( cells ( nx + 1_int64 , 1_int64 ) ) cells ( 1_int64 , 1_int64 ) = String ( trim ( adjustl ( header ( 1_int64 ))) ) else allocate ( cells ( 2_int64 , nx ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 1 , kind = int64 ): ubound ( x , dim = 1 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if end if else header_present = . true . allocate ( cells ( 2_int64 , nx ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then if ( dim == 1 ) then call cast ( x , into = cells ( 2_int64 :, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 2_int64 ,:), fmt = fmt ) end if else if ( dim == 1 ) then call cast ( x , into = cells (:, 1_int64 ), fmt = fmt ) else call cast ( x , into = cells ( 1_int64 ,:), fmt = fmt ) end if end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_1di8 module procedure to_text_2di64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), fmt = fmt ) else call cast ( x , into = cells , fmt = fmt ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2di64 module procedure to_text_2di32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), fmt = fmt ) else call cast ( x , into = cells , fmt = fmt ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2di32 module procedure to_text_2di16 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), fmt = fmt ) else call cast ( x , into = cells , fmt = fmt ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2di16 module procedure to_text_2di8 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells character ( len = :), allocatable :: label integer ( int64 ) :: n_rows , n_cols , j logical :: header_present n_rows = size ( x , dim = 1 , kind = int64 ) n_cols = size ( x , dim = 2 , kind = int64 ) header_present = . false . if ( size ( header , kind = int64 ) == 1_int64 ) then if ( all ( header == EMPTY_STR ) ) then allocate ( cells ( n_rows , n_cols ) ) else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) label = trim ( adjustl ( header ( 1_int64 ))) do concurrent ( j = lbound ( x , dim = 2 , kind = int64 ): ubound ( x , dim = 2 , kind = int64 )) cells ( 1_int64 , j ) = String ( label // str ( j )) end do end if else header_present = . true . allocate ( cells ( n_rows + 1_int64 , n_cols ) ) cells ( 1_int64 ,:) = String ( header ) end if if ( header_present ) then call cast ( x , into = cells ( 2_int64 :,:), fmt = fmt ) else call cast ( x , into = cells , fmt = fmt ) end if call text_file % write_file ( cells , file_name = file_name , row_separator = NL , column_separator = delim ) end procedure to_text_2di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_text_1dc128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_1dc128 module procedure from_text_1dc64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_1dc64 module procedure from_text_1dc32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_1dc32 module procedure from_text_2dc128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_2dc128 module procedure from_text_2dc64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_2dc64 module procedure from_text_2dc32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols if ( len ( im ) == 0 ) then custom_processing : block integer ( int64 ) :: file_length , row , col , l , i integer :: row_sep , col_sep , col_sep_len , open_paren , close_paren , current integer :: file_unit , iostat logical :: exists , in_paren inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if inquire ( file = file_name , size = file_length ) if ( file_length == 0_int64 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". File is empty.' return end if allocate ( character ( len = file_length ) :: text_file % s ) read ( unit = file_unit , iostat = iostat ) text_file % s close ( file_unit ) if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if col_sep_len = len ( delim ) row_sep = iachar ( NL ); col_sep = iachar ( delim ( 1 : 1 )) open_paren = iachar ( '(' ); close_paren = iachar ( ')' ); in_paren = . false . n_rows = text_file % count ( match = NL ) n_cols = 1_int64 ; i = 1_int64 ; get_n_cols : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then n_cols = n_cols + 1_int64 ; i = i + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then n_cols = n_cols + 1_int64 ; i = i + col_sep_len ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) exit get_n_cols end do get_n_cols allocate ( cells ( n_rows , n_cols ) ) row = 1_int64 ; col = 1_int64 ; l = 1_int64 ; i = 1_int64 ; positional_transfers : do current = iachar ( text_file % s ( i : i )) if ( ( current /= open_paren ) . and . ( current /= close_paren ) . and . ( current /= col_sep ) . and . & ( current /= row_sep ) ) then i = i + 1_int64 ; cycle end if if ( current == open_paren ) then in_paren = . true .; i = i + 1_int64 ; cycle end if if ( current == close_paren ) then in_paren = . false .; i = i + 1_int64 ; cycle end if if ( current == col_sep ) then if ( in_paren ) then i = i + 1_int64 ; cycle end if if ( col_sep_len == 1 ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + 1_int64 ; l = i col = col + 1_int64 ; cycle else if ( text_file % s ( i : i + col_sep_len - 1_int64 ) == delim ) then cells ( row , col )% s = text_file % s ( l : i - 1 ); i = i + col_sep_len ; l = i col = col + 1_int64 ; cycle else i = i + 1_int64 ; cycle end if end if end if if ( current == row_sep ) then cells ( row , col )% s = text_file % s ( l : i - 1 ) if ( row == n_rows ) exit custom_processing i = i + 1_int64 ; l = i ; col = 1_int64 ; row = row + 1_int64 ; cycle end if end do positional_transfers end block custom_processing else call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt , im = im ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt , im = im ); return end if end procedure from_text_2dc32 module procedure from_text_1dr128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_1dr128 module procedure from_text_1dr64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_1dr64 module procedure from_text_1dr32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , locale = locale , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_1dr32 module procedure from_text_2dr128 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_2dr128 module procedure from_text_2dr64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_2dr64 module procedure from_text_2dr32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , locale = locale , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , locale = locale , fmt = fmt ); return end if end procedure from_text_2dr32 module procedure from_text_1di64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , fmt = fmt ); return end if end procedure from_text_1di64 module procedure from_text_1di32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , fmt = fmt ); return end if end procedure from_text_1di32 module procedure from_text_1di16 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , fmt = fmt ); return end if end procedure from_text_1di16 module procedure from_text_1di8 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( ( n_rows > 1_int64 ) . and . ( n_cols > 1_int64 ) ) then if ( header ) then if ( n_rows /= 2_int64 ) then error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' return end if else error stop LF // 'Error reading file \"' // file_name // '\". Data cannot fit into one-dimensional array.' // & ' If there are two rows including a header row, specify \"header=.true.\" .' return end if end if if ( n_cols == 1_int64 ) then if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 ) ) call cells ( 2_int64 :, 1_int64 )% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows ) ) call cells (:, 1_int64 )% cast ( into = into , fmt = fmt ); return end if end if if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_cols ) ) call cells ( 2_int64 ,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_cols ) ) call cells ( 1_int64 ,:)% cast ( into = into , fmt = fmt ); return end if end procedure from_text_1di8 module procedure from_text_2di64 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , fmt = fmt ); return end if end procedure from_text_2di64 module procedure from_text_2di32 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , fmt = fmt ); return end if end procedure from_text_2di32 module procedure from_text_2di16 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , fmt = fmt ); return end if end procedure from_text_2di16 module procedure from_text_2di8 type ( String ) :: text_file type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: n_rows , n_cols call text_file % read_file ( file_name , cell_array = cells , row_separator = NL , column_separator = delim ) call text_file % empty () n_rows = size ( cells , dim = 1 , kind = int64 ) n_cols = size ( cells , dim = 2 , kind = int64 ) if ( header ) then if ( . not . ( n_rows > 1_int64 ) ) then error stop LF // 'Error reading file \"' // file_name // '\". File is empty after header.' return end if allocate ( into ( n_rows - 1_int64 , n_cols ) ) call cells ( 2_int64 :,:)% cast ( into = into , fmt = fmt ); return else allocate ( into ( n_rows , n_cols ) ) call cells % cast ( into = into , fmt = fmt ); return end if end procedure from_text_2di8 end submodule text_io submodule ( io_fortran_lib ) binary_io !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **private interfaces** `to_binary` and !! `from_binary`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains ! Writing Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure to_binary_1dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc128 module procedure to_binary_1dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc64 module procedure to_binary_1dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dc32 module procedure to_binary_2dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc128 module procedure to_binary_2dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc64 module procedure to_binary_2dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dc32 module procedure to_binary_3dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc128 module procedure to_binary_3dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc64 module procedure to_binary_3dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dc32 module procedure to_binary_4dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc128 module procedure to_binary_4dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc64 module procedure to_binary_4dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dc32 module procedure to_binary_5dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc128 module procedure to_binary_5dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc64 module procedure to_binary_5dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dc32 module procedure to_binary_6dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc128 module procedure to_binary_6dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc64 module procedure to_binary_6dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dc32 module procedure to_binary_7dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc128 module procedure to_binary_7dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc64 module procedure to_binary_7dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dc32 module procedure to_binary_8dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc128 module procedure to_binary_8dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc64 module procedure to_binary_8dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dc32 module procedure to_binary_9dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc128 module procedure to_binary_9dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc64 module procedure to_binary_9dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dc32 module procedure to_binary_10dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc128 module procedure to_binary_10dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc64 module procedure to_binary_10dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dc32 module procedure to_binary_11dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc128 module procedure to_binary_11dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc64 module procedure to_binary_11dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dc32 module procedure to_binary_12dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc128 module procedure to_binary_12dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc64 module procedure to_binary_12dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dc32 module procedure to_binary_13dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc128 module procedure to_binary_13dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc64 module procedure to_binary_13dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dc32 module procedure to_binary_14dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc128 module procedure to_binary_14dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc64 module procedure to_binary_14dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dc32 module procedure to_binary_15dc128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc128 module procedure to_binary_15dc64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc64 module procedure to_binary_15dc32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dc32 module procedure to_binary_1dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr128 module procedure to_binary_1dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr64 module procedure to_binary_1dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1dr32 module procedure to_binary_2dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr128 module procedure to_binary_2dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr64 module procedure to_binary_2dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2dr32 module procedure to_binary_3dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr128 module procedure to_binary_3dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr64 module procedure to_binary_3dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3dr32 module procedure to_binary_4dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr128 module procedure to_binary_4dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr64 module procedure to_binary_4dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4dr32 module procedure to_binary_5dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr128 module procedure to_binary_5dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr64 module procedure to_binary_5dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5dr32 module procedure to_binary_6dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr128 module procedure to_binary_6dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr64 module procedure to_binary_6dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6dr32 module procedure to_binary_7dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr128 module procedure to_binary_7dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr64 module procedure to_binary_7dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7dr32 module procedure to_binary_8dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr128 module procedure to_binary_8dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr64 module procedure to_binary_8dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8dr32 module procedure to_binary_9dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr128 module procedure to_binary_9dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr64 module procedure to_binary_9dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9dr32 module procedure to_binary_10dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr128 module procedure to_binary_10dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr64 module procedure to_binary_10dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10dr32 module procedure to_binary_11dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr128 module procedure to_binary_11dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr64 module procedure to_binary_11dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11dr32 module procedure to_binary_12dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr128 module procedure to_binary_12dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr64 module procedure to_binary_12dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12dr32 module procedure to_binary_13dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr128 module procedure to_binary_13dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr64 module procedure to_binary_13dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13dr32 module procedure to_binary_14dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr128 module procedure to_binary_14dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr64 module procedure to_binary_14dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14dr32 module procedure to_binary_15dr128 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr128 module procedure to_binary_15dr64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr64 module procedure to_binary_15dr32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15dr32 module procedure to_binary_1di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di64 module procedure to_binary_1di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di32 module procedure to_binary_1di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di16 module procedure to_binary_1di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_1di8 module procedure to_binary_2di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di64 module procedure to_binary_2di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di32 module procedure to_binary_2di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di16 module procedure to_binary_2di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_2di8 module procedure to_binary_3di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di64 module procedure to_binary_3di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di32 module procedure to_binary_3di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di16 module procedure to_binary_3di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_3di8 module procedure to_binary_4di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di64 module procedure to_binary_4di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di32 module procedure to_binary_4di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di16 module procedure to_binary_4di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_4di8 module procedure to_binary_5di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di64 module procedure to_binary_5di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di32 module procedure to_binary_5di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di16 module procedure to_binary_5di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_5di8 module procedure to_binary_6di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di64 module procedure to_binary_6di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di32 module procedure to_binary_6di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di16 module procedure to_binary_6di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_6di8 module procedure to_binary_7di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di64 module procedure to_binary_7di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di32 module procedure to_binary_7di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di16 module procedure to_binary_7di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_7di8 module procedure to_binary_8di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di64 module procedure to_binary_8di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di32 module procedure to_binary_8di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di16 module procedure to_binary_8di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_8di8 module procedure to_binary_9di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di64 module procedure to_binary_9di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di32 module procedure to_binary_9di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di16 module procedure to_binary_9di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_9di8 module procedure to_binary_10di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di64 module procedure to_binary_10di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di32 module procedure to_binary_10di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di16 module procedure to_binary_10di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_10di8 module procedure to_binary_11di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di64 module procedure to_binary_11di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di32 module procedure to_binary_11di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di16 module procedure to_binary_11di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_11di8 module procedure to_binary_12di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di64 module procedure to_binary_12di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di32 module procedure to_binary_12di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di16 module procedure to_binary_12di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_12di8 module procedure to_binary_13di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di64 module procedure to_binary_13di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di32 module procedure to_binary_13di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di16 module procedure to_binary_13di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_13di8 module procedure to_binary_14di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di64 module procedure to_binary_14di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di32 module procedure to_binary_14di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di16 module procedure to_binary_14di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_14di8 module procedure to_binary_15di64 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di64 module procedure to_binary_15di32 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di32 module procedure to_binary_15di16 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di16 module procedure to_binary_15di8 logical :: exists integer :: file_unit inquire ( file = file_name , exist = exists ) file_unit = output_unit if ( . not . exists ) then open ( newunit = file_unit , file = file_name , status = 'new' , form = 'unformatted' , & action = 'write' , access = 'stream' ) else open ( newunit = file_unit , file = file_name , status = 'replace' , form = 'unformatted' , & action = 'write' , access = 'stream' ) end if write ( unit = file_unit ) x close ( file_unit ) end procedure to_binary_15di8 ! Reading Procedures ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ module procedure from_binary_1dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dc128 module procedure from_binary_1dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dc64 module procedure from_binary_1dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dc32 module procedure from_binary_2dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dc128 module procedure from_binary_2dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dc64 module procedure from_binary_2dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dc32 module procedure from_binary_3dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dc128 module procedure from_binary_3dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dc64 module procedure from_binary_3dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dc32 module procedure from_binary_4dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dc128 module procedure from_binary_4dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dc64 module procedure from_binary_4dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dc32 module procedure from_binary_5dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dc128 module procedure from_binary_5dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dc64 module procedure from_binary_5dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dc32 module procedure from_binary_6dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dc128 module procedure from_binary_6dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dc64 module procedure from_binary_6dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dc32 module procedure from_binary_7dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dc128 module procedure from_binary_7dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dc64 module procedure from_binary_7dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dc32 module procedure from_binary_8dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dc128 module procedure from_binary_8dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dc64 module procedure from_binary_8dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dc32 module procedure from_binary_9dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dc128 module procedure from_binary_9dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dc64 module procedure from_binary_9dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dc32 module procedure from_binary_10dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dc128 module procedure from_binary_10dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dc64 module procedure from_binary_10dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dc32 module procedure from_binary_11dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dc128 module procedure from_binary_11dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dc64 module procedure from_binary_11dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dc32 module procedure from_binary_12dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dc128 module procedure from_binary_12dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dc64 module procedure from_binary_12dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dc32 module procedure from_binary_13dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dc128 module procedure from_binary_13dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dc64 module procedure from_binary_13dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dc32 module procedure from_binary_14dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dc128 module procedure from_binary_14dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dc64 module procedure from_binary_14dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dc32 module procedure from_binary_15dc128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dc128 module procedure from_binary_15dc64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dc64 module procedure from_binary_15dc32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dc32 module procedure from_binary_1dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dr128 module procedure from_binary_1dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dr64 module procedure from_binary_1dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1dr32 module procedure from_binary_2dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dr128 module procedure from_binary_2dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dr64 module procedure from_binary_2dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2dr32 module procedure from_binary_3dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dr128 module procedure from_binary_3dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dr64 module procedure from_binary_3dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3dr32 module procedure from_binary_4dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dr128 module procedure from_binary_4dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dr64 module procedure from_binary_4dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4dr32 module procedure from_binary_5dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dr128 module procedure from_binary_5dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dr64 module procedure from_binary_5dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5dr32 module procedure from_binary_6dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dr128 module procedure from_binary_6dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dr64 module procedure from_binary_6dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6dr32 module procedure from_binary_7dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dr128 module procedure from_binary_7dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dr64 module procedure from_binary_7dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7dr32 module procedure from_binary_8dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dr128 module procedure from_binary_8dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dr64 module procedure from_binary_8dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8dr32 module procedure from_binary_9dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dr128 module procedure from_binary_9dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dr64 module procedure from_binary_9dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9dr32 module procedure from_binary_10dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dr128 module procedure from_binary_10dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dr64 module procedure from_binary_10dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10dr32 module procedure from_binary_11dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dr128 module procedure from_binary_11dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dr64 module procedure from_binary_11dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11dr32 module procedure from_binary_12dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dr128 module procedure from_binary_12dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dr64 module procedure from_binary_12dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12dr32 module procedure from_binary_13dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dr128 module procedure from_binary_13dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dr64 module procedure from_binary_13dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13dr32 module procedure from_binary_14dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dr128 module procedure from_binary_14dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dr64 module procedure from_binary_14dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14dr32 module procedure from_binary_15dr128 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dr128 module procedure from_binary_15dr64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dr64 module procedure from_binary_15dr32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15dr32 module procedure from_binary_1di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1di64 module procedure from_binary_1di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1di32 module procedure from_binary_1di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1di16 module procedure from_binary_1di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_1di8 module procedure from_binary_2di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2di64 module procedure from_binary_2di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2di32 module procedure from_binary_2di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2di16 module procedure from_binary_2di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_2di8 module procedure from_binary_3di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3di64 module procedure from_binary_3di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3di32 module procedure from_binary_3di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3di16 module procedure from_binary_3di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_3di8 module procedure from_binary_4di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4di64 module procedure from_binary_4di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4di32 module procedure from_binary_4di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4di16 module procedure from_binary_4di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_4di8 module procedure from_binary_5di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5di64 module procedure from_binary_5di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5di32 module procedure from_binary_5di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5di16 module procedure from_binary_5di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_5di8 module procedure from_binary_6di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6di64 module procedure from_binary_6di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6di32 module procedure from_binary_6di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6di16 module procedure from_binary_6di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_6di8 module procedure from_binary_7di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7di64 module procedure from_binary_7di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7di32 module procedure from_binary_7di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7di16 module procedure from_binary_7di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_7di8 module procedure from_binary_8di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8di64 module procedure from_binary_8di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8di32 module procedure from_binary_8di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8di16 module procedure from_binary_8di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_8di8 module procedure from_binary_9di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9di64 module procedure from_binary_9di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9di32 module procedure from_binary_9di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9di16 module procedure from_binary_9di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_9di8 module procedure from_binary_10di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10di64 module procedure from_binary_10di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10di32 module procedure from_binary_10di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10di16 module procedure from_binary_10di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_10di8 module procedure from_binary_11di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11di64 module procedure from_binary_11di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11di32 module procedure from_binary_11di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11di16 module procedure from_binary_11di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_11di8 module procedure from_binary_12di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12di64 module procedure from_binary_12di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12di32 module procedure from_binary_12di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12di16 module procedure from_binary_12di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_12di8 module procedure from_binary_13di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13di64 module procedure from_binary_13di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13di32 module procedure from_binary_13di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13di16 module procedure from_binary_13di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_13di8 module procedure from_binary_14di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14di64 module procedure from_binary_14di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14di32 module procedure from_binary_14di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14di16 module procedure from_binary_14di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_14di8 module procedure from_binary_15di64 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15di64 module procedure from_binary_15di32 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15di32 module procedure from_binary_15di16 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15di16 module procedure from_binary_15di8 logical :: exists integer :: file_unit , iostat inquire ( file = file_name , exist = exists ) file_unit = input_unit if ( exists ) then open ( newunit = file_unit , file = file_name , status = 'old' , form = 'unformatted' , & action = 'read' , access = 'stream' , position = 'rewind' ) else error stop LF // 'FATAL: Error reading file \"' // file_name // '\". No such file exists.' return end if allocate ( into ( data_shape ( 1 ), data_shape ( 2 ), data_shape ( 3 ), data_shape ( 4 ), data_shape ( 5 ), data_shape ( 6 ), & data_shape ( 7 ), data_shape ( 8 ), data_shape ( 9 ), data_shape ( 10 ), data_shape ( 11 ), data_shape ( 12 ), & data_shape ( 13 ), data_shape ( 14 ), data_shape ( 15 )) ) read ( unit = file_unit , iostat = iostat ) into if ( iostat > 0 ) then error stop LF // 'FATAL: Error reading file \"' // file_name // '\". iostat is ' // str ( iostat ) return end if close ( file_unit ) end procedure from_binary_15di8 end submodule binary_io submodule ( io_fortran_lib ) array_printing !------------------------------------------------------------------------------------------------------------------ !! This submodule provides module procedure implementations for the **public interface** `aprint`. !------------------------------------------------------------------------------------------------------------------ implicit none ( type , external ) contains module procedure aprint_1dc128 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc128 module procedure aprint_1dc64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc64 module procedure aprint_1dc32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_1dc32 module procedure aprint_2dc128 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc128 module procedure aprint_2dc64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc64 module procedure aprint_2dc32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , im_ , xre_max_str , xre_min_str , xim_max_str , xim_min_str integer :: i , j , decimals_ , l if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if if ( . not . present ( im ) ) then im_ = 'j' else im_ = trim ( adjustl ( im )) end if if ( len ( im_ ) > 0 ) then l = len ( im_ ) else l = 3 end if xre_max_str = str ( maxval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xre_min_str = str ( minval ( x % re ), fmt = fmt_ , decimals = decimals_ ) xim_max_str = str ( maxval ( x % im ), fmt = fmt_ , decimals = decimals_ ) xim_min_str = str ( minval ( x % im ), fmt = fmt_ , decimals = decimals_ ) if ( len ( xre_max_str ) > len ( xre_min_str ) ) then l = l + len ( xre_max_str ) else l = l + len ( xre_min_str ) end if if ( len ( xim_max_str ) > len ( xim_min_str ) ) then l = l + len ( xim_max_str ) else l = l + len ( xim_min_str ) end if allocate ( character ( len = l ) :: x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ , im = im_ ) end do call aprint ( x_str ) end procedure aprint_2dc32 module procedure aprint_1dr128 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr128 module procedure aprint_1dr64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr64 module procedure aprint_1dr32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_1dr32 module procedure aprint_2dr128 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr128 module procedure aprint_2dr64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr64 module procedure aprint_2dr32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , x_abs_min_str , source integer :: i , j , decimals_ if ( . not . present ( fmt ) ) then fmt_ = 'f' else if ( any ( REAL_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'f' end if end if if ( . not . present ( decimals ) ) then decimals_ = 2 else decimals_ = decimals end if x_max_str = str ( maxval ( x ), fmt = fmt_ , decimals = decimals_ ) x_min_str = str ( minval ( x ), fmt = fmt_ , decimals = decimals_ ) x_abs_min_str = str ( minval ( abs ( x )), fmt = fmt_ , decimals = decimals_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if if ( len ( x_abs_min_str ) > len ( source ) ) source = x_abs_min_str allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ , decimals = decimals_ ) end do call aprint ( x_str ) end procedure aprint_2dr32 module procedure aprint_1di64 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di64 module procedure aprint_1di32 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di32 module procedure aprint_1di16 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di16 module procedure aprint_1di8 character ( len = :), allocatable , dimension (:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source integer :: i if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )), source = source ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i ) = str ( x ( i ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_1di8 module procedure aprint_2di64 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di64 module procedure aprint_2di32 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di32 module procedure aprint_2di16 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di16 module procedure aprint_2di8 character ( len = :), allocatable , dimension (:,:) :: x_str character ( len = :), allocatable :: fmt_ , x_max_str , x_min_str , source , str_tmp integer :: i , j if ( . not . present ( fmt ) ) then fmt_ = 'i' else if ( any ( INT_FMTS == fmt ) ) then fmt_ = fmt else fmt_ = 'i' end if end if x_max_str = str ( maxval ( x ), fmt = fmt_ ) x_min_str = str ( minval ( x ), fmt = fmt_ ) if ( len ( x_max_str ) > len ( x_min_str ) ) then source = x_max_str else source = x_min_str end if allocate ( x_str ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )), source = source ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) x_str ( i , j ) = str ( x ( i , j ), fmt = fmt_ ) end do call aprint ( x_str ) end procedure aprint_2di8 module procedure aprint_1dchar type ( String ), allocatable , dimension (:) :: rows integer :: i allocate ( rows ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) if ( i == lbound ( x , dim = 1 ) ) then if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = LF // '    ' // adjustl ( x ( i ) ) // LF else rows ( i )% s = LF // '    ' // adjustl ( x ( i ) ) end if else if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = '    ' // adjustl ( x ( i ) ) // LF else rows ( i )% s = '    ' // adjustl ( x ( i ) ) end if end do do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) write ( * , '(a)' ) rows ( i )% s end do end procedure aprint_1dchar module procedure aprint_2dchar type ( String ), allocatable , dimension (:) :: rows integer :: i allocate ( rows ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) if ( i == lbound ( x , dim = 1 ) ) then if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = LF // '    ' // accum ( x ( i ,:) ) // LF else rows ( i )% s = LF // '    ' // accum ( x ( i ,:) ) end if else if ( i == ubound ( x , dim = 1 ) ) then rows ( i )% s = '    ' // accum ( x ( i ,:) ) // LF else rows ( i )% s = '    ' // accum ( x ( i ,:) ) end if end do do i = lbound ( x , dim = 1 ), ubound ( x , dim = 1 ) write ( * , '(a)' ) rows ( i )% s end do contains pure recursive function accum ( x ) result ( x_str ) character ( len =* ), dimension (:), intent ( in ) :: x character ( len = :), allocatable :: x_str integer :: x_len , x_size , i , pos x_len = len ( x ) x_size = size ( x ) if ( x_size == 1 ) then x_str = x ( 1 ); return end if if ( x_len == 0 ) then x_str = EMPTY_STR ; return end if allocate ( character ( len = x_len * x_size + x_size - 1 ) :: x_str ) positional_transfer : do concurrent ( i = 1 : x_size ) pos = ( i - 1 ) * ( x_len + 1 ) + 1 x_str ( pos : pos + x_len - 1 ) = adjustl ( x ( i )) if ( i < x_size ) x_str ( pos + x_len : pos + x_len ) = SPACE end do positional_transfer end function accum end procedure aprint_2dchar module procedure aprint_1dString character ( len = :), allocatable , dimension (:) :: char_arr integer , allocatable , dimension (:) :: lengths integer :: i , max_length lengths = x % len () max_length = maxval ( lengths ) allocate ( character ( len = max_length ) :: char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) ) do concurrent ( i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) if ( lengths ( i ) < 1 ) then char_arr ( i ) = EMPTY_STR else char_arr ( i ) = x ( i )% s end if end do call aprint ( char_arr ) end procedure aprint_1dString module procedure aprint_2dString character ( len = :), allocatable , dimension (:,:) :: char_arr integer , allocatable , dimension (:,:) :: lengths integer :: i , j , max_length lengths = x % len () max_length = maxval ( lengths ) allocate ( character ( len = max_length ) :: & char_arr ( lbound ( x , dim = 1 ): ubound ( x , dim = 1 ), lbound ( x , dim = 2 ): ubound ( x , dim = 2 )) ) do concurrent ( j = lbound ( x , dim = 2 ): ubound ( x , dim = 2 ), i = lbound ( x , dim = 1 ): ubound ( x , dim = 1 )) if ( lengths ( i , j ) < 1 ) then char_arr ( i , j ) = EMPTY_STR else char_arr ( i , j ) = x ( i , j )% s end if end do call aprint ( char_arr ) end procedure aprint_2dString end submodule array_printing !====================================================================================================================== !\tList of workarounds for compiler bugs in ifx 2023.0.0 : !\t------------------------------------------------------- !\t1.\tIn join_into_self (line 4808), the recursive call to join_into_self at line 4836 induces a run-time !\t\tsegmentation fault in the program contained in benchmark.f90 not seen with the following compilers: ifort !\t\t2021.8.0, gfortran 11.3.0, gfortran 11.2.0. From investigation, the segmentation fault seems due to the passing !\t\tof the array of derived type. The fault occurs in a majority of runs, but not in every run. To avoid the fault, !\t\tthe array to be passed must be constructed element by element and passed as in the \"else\" section of the \"if\" !\t\tblock. The fault again seems to be induced only when \"-heap-arrays 0\" is specified and only with ifx 2023.0.0. !======================================================================================================================","tags":"","loc":"sourcefile/io_fortran_lib.f90.html"},{"title":"API Design – IO-Fortran-Library","text":"The API is made available for use through the following statement: use io_fortran_lib which may be placed at the start of any compilation unit, immediately following the program , module , function , or subroutine statement, and before any implicit statement. The functionality provided by the API is distributed via a handful of generic interfaces and a derived type String . The corresponding routines operate on numeric and string data, and take a minimal number of arguments with optional arguments to customize output for particular use cases. This ensures ease of use and flexibility for the end-user, without the need for any specific knowledge regarding the internal implementations. For advanced character handling, the String type provides extensive functionality through type-bound procedures . For convenience, a list of constants are also provided. The design of io_fortran_lib is dualistic in nature. That is, for each operation represented by an interface, there exists a transpose operation with a corresponding interface, such as String ⇆ cast , str ⇆ cast , to_file ⇆ from_file , read_file ⇆ write_file , join ⇆ split , and so on. Each pair of interfaces are designed to mirror each other in their arguments and assumptions of optional arguments. Note All file I/O (both text and binary) is conducted via unformatted, stream-access reads and writes as introduced in Fortran 2003.","tags":"","loc":"page/index.html"},{"title":"Important User Information – IO-Fortran-Library","text":"The following subsections detail important information for users: Numeric text formats Locales File extensions Compiler-dependent behavior Character sets and kinds Thread safety","tags":"","loc":"page/UserInfo/index.html"},{"title":"Numeric text formats – IO-Fortran-Library","text":"When writing integer data as strings with String , str , or to_file , any of the following text formats may be used: INT_FMTS = [ 'i' , 'z' ] 'i' : integer format (default), e.g. 123456 'z' : hexadecimal format, e.g. 0x1e240 When writing floating point numbers of type real or complex as strings with String , str , or to_file , any of the following text formats may be used: REAL_FMTS = [ 'e' , 'f' , 'z' ] 'e' : normalized exponential format (default), e.g. 1.23456789012345675e+005 'f' : decimal format, e.g. 123456.789012345674 'z' : hexadecimal format, e.g. 0x40fe240c9fcb68cd Note The 'z' hexadecimal format is an unsigned integer format and may be used for integer , real , or complex data. Floating point numbers are interpreted bit-wise as unsigned integers when written with the 'z' format, preventing any loss of precision in a round-trip conversion. This format is preferred in data transfers for which precision losses are intolerable. The 'z' format may also be preferred for faster read/write times and more compact storage. When moving data in the opposite direction with the complementary procedures cast or from_file , the same fmt is required to properly cast the data. Specifying a fmt that is different from what is actually present may result in an I/O syntax error. Note By default, real and complex data will be written with a number of significant digits required for a lossless round-trip conversion of the form numeric -> string -> numeric . In general, one may expect the f format to produce losses in round-trip conversion of up to a few epsilon in as many as a fifth of transfers. However, the e format is not expected to produce any losses, and the z format will never produce losses as it involves direct bit transfer (no base-10 ⇆ base-2 conversions are involved). Note For negative integers, the hexadecimal format 'z' produces ambiguities across storage sizes. For instance, the integer 0xff equates to -1 in int8 storage but equates to 255 in larger storage sizes. Similarly, the integer 0xffff equates to -1 in int16 storage but equates to 65535 in larger storage sizes, and so on. It is the responsibility of the programmer to cast hexadecimal strings into variables with the proper storage size.","tags":"","loc":"page/UserInfo/text-fmts.html"},{"title":"Locales – IO-Fortran-Library","text":"When writing floating point numbers of type real or complex as strings with String , str , or to_file , any of the following locales may be used: LOCALES = [ 'US' , 'EU' ] 'US' : US decimal (default), e.g. 1.23456789 'EU' : EU decimal, e.g. 1,23456789 With to_file and from_file , the locale additionally determines the default delimiter, e.g. 1.23456789,0.12345678 for locale='US' and 1,23456789;0,12345678 for locale='EU' . When moving data in the opposite direction with the complementary procedures cast or from_file , the same locale is required to properly read the decimals. Specifying a locale that is different from what is actually present may result in an I/O syntax error.","tags":"","loc":"page/UserInfo/locale-fmts.html"},{"title":"File extensions – IO-Fortran-Library","text":"When writing to file or reading from file, a valid file extension must be present. The following are valid text file extensions: TEXT_EXT = [ 'csv' , 'txt' , 'log' , 'rtf' , 'odm' , 'odt' , 'ods' , 'odf' , 'xls' , 'doc' , 'org' , 'dbf' , & 'bed' , 'gff' , 'gtf' ] The following are valid binary file extensions: BINARY_EXT = [ 'dat' , 'bin' ] The routines to_file and from_file will detect the file extension used and direct whether to write/read a text file or a binary file. The routines echo , write_file , and read_file accept only text extensions. Other file extensions may be eligible for addition.","tags":"","loc":"page/UserInfo/file-ext.html"},{"title":"Compiler-dependent behavior – IO-Fortran-Library","text":"When writing text files, it's important to note that some compilers implement extensions to the Fortran standard by default with regards to character array literals. For example, the array literal header = [ 'firstcol' , 'secondcol' ] is not standard Fortran 2018 since the strings in the array do not have identical length. Some compilers will accept this and others will not. If required, simply add padding spaces to the left or right of each string to match the length of the longest element. These padding spaces will not be present in the output file. Note Some compilers may allocate strings dynamically on the stack. When reading large text files, this may result in a stack overflow or segmentation fault unless the compiler is directed to allocate everything on the heap. For example, one would specify -heap-arrays 0 for the Intel Fortran compiler on Linux ( /heap-arrays:0 on Windows).","tags":"","loc":"page/UserInfo/compilers.html"},{"title":"Character sets and kinds – IO-Fortran-Library","text":"The IO-Fortran-Library officially supports the standard Fortran character set, based on the US-ASCII character set with default character kind . On most systems, the default kind will consist of precisely one byte per character, equivalent to selected_char_kind('ascii') . Since US-ASCII is a 7-bit character set and most systems use 8-bit characters, it must be noted that only the first 128 characters are system-independent, i.e. achar(0) is portable but achar(255) is not. To maximize portability across systems and compilers, the IO-Fortran-Library does not reference any other character sets or kinds other than the 128-character US-ASCII with default kind . However, most users should feel free to employ characters outside of the US-ASCII in strings and string expressions (including many Unicode symbols) and these will tend to behave as expected as long as the characters can fit comfortably into one byte and the output unit supports UTF-8 encoding. For instance, inspect the output of the following program: program main use io_fortran_lib implicit none ( type , external ) type ( String ) :: emojis emojis = '😂🙈😊🤣' + '😍' - '😂' + '👌' ** 5 call emojis % echo ( 'emojis.txt' ) write ( * , * ) emojis end program main The expected result is 🙈😊🤣😍👌👌👌👌👌 , which will be displayed properly in any terminal or text file with UTF-8 encoding. Note The Fortran standard permits compilers to support character sets and kinds other than US-ASCII with one-byte kind , and acknowledges the extended four-byte UCS-4 character set defined by ISO 10646, but such support is highly inconsistent across compilers at the time of writing.","tags":"","loc":"page/UserInfo/characters.html"},{"title":"Thread safety – IO-Fortran-Library","text":"The IO-Fortran-Library promotes thread-safety by explicitly enforcing recursion with the recursive keyword on all module procedures. However, performing I/O in parallel regions has the tendency to result in unexpected behavior. For instance, inspect the output of the following program with multiple coarray images: program main use io_fortran_lib implicit none ( type , external ) call echo ( 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end program main This program will result in conflicts as multiple images attempt to write to the same file concurrently. The proper way to compose this program is by nesting echo inside a critical block to enforce strict thread-safety in the region: program main use io_fortran_lib implicit none ( type , external ) critical call echo ( 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end critical end program main Another common scenario involves performing I/O on a single image, which is thread-safe: program main use io_fortran_lib implicit none ( type , external ) if ( this_image () == 1 ) then call echo ( 'Hello from image ' // str ( this_image ()), file_name = 'hello.txt' ) end if end program main","tags":"","loc":"page/UserInfo/thread-safety.html"},{"title":"Reference Guide – IO-Fortran-Library","text":"The following subsections provide user instructions for each of the publicly accessible interfaces : String : Function for returning a String representation of numbers. str : Function for returning a character representation of a number. cast : Subroutine for casting between numeric and string data. join and split : Functions for joining and splitting strings. to_file : Subroutine for writing an array of uniform numeric data type to an external file. from_file : Subroutine for reading an external file of uniform numeric data type and format into an array. echo : Subroutine for writing a scalar character or String to an external text file. aprint : Subroutine for printing arrays and array sections to stdout. String methods : Type-bound procedures for String . Operators : Extended operators for convenient string manipulations.","tags":"","loc":"page/Ref/index.html"},{"title":"CONSTANTS – IO-Fortran-Library","text":"The io_fortran_lib module provides access to a handful of parameter constants for general use: NL : The newline character (system agnostic). SPACE : The space character. CR : The carriage return character. FF : The form feed character. VT : The vertical tab character. LF : The line feed character. TAB : The horizontal tab character. HT : The horizontal tab character (alternate name). BELL : The bell/alert character. NUL : The null character. CNUL : The C null character re-exported from iso_c_binding . EMPTY_STR : The empty string.","tags":"","loc":"page/Ref/constants.html"},{"title":"String – IO-Fortran-Library","text":"interface String Description : Function for returning a String representation of numbers. To return the empty String , use no arguments: result = String () For x a scalar or array of any rank and of type character : result = String ( x ) This is for character to String conversion. For x a scalar or array of any rank and of type integer : result = String ( x , fmt ) fmt is optional , may be one of INT_FMTS For x a scalar or array of any rank and of type real : result = String ( x , locale , fmt , decimals ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x a scalar or array of any rank and of type complex : result = String ( x , locale , fmt , decimals , im ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note Unlike str , which takes scalar arguments only and returns a character , String operates elementally and returns a String . Optional Arguments Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'e' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Locales (default is 'US' ): LOCALES = [ 'US' , 'EU' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By default, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as a sum with the specified imaginary unit, e.g. 2.45+3.45j for im='j' or 2.45+3.45*1i for im='*1i' .","tags":"","loc":"page/Ref/String.html"},{"title":"str – IO-Fortran-Library","text":"interface str Description : Function for returning a character representation of a number. To return the empty string , use no arguments: result = str () For x a scalar of type String : result = str ( x ) This is for scalar String to character conversion. For x a scalar of type integer : result = str ( x , fmt ) fmt is optional , may be one of INT_FMTS For x a scalar of type real : result = str ( x , locale , fmt , decimals ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x a scalar of type complex : result = str ( x , locale , fmt , decimals , im ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note Note that str operates on scalars only. For elemental functionality, see String . Optional Arguments Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'e' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Locales (default is 'US' ): LOCALES = [ 'US' , 'EU' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By default, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as a sum with the specified imaginary unit, e.g. 2.45+3.45j for im='j' or 2.45+3.45*1i for im='*1i' .","tags":"","loc":"page/Ref/str.html"},{"title":"cast – IO-Fortran-Library","text":"interface cast Description : Subroutine for casting between numeric and string data. Casting numbers to string variables For casting x of type integer into a variable into of type character (scalar only) or String (any rank): call cast ( x , into , fmt ) fmt is optional , may be one of INT_FMTS For casting x of type real into a variable into of type character (scalar only) or String (any rank): call cast ( x , into , locale , fmt , decimals ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For casting x of type complex into a variable into of type character (scalar only) or String (any rank): call cast ( x , into , locale , fmt , decimals , im ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Note While str and String return values which may be used flexibly inside of string expressions, cast may be used as above to write directly to variables. When converting large amounts of data to strings, cast may be up to 2x faster than the functional alternatives since the total number of string allocations is reduced by at least half, all else being equal. Casting strings to numeric variables For casting substring of type character (scalar only) or String (any rank) into a variable into of type integer : call cast ( substring , into , fmt ) call substring % cast ( into , fmt ) fmt is optional , may be one of INT_FMTS For casting substring of type character (scalar only) or String (any rank) into a variable into of type real : call cast ( substring , into , locale , fmt ) call substring % cast ( into , locale , fmt ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS For casting substring of type character (scalar only) or String (any rank) into a variable into of type complex : call cast ( substring , into , locale , fmt , im ) call substring % cast ( into , locale , fmt , im ) locale is optional , may be one of LOCALES fmt is optional , may be one of REAL_FMTS im is optional and of type character(len=*) Warning The arguments x and substring must always be of the same rank and shape as into , which must be pre-allocated prior to calling cast due to the restrictions on intent(out) arguments of elemental procedures. Note The type-bound procedure access of the form call substring%cast() is valid when substring is a String variable. To cast a String -valued expression, the expression must be passed to cast by the form call cast() . Optional Arguments Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'e' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Locales (default is 'US' ): LOCALES = [ 'US' , 'EU' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. If not present, complex numbers will be assumed to be written as ordered pairs, e.g. (2.45,3.45) .","tags":"","loc":"page/Ref/cast.html"},{"title":"join and split – IO-Fortran-Library","text":"interface join Description : Function for joining a vector of tokens into a scalar character or String . To join a one-dimensional array tokens of type character or String : result = join ( tokens , separator ) separator is optional and of type character(len=*) For a subroutine version of join , see join . Note The return type of join is the same as the type of tokens . interface split Description : Function for splitting a scalar character or String into a vector of tokens . For substring a scalar character or String : result = split ( substring , separator ) separator is optional and of type character(len=*) For substring a scalar variable of type String : result = substring % split ( separator ) Note The type-bound procedure access of the form substring%split() is valid when substring is a String variable. To split a String -valued expression, the expression must be passed to split by the form split(substring) . Note The return type of split is always String . Optional Arguments Separator (default is SPACE ): the separator to use when joining or splitting.","tags":"","loc":"page/Ref/join-split.html"},{"title":"to_file – IO-Fortran-Library","text":"interface to_file Description : Subroutine for writing an array of uniform numeric data type to an external file. For x an array of rank 1 , 2 and of type integer : call to_file ( x , file_name , header , dim , delim , fmt ) call to_file ( x , file_name , header , delim , fmt ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer (available only if x has rank 1 ) delim is optional and of type character(len=*) fmt is optional , may be one of INT_FMTS For x an array of rank 1 , 2 and of type real : call to_file ( x , file_name , header , dim , locale , delim , fmt , decimals ) call to_file ( x , file_name , header , locale , delim , fmt , decimals ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer (available only if x has rank 1 ) locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x an array of rank 1 , 2 and of type of type complex : call to_file ( x , file_name , header , dim , locale , delim , fmt , decimals , im ) call to_file ( x , file_name , header , locale , delim , fmt , decimals , im ) file_name is of type character(len=*) header is optional and of type character(len=*), dimension(:) dim is optional and of type integer (available only if x has rank 1 ) locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) For x an array of any rank 3 - 15 and of type integer , real , complex : call to_file ( x , file_name ) file_name is of type character(len=*) Note file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Note to_file will always use the NL line ending when writing text files (which on most systems equates to LF ). Optional Arguments Header (default is none): header is a character array literal . For x of rank 1 , header may be of size 1 or size(x) . For x of rank 2 , header may be of size 1 or size(x, dim=2) . Dimension: dim specifies whether to write along the rows ( dim=1 ) or along the columns ( dim=2 ), choosing the former by default unless size(header) is size(x) . This option is available only if x has rank 1 . Locales (default is 'US' ): LOCALES = [ 'US' , 'EU' ] Delimiter: data separator. Default is ',' for integer data and for real / complex data with 'US' locale, and ';' for real / complex data with 'EU' locale. It is always recommended to omit the delimiter argument for default unless a custom delimiter is really necessary. If x has rank 1 and dim=1 , then the delim argument is ignored. Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'e' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Decimals: decimals specifies the number of digits on the rhs of the radix point, with a default determined internally based on the text format and precision. Imaginary unit: im specifies the form of a complex number. By default, complex numbers will be written as ordered pairs, e.g. (2.45,3.45) . If im is specified, then the number will be written as a sum with the specified imaginary unit, e.g. 2.45+3.45j for im='j' or 2.45+3.45*1i for im='*1i' .","tags":"","loc":"page/Ref/to_file.html"},{"title":"from_file – IO-Fortran-Library","text":"interface from_file Description : Subroutine for reading an external file of uniform numeric data type and format into an array. For reading textual data into an array into of rank 1 or 2 and of type integer : call from_file ( file_name , into , header , delim , fmt ) file_name is of type character(len=*) header is optional and of type logical delim is optional and of type character(len=*) fmt is optional , may be one of INT_FMTS For reading textual data into an array into of rank 1 or 2 and of type real : call from_file ( file_name , into , header , locale , delim , fmt ) file_name is of type character(len=*) header is optional and of type logical locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS For reading textual data into an array into of rank 1 or 2 and of type complex : call from_file ( file_name , into , header , locale , delim , fmt , im ) file_name is of type character(len=*) header is optional and of type logical locale is optional , may be one of LOCALES delim is optional and of type character(len=*) fmt is optional , may be one of REAL_FMTS im is optional and of type character(len=*) For reading binary data into an array into of any rank 1 - 15 and of type integer , real , complex : call from_file ( file_name , into , data_shape ) file_name is of type character(len=*) data_shape is of type integer, dimension(:) Note file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Warning In all cases, into must be allocatable , and will lose its allocation status upon passing into from_file if already allocated. As a result, from_file does not allow reading into sections of already allocated arrays. Note When reading binary data, data_shape must be present and its size must equal the rank of into . Optional Arguments Header (default is .false. ): specifies whether a header line is present. Locales (default is 'US' ): LOCALES = [ 'US' , 'EU' ] Delimiter: data separator. Default is ',' for integer data and for real / complex data with 'US' locale, and ';' for real / complex data with 'EU' locale. It is always recommended to omit the delimiter argument for default unless a custom delimiter is really necessary. If x has rank 1 and the data is ordered down the rows, then the delim argument is ignored. Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'e' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Imaginary unit: im specifies the form of a complex number. If not present, complex numbers will be assumed to be written as ordered pairs, e.g. (2.45,3.45) .","tags":"","loc":"page/Ref/from_file.html"},{"title":"echo – IO-Fortran-Library","text":"interface echo Description : Subroutine for writing a scalar character or String to an external text file. For substring a scalar of type character or String : call echo ( substring , file_name , append , terminator ) substring is of type character(len=*) or String file_name is of type character(len=*) append is optional and of type logical terminator is optional and of type character(len=*) For substring a scalar variable of type String : call substring % echo ( file_name , append , terminator ) Note The type-bound procedure access of the form call substring%echo() is valid when substring is a String variable. To echo a String -valued expression, the expression must be passed to echo by the form call echo() . Note file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Optional Arguments Append (default is .true. ): append specifies whether to append or to replace the file file_name . Either way, the file will be created if it does not exist. Terminator (default is LF ): terminator is a string terminator inserted at the end of the input string.","tags":"","loc":"page/Ref/echo.html"},{"title":"aprint – IO-Fortran-Library","text":"interface aprint Description : Subroutine for printing arrays and array sections to stdout. For x an array of rank 1 or 2 and of type character or String : call aprint ( x ) For x an array of rank 1 or 2 and of type integer : call aprint ( x , fmt ) fmt is optional , may be one of INT_FMTS For x an array of rank 1 or 2 and of type real : call aprint ( x , fmt , decimals ) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer For x an array of rank 1 or 2 and of type complex : call aprint ( x , fmt , decimals , im ) fmt is optional , may be one of REAL_FMTS decimals is optional and of type integer im is optional and of type character(len=*) Optional Arguments Integer formats (default is 'i' ): INT_FMTS = [ 'i' , 'z' ] Real formats (default is 'f' ): REAL_FMTS = [ 'e' , 'f' , 'z' ] Decimals (default is 2 ): decimals specifies the number of digits on the rhs of the radix point. Imaginary unit (default is 'j' ): im specifies the form of a complex number. Note The optional arguments for aprint are different than elsewhere, and better suited for easy viewing of array sections.","tags":"","loc":"page/Ref/aprint.html"},{"title":"String methods – IO-Fortran-Library","text":"type String Description : A growable string type for advanced character handling and text I/O. Note In addition to the functionality provided through type-bound procedures, the String type may be useful in array contexts for which the user requires arrays of strings which may have non-identical lengths, whose lengths may not be known, whose lengths may need to vary during run time, or in any other context in which the intrinsic character type is insufficient. Type-bound procedures as_str For self a scalar variable of type String : result = self % as_str () Description : Returns a copy of the string slice component of a scalar String . This procedure is identical in function to the type conversion result = str(self) . cast Description : A generic binding for the interface cast . count For self a scalar or array variable of any rank and of type String : result = self % count ( match ) match is of type character(len=*) or String Description : Returns number of non-overlapping occurrences of a substring elementally. Note match may be a scalar or the same rank and shape as self . echo Description : A generic binding for the interface echo . empty For self a scalar or array variable of any rank and of type String : call self % empty () Description : Sets the string slice component to the empty string elementally. This procedure is identical in function to the assignment self = String() . join For self a scalar variable of type String : call self % join ( tokens , separator ) tokens is of type type(String), dimension(:) separator is optional and of type character(len=*) (default is SPACE ) Description : Joins a String vector tokens into self with given separator. Default separator is SPACE . The string slice component will be replaced if already allocated. For a functional version of join , see join . len For self a scalar or array variable of any rank and of type String : result = self % len () Description : Returns the length of the string slice component elementally. Unallocated components return -1 . For strings larger than 2,147,483,647 bytes, use self%len64() . push For self a scalar or array variable of any rank and of type String : call self % push ( substring ) substring is of type character(len=*) or String Description : Appends to the string slice component elementally in place. This procedure is identical in function to the concatenation operators with self assignment: self = self // substring and self = self + substring . Note substring may be a scalar or the same rank and shape as self . read_file For self a scalar variable of type String : call self % read_file ( file_name , cell_array , row_separator , column_separator ) file_name is of type character(len=*) cell_array is optional and of type type(String), allocatable, dimension(:,:) row_separator is optional and of type character(len=*) (default is LF ) column_separator is optional and of type character(len=*) (default is ',' ) Description : Reads raw text file contents into self and optionally populates a cell array using the designated row_separator and column_separator whose default values are LF and ',' respectively. Note file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. Note The cell_array must be allocatable and will be re-allocated internally (if already allocated). replace For self a scalar or array variable of any rank and of type String : result = self % replace ( match , substring , back ) match is of type character(len=*) or String substring is of type character(len=*) or String back is optional and of type logical (default is .false. ) Description : Matches and replaces all occurrences of a substring elementally. If back is .true. , then self is scanned from back to front, which may result in a different outcome in the case that match is overlapping itself. Note match and substring may be any combination of character and String , and may be any combination of scalars or arrays with the same rank and shape as self , with the same rank/shape matching rules applying to back . replace_inplace For self a scalar or array variable of any rank and of type String : call self % replace_inplace ( match , substring , back ) match is of type character(len=*) or String substring is of type character(len=*) or String back is optional and of type logical (default is .false. ) Description : Matches and replaces all occurrences of a substring elementally in place. If back is .true. , then self is scanned from back to front, which may result in a different outcome in the case that match is overlapping itself. Note match and substring may be any combination of character and String , and may be any combination of scalars or arrays with the same rank and shape as self , with the same rank/shape matching rules applying to back . split Description : A generic binding for the interface split . trim For self a scalar or array variable of any rank and of type String : result = self % trim () Description : Returns a copy of a String elementally in which each string slice component has been trimmed of any leading or trailing whitespace. trim_inplace For self a scalar or array variable of any rank and of type String : call self % trim_inplace () Description : Removes any leading or trailing whitespace of the string slice component of a String elementally and in place. write_file For self a scalar variable of type String : call self % write_file ( cell_array , file_name , row_separator , column_separator , append ) cell_array is of type type(String), dimension(:,:) file_name is of type character(len=*) row_separator is optional and of type character(len=*) (default is LF ) column_separator is optional and of type character(len=*) (default is ',' ) append is optional and of type logical (default is .false. ) Description : Writes the content of a cell array to a text file. The cell array's entire contents are populated into self using the designated row_separator and column_separator whose default values are LF and ',' respectively, and then streamed to an external text file. The file will be created if it does not exist, and will be appended to if append is .true. . Note file_name may be a relative path, but absolute paths are not guaranteed to work on every platform. write(formatted) For substring a scalar or array of any rank and of type String : print '(DT)' , substring write ( unit , '(DT)' ) substring Description : Formatted write DTIO procedure for type String . Note When performing a formatted write to unit , use the derived-type edit descriptor format fmt='(DT)' .","tags":"","loc":"page/Ref/String-methods.html"},{"title":"Operators – IO-Fortran-Library","text":"Operator interfaces Description : Extended operators for convenient string manipulations. Concatenation ( // and + ) For x and y scalars or arrays of any compatible rank, and of any combination of type character and String : result = x // y result = x + y Note Concatenation of mixed type will return a String . Excision ( - ) For x and y scalars or arrays of any compatible rank, and of any combination of type character and String : result = x - y Note Excision always returns a String value even when both arguments are of type character . This ensures that excision can be performed elementally even for character values, which would not be well-defined with a return type of character . For two scalar character values, one may simply perform the conversion result = str(x - y) to return a scalar character . Note String arithmetic is not associative, commutative, or distributive in general: (Associative) (x + y) + z == x + (y + z) and x + (y - z) /= (x + y) - z are both .true. in general. (Commutative) x + y /= y + x and x + y - z /= x - z + y are both .true. in general. (Distributive) x - (y + z) /= x - y - z is .true. in general. Repetition ( ** ) For x a scalar or array of any rank, and of type character or String : result = x ** ncopies ncopies is of type integer Note The ** operator is a wrapper for the repeat intrinsic, and extended for type String . Equivalence ( == ) For x and y scalars or arrays of any compatible rank, and of any combination of type character and String : result = ( x == y ) result = ( x . eq . y ) Non-equivalence ( /= ) For x and y scalars or arrays of any compatible rank, and of any combination of type character and String : result = ( x /= y ) result = ( x . ne . y )","tags":"","loc":"page/Ref/operators.html"},{"title":"Tutorials – IO-Fortran-Library","text":"The following subsections provide example programs for common use cases of the public interfaces : Handling csv files Handling dat files Handling log files String manipulation FizzBuzz NGS Human Core Exome Panel Benchmarking","tags":"","loc":"page/Examples/index.html"},{"title":"Handling csv files – IO-Fortran-Library","text":"Basic csv file I/O The routines to_file and from_file are the preferred method for handling I/O for numeric data of uniform type and format. Typical use cases involve writing whole arrays to file and reading files of uniform type and format directly into an array of numeric type. The following program demonstrates the use of to_file and from_file for writing an array of real data to a csv file in each possible text format , reading each file back into the program, and testing for exact equality to ensure that there has been no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_e , x_f , x_z call random_number ( x ) call to_file ( x , file_name = 'x_e.csv' , header = [ 'x' ], fmt = 'e' ) call to_file ( x , file_name = 'x_f.csv' , header = [ 'x' ], fmt = 'f' ) call to_file ( x , file_name = 'x_z.csv' , header = [ 'x' ], fmt = 'z' ) call from_file ( 'x_e.csv' , into = x_e , header = . true ., fmt = 'e' ) call from_file ( 'x_f.csv' , into = x_f , header = . true ., fmt = 'f' ) call from_file ( 'x_z.csv' , into = x_z , header = . true ., fmt = 'z' ) write ( * , * ) 'x == x_e : ' , all ( x == x_e ) write ( * , * ) 'x == x_f : ' , all ( x == x_f ) write ( * , * ) 'x == x_z : ' , all ( x == x_z ) end program main Here we use the simple header header=['x'] , which produces a header of the form: x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20 Note that the default value for header when reading is .false. . If a header is actually present, the output array will have an extra row with default initialized values. Warning Default text format for writing and reading is 'e' for data of type real or complex , and 'i' for data of type integer . Attempting to read data with a format that does not correspond to the format in the file may result in an I/O syntax error. Note Reading into arrays of a different kind than the array that was written is a type conversion, and will fail the equality test. Advanced csv file I/O The routines write_file and read_file are the preferred method for handling I/O for general text files. Typical use cases involve writing cell arrays of type String to delimited files, and reading delimited files into a cell array. For reading and writing non-delimited text files, one would use read_file without the cell_array argument and echo . The same program as above can be recast in an object-oriented fashion that is generalizable for processing data of mixed type: program main use io_fortran_lib , only : String , str implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:) :: header type ( String ), allocatable , dimension (:,:) :: cells real , dimension ( 1000 , 20 ) :: x real , allocatable , dimension (:,:) :: x_e , x_f , x_z integer :: i call random_number ( x ); allocate ( cells ( 1001 , 20 ) ); header = [( String ( 'x' // str ( i )), i = 1 , 20 )] cells ( 1 ,:) = header ; cells ( 2 :,:) = String ( x , fmt = 'e' ); call csv % write_file ( cells , file_name = 'x_e.csv' ) cells ( 1 ,:) = header ; cells ( 2 :,:) = String ( x , fmt = 'f' ); call csv % write_file ( cells , file_name = 'x_f.csv' ) cells ( 1 ,:) = header ; cells ( 2 :,:) = String ( x , fmt = 'z' ); call csv % write_file ( cells , file_name = 'x_z.csv' ) allocate ( x_e , x_f , x_z , mold = x ) call csv % read_file ( 'x_e.csv' , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_e , fmt = 'e' ) call csv % read_file ( 'x_f.csv' , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_f , fmt = 'f' ) call csv % read_file ( 'x_z.csv' , cell_array = cells ); call cells ( 2 :,:)% cast ( into = x_z , fmt = 'z' ) write ( * , * ) 'x == x_e : ' , all ( x == x_e ) write ( * , * ) 'x == x_f : ' , all ( x == x_f ) write ( * , * ) 'x == x_z : ' , all ( x == x_z ) end program main Here, we construct the same header as before with the implicit loop header = [( String ( 'x' // str ( i )), i = 1 , 20 )] and then construct the remainder of the cell array cells with an elemental assignment cells(2:,:) = String(x, fmt) before writing the array to a csv file. We then read the files back into csv and output the cells into cells (which is reallocated internally). Note that when casting the cell data into numeric arrays, we must pre-allocate the output arrays due to the restrictions on intent(out) arguments of elemental procedures. Note also that we must reassign the header row to cells before writing each time because write_file consumes the cell array. Note One may optionally specify the arguments of row_separator and column_separator when writing and reading text files with write_file and read_file . The default row_separator is LF , and the default column_separator is ',' . Warning When reading files with CRLF line endings, be sure to specify row_separator=CR//LF or pre-process the file to LF . Trying to cast data with a hidden CR character may result in an I/O syntax error. For a slightly more advanced example, consider the following program to read in and cast the data of mixed type contained in the example data /data/ancestry_comp.csv : program main use , intrinsic :: iso_fortran_env , only : int8 , int64 use io_fortran_lib , only : String , cast , CR , LF , operator ( + ), operator ( - ) implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:,:) :: cells integer ( int8 ), allocatable , dimension (:) :: copy , chromosome integer ( int64 ), allocatable , dimension (:) :: start_point , end_point integer :: nrows call csv % read_file ( './data/ancestry_comp.csv' , cell_array = cells , row_separator = CR + LF ) write ( * , * ) csv nrows = size ( cells , dim = 1 ) - 1 allocate ( copy ( nrows ), chromosome ( nrows ), start_point ( nrows ), end_point ( nrows ) ) call cells ( 2 :, 2 )% cast ( into = copy ) call cast ( cells ( 2 :, 3 )% replace ( 'X' , '0' ) - 'chr' , into = chromosome ) call cells ( 2 :, 4 )% cast ( into = start_point ) call cells ( 2 :, 5 )% cast ( into = end_point ) end program main Here, file_name is a relative path, and we use the extended operator + for concatenation in the character expression CR+LF . We then allocate data arrays and cast each column into respective arrays. Note that we must use cast as a standalone subroutine to accept the String -valued expression cells ( 2 :, 3 )% replace ( 'X' , '0' ) - 'chr' which first calls replace to return an elemental copy of the given cells in which all instances of X have been replaced with 0 , and then calls the excision operator - to remove all instances of 'chr' elementally. The output of the String expression contains numeric characters only, which are then casted to the array chromosome . Note In general, for other text file extensions , one would specify the column_separator associated with the given file. For instance, one would specify column_separator=TAB for the file formats .bed , .gff , and .gtf .","tags":"","loc":"page/Examples/csv.html"},{"title":"Handling dat files – IO-Fortran-Library","text":"Binary file I/O The routines to_file and from_file are used for writing numeric arrays to binary files with the extension .dat or .bin . The following program demonstrates the use of to_file and from_file for writing real data of rank 5 to a .dat file, reading the file back into the program, and testing for exact equality to ensure that there has been no loss in precision: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 20 , 20 , 20 , 20 , 20 ) :: x real , allocatable , dimension (:,:,:,:,:) :: x_dat call random_number ( x ) call to_file ( x , file_name = 'x.dat' ) call from_file ( 'x.dat' , into = x_dat , data_shape = shape ( x )) write ( * , * ) 'x == x_dat : ' , all ( x == x_dat ) end program main Warning Reading into arrays of a different kind than the array that was written will invalidate the data. Always make sure the kind is matching for binary I/O. TIP: The shape of an array may be written to a csv file so that the value of data_shape can be read into the program before reading in the main array with the corresponding value. The following program demonstrates the above tip: program main use io_fortran_lib , only : to_file , from_file implicit none ( type , external ) real , dimension ( 20 , 20 , 20 , 20 , 20 ) :: x real , allocatable , dimension (:,:,:,:,:) :: x_dat integer , allocatable , dimension (:) :: x_shape call random_number ( x ) call to_file ( x , file_name = 'x.dat' ) call to_file ( shape ( x ), file_name = 'x_shape.csv' ) call from_file ( 'x_shape.csv' , into = x_shape ) call from_file ( 'x.dat' , into = x_dat , data_shape = x_shape ) write ( * , * ) 'x == x_dat : ' , all ( x == x_dat ) end program main","tags":"","loc":"page/Examples/binary.html"},{"title":"Handling log files – IO-Fortran-Library","text":"Log file I/O The routine echo is the preferred method for writing general text data to a log file. The following program demonstrates a simple use of echo for writing messages to a log file: program main use io_fortran_lib , only : echo , str , LF implicit none ( type , external ) character ( len = :), allocatable :: logfile , logmsg character ( len = 10 ) :: date , time integer :: errstat call date_and_time ( date = date , time = time ) logfile = 'logfile_main_' // trim ( adjustl ( date )) // '_' // time // '.log' logmsg = 'PROGRAM MAIN - BEGINNING EXECUTION' call echo ( logmsg // LF // repeat ( '-' , ncopies = len ( logmsg )), file_name = logfile ) ! ... logmsg = 'All is good so far...' call echo ( logmsg , logfile ) read ( * , * ) errstat if ( errstat /= 0 ) then logmsg = 'Process has non-zero exit status: ' // str ( errstat ) // LF // 'Stopping...' call echo ( logmsg , logfile ) error stop logmsg end if logmsg = 'All processes have executed successfully.' call echo ( logmsg , logfile ) end program main Depending on style, one may wish to accumulate log messages into a String and then call the type-bound procedure echo conditionally: program main use io_fortran_lib , only : String , str , LF , operator ( + ), operator ( ** ) implicit none ( type , external ) type ( String ) :: logmsg character ( len = :), allocatable :: logfile character ( len = 10 ) :: date , time integer :: errstat call date_and_time ( date = date , time = time ) logfile = 'logfile_main_' + trim ( adjustl ( date )) + '_' + time + '.log' logmsg = String ( 'PROGRAM MAIN - BEGINNING EXECUTION' ) call logmsg % push ( LF + '-' ** logmsg % len () + LF ) ! ... call logmsg % push ( 'All is good so far...' + LF ) read ( * , * ) errstat if ( errstat /= 0 ) then call logmsg % push ( 'Process has non-zero exit status: ' + str ( errstat ) + LF + 'Stopping...' ) call logmsg % echo ( logfile ) error stop logmsg % as_str () end if call logmsg % push ( 'All processes have executed successfully.' ) call logmsg % echo ( logfile ) end program main Here, the error stop will dump the entire contents of logmsg to stdout. We also take advantage of the operators + and ** for concatenation and repetition.","tags":"","loc":"page/Examples/logging.html"},{"title":"String manipulations – IO-Fortran-Library","text":"String Queries Sometimes it is useful or necessary to write execution conditions based on compiler vendors or version, such as when a certain compiler version has a known bug or when a piece of code is required for a specific compiler. The following program shows how one may use the count procedure to determine a compiler at runtime: program main use , intrinsic :: iso_fortran_env , only : compiler_version use io_fortran_lib , only : String implicit none ( type , external ) type ( String ) :: compiler logical :: GCC , GCC_RECENT , INTEL , INTEL_RECENT compiler = String ( compiler_version ()) GCC = compiler % count ( match = 'GCC' ) > 0 GCC_RECENT = GCC . and . ( compiler % count ( match = '11.3.0' ) > 0 ) INTEL = compiler % count ( match = 'Intel' ) > 0 INTEL_RECENT = INTEL . and . ( compiler % count ( match = '2023.0.0' ) > 0 ) write ( * , * ) compiler if ( GCC ) then if ( GCC_RECENT ) then write ( * , * ) 'Hello from a recent GNU Fortran Compiler.' else write ( * , * ) 'Hello from an older GNU Fortran Compiler.' end if else if ( INTEL ) then if ( INTEL_RECENT ) then write ( * , * ) 'Hello from a recent Intel Fortran Compiler.' else write ( * , * ) 'Hello from an older Intel Fortran Compiler.' end if end if end program main Dynamic string manipulation Using operator techniques and string methods , we may easily perform complex string manipulations during run time. The following program demonstrates the use of the String type and some type-bound procedures for manipulating a timestamp: program main use io_fortran_lib , only : String , join , split , LF , operator ( + ), operator ( - ) implicit none ( type , external ) type ( String ) :: time_stamp , new_time_stamp type ( String ), allocatable , dimension (:) :: tokens character ( len = 10 ) :: date , time call date_and_time ( date = date , time = time ) time_stamp = String ( 'Date : ' + date + LF + 'Time : ' + time ) write ( * , '(a)' ) 'ORIGINAL TIME STAMP:' + LF + time_stamp % as_str () + LF tokens = split ( time_stamp , separator = LF ) - 'Date : ' - 'Time : ' + [ ' : Date' , ' : Time' ] new_time_stamp = join ( tokens , separator = ' | ' ) write ( * , '(a)' ) 'RECONSTRUCTED TIME STAMP:' + LF + new_time_stamp % as_str () end program main This program produces the following sample output: ORIGINAL TIME STAMP:\nDate : 20230101  \nTime : 143355.897\n\nRECONSTRUCTED TIME STAMP:\n20230101   : Date | 143355.897 : Time","tags":"","loc":"page/Examples/manipulations.html"},{"title":"FizzBuzz – IO-Fortran-Library","text":"Division game The following program demonstrates the use of aprint for printing an array of Strings containing values of the first 100 FizzBuzz numbers: program main use io_fortran_lib , only : String , aprint implicit none ( type , external ) integer , allocatable , dimension (:) :: nums integer :: i nums = [( i , i = 1 , 100 )] call aprint ( FizzBuzz ( nums ) ) contains pure elemental type ( String ) function FizzBuzz ( number ) result ( res ) integer , intent ( in ) :: number if ( mod ( number , 5 ) /= 0 ) then if ( mod ( number , 3 ) /= 0 ) then res = String ( number ) else res = String ( 'fizz' ) end if else if ( mod ( number , 3 ) /= 0 ) then res = String ( 'buzz' ) else res = String ( 'fizzbuzz' ) end if end if end function FizzBuzz end program main","tags":"","loc":"page/Examples/fizzbuzz.html"},{"title":"NGS Human Core Exome Panel – IO-Fortran-Library","text":"Handling genomic data Fortran can serve as a valuable tool for heavy numerical calculations in Next Generation Sequencing (NGS) analysis, which may often involve reading and writing many large .bed files in succession. The IO-Fortran-Library is optimized for both performance and memory consumption when reading and writing large text files, streamlining performance for Fortran bioinformatics applications. To demonstrate the speed of file I/O, the following program reads the Twist Human Core Exome target .bed file for hg38 obtained from Twist Bioscience into a cell array and then writes the cell array to a new file in a round-trip, comparing the two files for an exact match and providing the total time elapsed: program main use , intrinsic :: iso_fortran_env , only : int64 , real64 , compiler_version use io_fortran_lib , only : String , str , TAB , operator ( + ), operator ( == ) implicit none ( type , external ) type ( String ) :: hg38 , hg38_new type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: t1 , t2 real ( real64 ) :: wall_time , rate call system_clock ( t1 ) call hg38 % read_file ( './data/hg38.bed' , cell_array = cells , column_separator = TAB ) call hg38_new % write_file ( cells , './data/hg38_new.bed' , column_separator = TAB ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , real64 ) / rate write ( * , '(a,l)' ) 'New file and original are exact match: ' , hg38_new == hg38 write ( * , '(a)' ) 'Wall time: ' + str ( wall_time , fmt = 'f' , decimals = 3 ) + ' s ' + & 'using compiler: \"' + compiler_version () + '\".' end program main The file hg38.bed is provided locally in /data and contains 192262 lines of TAB -delimited data. The following sample output is observed on Linux with highest optimizations enabled ( -O3 ): ---\nNew file and original are exact match: T\nWall time: 0.048 s using compiler: \"GCC version 11.3.0\".\n---\nNew file and original are exact match:  T\nWall time: 0.062 s using compiler: \"Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2023.0.0 Build 20221201\".\n---\nNew file and original are exact match:  T\nWall time: 0.070 s using compiler: \"Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.8.0 Build 20221119_000000\".\n--- Note With the Intel Fortran compiler ifx / ifort , we may need to specify -heap-arrays 0 to avoid a segmentation fault when reading a file of this size, as noted in compiler-dependent behavior .","tags":"","loc":"page/Examples/exome.html"},{"title":"Benchmarking – IO-Fortran-Library","text":"Big data I/O The IO-Fortran-Library is capable of reading and writing very large text files with efficiency, even those whose data size exceeds the 2,147,483,647 byte upper limit of the 32-bit signed integer. A program is provided in /test/benchmark.f90 for benchmarking the major internal and external text I/O routines of the IO-Fortran-Library: program main use , intrinsic :: iso_fortran_env , only : int64 , rk => real32 , dp => real64 , compiler_version , compiler_options use io_fortran_lib , only : String , cast , str , LF , operator ( + ) implicit none ( type , external ) type ( String ) :: csv type ( String ), allocatable , dimension (:,:) :: cells integer ( int64 ) :: t1 , t2 real ( dp ) :: wall_time , rate integer , parameter :: n = 15000 real ( rk ), allocatable , dimension (:,:) :: x , y allocate ( x ( n , n ), cells ( n , n ) ); call random_gauss ( x , 0.0_rk , 1.0_rk ) write ( * , '(a)' ) 'Compiler version: ' + compiler_version () write ( * , '(a)' ) 'Compiler options: ' + compiler_options () + LF call system_clock ( t1 ) call cast ( x , into = cells , fmt = 'z' ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , '(a)' ) 'Wall time for cast: ' + str ( wall_time , fmt = 'f' , decimals = 3 ) + ' s' write ( * , '(a)' ) 'Number of string conversions/second: ' + str ( nint ( size ( x ) / wall_time )) + LF call system_clock ( t1 ) call csv % write_file ( cells , file_name = 'bigx.csv' ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , '(a)' ) 'Wall time for write_file: ' + str ( wall_time , fmt = 'f' , decimals = 3 ) + ' s' write ( * , '(a)' ) 'Estimated file size: ' + str ( csv % len64 () / 1e9 , fmt = 'f' , decimals = 6 ) + ' GB' + LF call system_clock ( t1 ) call csv % read_file ( 'bigx.csv' , cell_array = cells ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , '(a)' ) 'Wall time for read_file: ' + str ( wall_time , fmt = 'f' , decimals = 3 ) + ' s' + LF call csv % empty (); allocate ( y ( n , n ) ) call system_clock ( t1 ) call cast ( cells , into = y , fmt = 'z' ) call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , dp ) / rate write ( * , '(a)' ) 'Wall time for cast: ' + str ( wall_time , fmt = 'f' , decimals = 3 ) + ' s' write ( * , '(a)' ) 'Number of string casts/second: ' + str ( nint ( size ( x ) / wall_time )) write ( * , '(a,l)' ) 'Data is exact match: ' , all ( x == y ) contains ! random_gauss end program main Here, we populate an n -by- n single-precision array x with samples from the standard Gaussian distribution and convert each to a hexadecimal string to populate a cell array, write the cell array to a text file 'bigx.csv' , read the file back into the program to re-populate the cell array, then finally cast the cell data into y and compare with x to observe an exact match. For n = 15000 , the total data size is 225e6 and the resulting csv file size is 2.47 GB . With highest optimizations enabled for each compiler on Linux ( -O3 ), we observe the following sample output: ---\nCompiler version: GCC version 11.3.0\nCompiler options: -I build/gfortran_93B6DA15423670F8 -mtune=generic -march=x86-64 -O3 -J build/gfortran_93B6DA15423670F8 -fpre-include=/usr/include/finclude/math-vector-fortran.h\n\nWall time for cast: 7.512 s\nNumber of string conversions/second: 29948728\n\nWall time for write_file: 15.658 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 18.444 s\n\nWall time for cast: 8.443 s\nNumber of string casts/second: 26646553\nData is exact match: T\n---\nCompiler version: Intel(R) Fortran Compiler for applications running on Intel(R) 64, Version 2023.0.0 Build 20221201\nCompiler options: -Ibuild/ifx_810FD198DC3B0576 -c -O3 -heap-arrays 0 -module build/ifx_810FD198DC3B0576 -o build/ifx_810FD198DC3B0576/IO-Fortran-Library/test_benchmark.f90.o\n\nWall time for cast: 13.283 s\nNumber of string conversions/second: 16937918\n\nWall time for write_file: 15.347 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 22.252 s\n\nWall time for cast: 7.942 s\nNumber of string casts/second: 28329900\nData is exact match:  T\n---\nCompiler version: Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.8.0 Build 20221119_000000\nCompiler options: -Ibuild/ifort_810FD198DC3B0576 -c -O3 -heap-arrays 0 -module build/ifort_810FD198DC3B0576 -o build/ifort_810FD198DC3B0576/IO-Fortran-Library/test_benchmark.f90.o\n\nWall time for cast: 14.117 s\nNumber of string conversions/second: 15937621\n\nWall time for write_file: 13.125 s\nEstimated file size: 2.474999 GB\n\nWall time for read_file: 23.753 s\n\nWall time for cast: 9.835 s\nNumber of string casts/second: 22875860\nData is exact match:  T\n--- Note With the Intel Fortran compiler ifx / ifort , we must specify -heap-arrays 0 to avoid a segmentation fault when reading a file of this size, as noted in compiler-dependent behavior . For a more extreme example, consider the following program to write every 32-bit integer as a hexadecimal string to a text file int32.txt : program main use , intrinsic :: iso_fortran_env , only : int64 , real64 use io_fortran_lib , only : String , cast , str , LF , operator ( + ) implicit none ( type , external ) type ( String ) :: int_file type ( String ), allocatable , dimension (:), target :: hex_ints , hex_ints_extra type ( String ), dimension (:,:), pointer :: hex_ints_map => null () integer , allocatable , dimension (:), target :: indices , indices_extra integer , dimension (:), pointer :: indices_map => null () integer :: largest , smallest , step , start , i , j integer ( int64 ) :: t1 , t2 , total_length real ( real64 ) :: wall_time , rate largest = huge ( 1 ); smallest = - largest - 1 ; step = ( int ( largest , int64 ) - int ( smallest , int64 )) / 128 write ( * , '(a)' ) 'Writing integers from ' + str ( smallest ) + ' to ' + str ( largest ) + ' in chunks of ' + str ( step ) total_length = 0_int64 allocate ( indices ( step ), hex_ints ( step ) ) allocate ( indices_extra ( smallest + 128 * step : largest ), hex_ints_extra ( smallest + 128 * step : largest ) ) call system_clock ( t1 ) do j = 1 , 128 start = smallest + ( j - 1 ) * step indices_map ( start : start + step - 1 ) => indices do concurrent ( i = start : start + step - 1 ) indices_map ( i ) = i end do call cast ( indices , into = hex_ints , fmt = 'z' ) hex_ints_map ( 1 : step , 1 : 1 ) => hex_ints call int_file % write_file ( hex_ints_map , file_name = 'int32.txt' , append = . true .) total_length = total_length + int_file % len64 () write ( * , '(a)' ) 'File length: ' + str ( total_length / 1e9 , fmt = 'f' , decimals = 3 ) + ' GB in cycle ' + str ( j ) end do do concurrent ( i = smallest + 128 * step : largest - 1 ) indices_extra ( i ) = i end do ; indices_extra ( largest ) = largest call cast ( indices_extra , into = hex_ints_extra , fmt = 'z' ) hex_ints_map ( smallest + 128 * step : largest , 1 : 1 ) => hex_ints_extra call int_file % write_file ( hex_ints_map , file_name = 'int32.txt' , append = . true .) total_length = total_length + int_file % len64 () write ( * , '(a)' ) 'File length: ' + str ( total_length / 1e9 , fmt = 'f' , decimals = 3 ) + ' GB at end of file.' call system_clock ( t2 , count_rate = rate ); wall_time = real ( t2 - t1 , real64 ) / rate write ( * , '(a)' ) 'Total time for write: ' + str ( wall_time / 60 , fmt = 'f' , decimals = 3 ) + ' minutes' nullify ( indices_map , hex_ints_map ); deallocate ( indices , indices_extra , hex_ints , hex_ints_extra ) end program main On Linux, this should take around five minutes with gfortran , and four minutes with ifx / ifort using highest optimizations, and the resulting file size is 46.96 GB .","tags":"","loc":"page/Examples/benchmark.html"}]}